<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Holub on Patterns(2) | greg.lee's blog</title><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/highlights/dracula.css"><link rel="canonical" href="https://daniel-hebn.github.io/2018/01/29/2018-01-29-Holub-on-Patterns-2/">
<meta name="description" content="3장 라이프 게임Clock 서브 시스템: Observer 디자인 패턴Clock은 이벤트를 처리하는 객체들(Observer)에 주기적으로 클록 틱(clock tick) 이벤트를 통지한다. Observer 의 주요 목적은 이벤트를 발생시키는 객체와…">
<meta property="og:type" content="article">
<meta property="og:title" content="Holub on Patterns(2)">
<meta property="og:url" content="https://daniel-hebn.github.io/2018/01/29/2018-01-29-Holub-on-Patterns-2/">
<meta property="og:site_name" content="greg.lee&#39;s blog">
<meta property="og:description" content="3장 라이프 게임Clock 서브 시스템: Observer 디자인 패턴Clock은 이벤트를 처리하는 객체들(Observer)에 주기적으로 클록 틱(clock tick) 이벤트를 통지한다. Observer 의 주요 목적은 이벤트를 발생시키는 객체와…">
<meta property="og:locale" content="ko_KR">
<meta property="og:image" content="https://daniel-hebn.github.io/images/logo/holub-on-patterns.png">
<meta property="article:published_time" content="2018-01-29T14:30:00.000Z">
<meta property="article:modified_time" content="2022-05-07T15:39:42.423Z">
<meta property="article:author" content="Lee Hee Chang">
<meta property="article:tag" content="design-pattern">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://daniel-hebn.github.io/images/logo/holub-on-patterns.png"><meta property="article:author" content="Lee Hee Chang"><meta property="twitter:label1" content="Published at"><meta property="twitter:data1" content="2018-01-29 23:30:00"><meta property="twitter:label2" content="Written by"><meta property="twitter:data2" content="Lee Hee Chang"><link rel="icon" href="/images/rocket.png"><script>(function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'G-1C42LL19JB', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/feed.xml" title="greg.lee's blog" type="application/rss+xml">
</head><body itemscope itemtype="https://schema.org/WebPage"><nav class="menu" id="menu"><div class="menu-inner"><div class="menu__left-area"><div class="menu__item"><a class="menu__item__link menu__item__link--brand" href="/" title="Home" rel="home"><img class="menu__item__link--brand__image" src="/images/rocket.png" alt="greg.lee's blog"><span class="menu__item__link--brand__label">greg.lee's blog</span></a></div></div><div class="menu__right-area"><div class="menu__item"><a class="menu__item__link" href="/">Home</a></div><div class="menu__item"><a class="menu__item__link" href="/about">About</a></div><div class="menu__item"><a class="menu__item__link" href="/archives">Archives</a></div></div></div></nav><div class="page-background"></div><div class="content-container"><div class="content-outer"><div class="content-inner" itemscope itemtype="https://schema.org/Blog"><article class="article" id="article" itemscope itemtype="https://schema.org/BlogPosting"><h1 class="article__title" itemprop="headline">Holub on Patterns(2)</h1><div class="article__meta"><time class="article__meta__time" datetime="2018-01-29T14:30:00.000Z" itemprop="datePublished">2018-01-29 23:30:00</time><div class="article__meta__categories"><a class="article__meta__categories__item" href="/categories/design-pattern/">design-pattern</a></div></div><div class="article__contents"><img src="/images/logo/holub-on-patterns.png"><h1 id="3장-라이프-게임"><a href="#3장-라이프-게임" class="headerlink" title="3장 라이프 게임"></a>3장 라이프 게임</h1><h2 id="Clock-서브-시스템-Observer-디자인-패턴"><a href="#Clock-서브-시스템-Observer-디자인-패턴" class="headerlink" title="Clock 서브 시스템: Observer 디자인 패턴"></a>Clock 서브 시스템: Observer 디자인 패턴</h2><p>Clock은 이벤트를 처리하는 객체들(Observer)에 주기적으로 클록 틱(clock tick) 이벤트를 통지한다.</p>
<p>Observer 의 주요 목적은 이벤트를 발생시키는 객체와 이벤트를 처리하는 객체 간의 결합도를 줄이는 것이다.</p>
<table>
<thead>
<tr>
<th>이벤트를 발생시키는 객체</th>
<th>이벤트를 처리하는 객체</th>
</tr>
</thead>
<tbody><tr>
<td>Observable</td>
<td>Observer</td>
</tr>
<tr>
<td>Subject</td>
<td>Observer</td>
</tr>
<tr>
<td>Publish</td>
<td>Subscribe</td>
</tr>
</tbody></table>
<p>Observable 은 이벤트 메시지를 Observer 에 보내고, 이 메시지는 Observer 인터페이스의 메서드 인자를 통해 구체 Observer 에 통지된다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subscriber</span> <span class="keyword">implements</span> <span class="title">ActionListener</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">		... <span class="comment">// 이벤트 발생 시 취할 행동</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이제 사용자가 이벤트를 발생시키면 Observable 은 Observer 인터페이스의 하나 혹은 그 이상의 메서드를 호출함으로써 구체 Observer 에 통지한다. 이 때 실제로 Observer 에게 통지하는 코드는 Commend 객체에 캡슐화 되어 있다.</p>
<p>아래 예제와 같이 익명 내부 클래스를 사용하여 Observer 패턴을 실체화할 수도 있다. 이와 같은 구현으로 Observer 패턴의 세 부분 모두를 한 곳에 모을 수 있다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="keyword">volatile</span> Boolean menuItemSelected = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Client</span><span class="params">(JMenu topMenu)</span> </span>&#123;</span><br><span class="line">		JMenuItem myItem = <span class="keyword">new</span> JMenuItem(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">		myItem.addActionListener(</span><br><span class="line">			<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">					menuItemSelected = <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		);</span><br><span class="line">		topMenu.add(myItem);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Concrete Observer/Subscriber 역할은 Listener(Observer) 인터페이스를 구현하는 클래스가 맡게 된다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Clock.instance().addClockListener(</span><br><span class="line">	<span class="keyword">new</span> Clock.Listener() &#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// 클록 틱 이벤트를 처리하는 코드 </span></span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>구체 Observer/Subscriber 는 addClockListener() 를 호출해 자신을 Publish 에 등록하며, addClockListener 메서드는 Publish 객체에 Universe 인스턴스를 위임한다. Universe 객체는 Clock.instance().startTicking() 을 호출하여 클록을 시작시키고, 이후부터 리스너가 주기적으로 이벤트 통지를 받는다 (등록된 리스너의 tick() 메서드가 호출된다)</p>
<p>여기서 내가 자체적으로 정리한 것을 기록하면 아래와 같다.</p>
<blockquote><p>Pub/Sub</p>
<ol>
<li><p>Pub 은<br>a. Sub 를 등록<br>b. Sub 에게 이벤트 통지<br>c. Sub 를 해제 </p>
</li>
<li><p>Sub 은<br>a. 이벤트를 받는 Listener 를 구현<br>b. Pub 에게 자신을 등록 </p>
</li>
<li><p>Event (Interface)<br>a. pub/sub 간의 연결. 이벤트</p>
</li>
</ol>
<p>1.b. 와 2.a. 가 동일하다<br>1.b. 가 호출되면 2.a. 가 실행된다. </p>
<p>2 는 3 의 interface 를 구현하고 1 은 1.b. 를 호출할 때<br>2 의 3 interface 를 호출한다. </p>
</blockquote>

<h2 id="Observer-구현하기-Publish-클래스"><a href="#Observer-구현하기-Publish-클래스" class="headerlink" title="Observer 구현하기: Publish 클래스"></a>Observer 구현하기: Publish 클래스</h2><p>지금까지 많은 개발자들의 경험을 통해 Observer 는 구현하기 매우 어렵다고 밝혀졌고 특히 스윙과 같이 여러 스레드가 상호 작용하는 환경에서는 더욱 그러하다. 스윙의 통지는 스윙 서브시스템에 의해 생성된 ‘이벤트’ 스레드에서 처리된다. 모든 실제 처리는 스윙 이벤트 스레드에서 일어나며 이 이벤트 스레드가 사용자 입력 액션에 반응한다. 이 때 이벤트 핸들러 상의 스윙 코드와 메인 스레드상의 코드가 동시에 같은 객체에 접근할 수 있기 때문에 동기화를 적절히 하지 않는다면 충돌은 피할 수 없다.</p>
<p>불행히도 아래와 같은 구현으로는 이러한 환경에 올바르게 대처할 수 없다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Publisher1</span> </span>&#123;</span><br><span class="line">	ArrayList subscribers = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Runnable subscriber)</span> </span>&#123;</span><br><span class="line">		subscribers.add(subscriber);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">cancelSubscription</span><span class="params">(Runnable subscriber)</span> </span>&#123;</span><br><span class="line">		subscribers.remove(subscriber);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">fireEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; subscribers.size() ; i++)</span><br><span class="line">			((Runnable) subscribers.get(i)).run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이벤트를 통지하는 도중에 객체 리스트를 수정하는 작업은 있을 수 있는 일이고, 이벤트 통지 사이클은 어느 정도의 시간을 소요할 수 있다. 이 때 run() 메서드의 구현은 클라이언트 클래스가 제공하는 것이기 때문에 얼마나 오랜 시간 동안 수행될지 알 수 없다. 이벤트 통지를 하는 동안 subscribe() 메서드를 잠구어 놓는 것은 이벤트 구독을 요청하는 스레드를 ‘굶겨 죽일 수도’ 있게 된다. 만약 이와 같은 ‘기아’ 를 없애기 위해 fireEvent() 에 synchronized 를 제거하면, 어떤 스레드에서 subscribe() 혹은 cancel() 메서드를 수행하는 동안, 다른 스레드에서 fireEvent() 를 수행시킬 수 있기 때문이다.</p>
<p>이번에는 관점을 달리하여 동기화된 방법의 장점을 살펴보자. fireEvent() 메서드가 비동기적인 상황에서는 통지 중에 추가한 구독자가 리스트의 마지막에 추가되어 구독하기 전에 발생한 통지를 받을 수도 있다. fireEvent() 메서드의 동기화 버전에서는 이러한 문제가 없다.</p>
<p>그렇다면 어떻게 해야 하는가? 몇 가지 방법이 있다. 첫 번째 방법은 구체적인 클래스 이름 대신에 Collection 인터페이스를 이용하고 리스트 탐색을 위해 Iterator 를 사용하는 것이다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList subscribers = <span class="keyword">new</span> ArrayList(); 를</span><br><span class="line">Collection subscribers = <span class="keyword">new</span> LinkedList() 로 변경</span><br></pre></td></tr></table></figure>

<p>이렇게 하면 이터레이션 연산이 진행 중인 동안 add(..) 혹은 remove(..) 가 호출되면 예외가 발생하게 된다. 그러므로 이벤트 통지를 하고 있는 동안 리스너를 등록하려 시도하면 예외를 받게 되고, 리스너 등록을 다시 시도해야 한다. 하지만 이 방법은 Observer 에 너무 많은 짐을 떠넘기는 방법이다.</p>
<p>다른 접근 방법은 복사를 이용하는 것이다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fireEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Collection localCopy;</span><br><span class="line">	<span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">		localCopy = subscribers.clone();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (Iterator i = subscribers.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">		((Runnable) i.next()).run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>clone() 을 이용하여 구독 객체 리스트의 복사본을 만들었다. 그리고 복사본을 이용하여 구독 객체들에 통지를 한다. 통지를 하는 동안 원본 리스트는 사용되지 않기 때문에 통지 프로세스에 영향을 끼치지 않으면서도 리스트를 수정할 수 있게 된다. 이 접근 방법은 앞에서 논의했던 문제점은 해결하지만 새로운 문제를 야기한다.</p>
<p>첫째, 이벤트 통지가 복사본으로부터 이루어지므로 구독 객체가 구독을 취소한 후에도 이벤트 통지를 할 가능성이 있다. 물론 되게 드문 일이나 우리가 구현하는 애플리케이션에서 이 문제가 중요한 것이라면 이 점을 명심하고 방어적으로 작성하기 바란다.</p>
<p>둘째, 이벤트 통지는 자주 일어날 수 있는데 이때마다 복사본을 만드는 것은 효율적이지 못하다. 대신 드물게 일어나는 구독 취소가 일어났을 때에만 복사본을 만드는 것이 현명할 것이다. (어떻게 한다는 것인지는… 기술되지 않음. 스스로 고민해보자) 해당 이슈를 해결한 멋진 코드는 뒤에 기술할 예정이다.</p>
<p>아래의 코드는 Clock 클래스로부터 Publisher 가 Observer 를 어떻게 처리하는지를 보여주는 부분을 발췌한 것이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Publisher publisher = <span class="keyword">new</span> Publisher();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Listener</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">tick</span><span class="params">()</span></span>;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addClockListener</span><span class="params">(Listener l)</span> </span>&#123;</span><br><span class="line">	publisher.subscribe(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	publisher.publish(</span><br><span class="line">		<span class="keyword">new</span> Publisher.Distributor() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deliverTo</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">				((Listener) subscriber).tick();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addClockListener(…) 는 단순히 Publisher 객체로 메시지 처리를 위임한다 (Observable 에 Observer 를 등록하는 것) 클록이 ‘똑딱’ 할 때마다 호출되는 tick() 메서드는 모든 구독 객체에 이벤트가 발생했음을 통지한다. Clock 은 이를 Publisher 에 실제 통지를 수행하는 Command 객체(Publisher.Distributor()) 를 넘김으로써 수행한다. 그러면 Publisher 는 Distributor 객체의 deliverTo() 메서드를 여러 번 호출하게 되며, 호출 시마다 이 메서드에 다른 구독 객체를 넘겨준다. (어떻게 여러 번 호출하지?)</p>
<p>Command 객체가 Observer 에 어떻게 통지할 것인가에 대한 정보를 캡슐화하기 때문에, Publisher는 통지 메커니즘을 Command 객체에 위임할 수 있다. 즉, Publisher 는 실제로 구독 객체에 어떻게 통지 (어떻게 처리) 하는지에 대한 정보를 가지고 있지 않다. 구독과 관련된 정보는 Publisher 가 아닌 Command 객체가 갖고 있다. Publisher 는 구독 객체의 리스트를 관리하고 Distributer 의 구현체가 구독 객체들에 통지를 어떻게 할지 결정한다는 것을 알고 있다.</p>
<p>이제 본격적으로 위에서 이야기한 이슈를 해결하는 코드를 살펴본다. Publisher 객체는 구독 객체들을 연결 리스트를 이용하여 관리한다. 이 때 단일 연결 리스트를 직접 구현하였다. 리스트의 각 노드는 구독 객체와 다음 Node 에 대한 레퍼런스를 지니고 있다. 생성자는 새로운 노드를 생성하고, 이 노드를 리스트에 연결시킨다. 이 때 새로 생성된 노드가 리스트의 헤드가 된다. 생성자에 새로운 구독 객체와 리스트 헤드의 레퍼런스를 넘겨주면, 노드는 next 레퍼런스를 이전의 헤드 레퍼런스를 가리키면서 스스로 리스트의 헤드가 된다. subscribe() 메서드는 리스트의 헤드에 대한 레퍼런스를 새로 생성된 노드 객체에 대한 레퍼런스로 교체한다. Node 의 모든 필드는 final 이므로 Node 는 불변(immutable) 객체이며 한 번 생성하면 수정할 수 없다. 결과적으로 여러 스레드가 Node 객체에 접근하더라도 안전하며 동기화를 하지 않아도 된다.</p>
<p>이벤트가 발생하면 클라이언트 클래스는 publish() 메서드를 호출하고, publish() 메서드는 리스트의 머리에서 꼬리까지 순회하면서 각 구독 객체가 publish(…) 의 인자로 넘어온 deliveryAgent Command 객체를 받아들이도록(accept) 요청한다. Node 의 accept 메서드를 보면 하는 일은 단지 deliverTo(…) 메서드를 호출하여 deliveryAgent 가 이벤트 통지 작업을 하도록 요청하는 것 밖에 없다. 그러므로 실제로는 deliveryAgent 가 구독 객체에 이벤트가 발생했음을 알리게 된다. (자세한 건 Visitor 패턴에서 논의)</p>
<p>이런 구조를 가질 경우 어떤 스레드가 publish 호출 직후 다른 스레드가 subscribe(b) 를 호출한다고 하면, 새로운 노드는 통지가 시작될 때는 리스트에 없었고 통지를 받는 첫 번째 구독 객체부터 연결 리스트를 타고 꼬리 객체까지 통지가 전달된다. 또한 구독 해지를 한다면 재귀를 이용해 삭제할 노드를 찾은 후에 다시 원 호출로 돌아오게 되고, 이 과정에서 실제 노드 삭제가 일어나지는 않지만 삭제할 노드 왼쪽에 있는 모든 노드를 새로 생성하게 된다. 물론 새로 생성된 노드는 기존의 구독 객체들에 대한 레퍼런스를 갖도록 초기화된다. </p>
<p>이제 해당 코드 전체를 작성한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*&lt;PRE&gt;</span></span><br><span class="line"><span class="comment">*class EventGenerator &#123;</span></span><br><span class="line"><span class="comment">*	interface Listener &#123;</span></span><br><span class="line"><span class="comment">*		notify(String why);</span></span><br><span class="line"><span class="comment">*	&#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*	private Publisher publisher = new Publisher();</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*	public void addEventListener(Listener l) &#123;</span></span><br><span class="line"><span class="comment">*		publisher.subscribe(l);</span></span><br><span class="line"><span class="comment">*	&#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*	public void removeEventListener(Listener l) &#123;</span></span><br><span class="line"><span class="comment">*		publisher.cancelSubscription(l);</span></span><br><span class="line"><span class="comment">*	&#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*	public void someEventHasHappend(final String reason) &#123;</span></span><br><span class="line"><span class="comment">*		publisher.publish(</span></span><br><span class="line"><span class="comment">*			new Publisher.Distributor() &#123;</span></span><br><span class="line"><span class="comment">*				public void deliverTo(Object subscriber) &#123;</span></span><br><span class="line"><span class="comment">*					((Listener)subscriber).notify(reason);</span></span><br><span class="line"><span class="comment">*				&#125;</span></span><br><span class="line"><span class="comment">*			&#125;</span></span><br><span class="line"><span class="comment">*		);</span></span><br><span class="line"><span class="comment">*	&#125;</span></span><br><span class="line"><span class="comment">*&#125;</span></span><br><span class="line"><span class="comment">*&lt;/PRE&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Publisher</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Distributor</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">deliverTo</span><span class="params">(Object subscriber)</span></span>; <span class="comment">// Visitor 패턴의 visit 메서드</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">final</span> Object subscriber;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">final</span> Node next;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="title">Node</span><span class="params">(Object subscriber, Node next)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.subscriber = subscriber;</span><br><span class="line">			<span class="keyword">this</span>.next = next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Node <span class="title">remove</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (target == subscriber)</span><br><span class="line">				<span class="keyword">return</span> next;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (next == <span class="keyword">null</span>) </span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> java.util.NoSuchElementException(target.toString());</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Node(subscriber, next.remove(target));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Distributor deliveryAgent)</span> </span>&#123;</span><br><span class="line">			deliveryAgent.deliverTo(subscriber); <span class="comment">// deliveryAgent 는 visitor 이다.</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> Node subscribers = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">(Distributor deliveryAgent)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (Node cursor = subscribers; cursor != <span class="keyword">null</span> ; cursor = cursor.next)</span><br><span class="line">			cursor.accept(deliveryAgent);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">		subscribers = <span class="keyword">new</span> Node(subscriber, subscribers);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelSubscription</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">		subscriber = subscribers.remove(subscriber);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="article__tags"><a class="article__tags__item" href="/tags/design-pattern/">design-pattern</a></div><div class="article__author" itemscope itemprop="author" itemtype="https://schema.org/Person"><img class="article__author__image" src="/images/greg_lee_c.png" alt="Lee Hee Chang"><a class="article__author__link" title="About Lee Hee Chang" rel="author">Lee Hee Chang</a><p class="article__author__desc">greg.lee 의 프로그래밍과 여러 생각에 대해 끄적이는 공간입니다.</p><div class="article__author__socials"></div><meta itemprop="name" content="Lee Hee Chang"></div><div class="sharer" id="sharer"><div class="sharer-inner"><div class="sharer__right"><button class="sharer__item" id="sharer-facebook"><i class="fa fa-facebook-official"></i></button><button class="sharer__item" id="sharer-twitter"><i class="fa fa-twitter"></i></button><button class="sharer__item" id="sharer-pinterest"><i class="fa fa-pinterest"></i></button><button class="sharer__item" id="sharer-pocket"><i class="fa fa-get-pocket"></i></button></div></div></div><!-- Disqus Code--><!-- Meta Tags for Structured Data--><meta itemprop="dateModified" content="2022-05-07T15:39:42.423Z"><meta itemprop="articleBody" content="3장 라이프 게임Clock 서브 시스템: Observer 디자인 패턴Clock은 이벤트를 처리하는 객체들(Observer)에 주기적으로 클록 틱(clock tick) 이벤트를 통지한다.
Observer 의 주요 목적은 이벤트를 발생시키는 객체와 이벤트를 처리하는 객체 간의 결합도를 줄이는 것이다.



이벤트를 발생시키는 객체
이벤트를 처리하는..."><meta itemprop="url" content="https://daniel-hebn.github.io/2018/01/29/2018-01-29-Holub-on-Patterns-2/"><meta itemprop="mainEntityOfPage" content="https://daniel-hebn.github.io/2018/01/29/2018-01-29-Holub-on-Patterns-2/"><div itemscope itemtype="https://schema.org/Organization" itemprop="publisher"><meta itemprop="name" content="greg.lee's blog"><div itemscope itemprop="logo" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://daniel-hebn.github.io/images/rocket.png"></div></div><div itemscope itemtype="https://schema.org/ImageObject" itemprop="image"><meta itemprop="contentUrl" content="https://daniel-hebn.github.io/images/logo/holub-on-patterns.png"><meta itemprop="url" content="https://daniel-hebn.github.io/images/logo/holub-on-patterns.png"><meta itemprop="width" content="360"><meta itemprop="height" content="180"></div></article><section class="related-posts"><h3>Related posts</h3><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2018/01/28/2018-01-28-Holub-on-Patterns-1/"><div class="related-posts__item__background" style="background-image:url('/images/logo/holub-on-patterns.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">Holub on Patterns(1)</span></a></div></section></div></div></div><footer id="footer"><div class="widgets"><div class="widgets-inner"><!-- Jade doesn't support dynamic inclusion with `each`.--><!-- So, I just hard coded the file names that will be included.--><div class="widgets__item"><h3 class="widgets__item__heading">Recent posts</h3><ul class="recent-posts"><li class="recent-posts__item"><a href="/2021/09/16/2021-09-16-%EC%A0%9C%ED%92%88-%EA%B0%9C%EB%B0%9C%EC%A0%84%EC%97%90-%EA%B0%80%EC%9E%A5-%EB%A8%BC%EC%A0%80-%EC%83%9D%EA%B0%81%ED%95%B4%EB%B3%B4%EB%A9%B4-%EC%A2%8B%EC%9D%80-%EC%A7%88%EB%AC%B8/">제품 개발전에 가장 먼저 생각해보면 좋은 질문</a></li><li class="recent-posts__item"><a href="/2019/10/24/2019-10-24-elasticsearch-%EC%9D%B4%EC%8A%88-%EB%8C%80%EC%9D%91-1/">elasticsearch 이슈 대응 (1)</a></li><li class="recent-posts__item"><a href="/2019/10/20/2019-10-20-elk-&amp;-kafka-%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%A1%9C%EA%B7%B8-%EC%88%98%EC%A7%91-%EB%B0%8F-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EA%B5%AC%EC%B6%95-(2)/">elk &amp; kafka 기반의 로그 수집 및 모니터링 구축 (2)</a></li><li class="recent-posts__item"><a href="/2019/10/18/2019-10-18-elk-&amp;-kafka-%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%A1%9C%EA%B7%B8-%EC%88%98%EC%A7%91-%EB%B0%8F-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EA%B5%AC%EC%B6%95-(1)/">elk &amp; kafka 기반의 로그 수집 및 모니터링 구축 (1)</a></li><li class="recent-posts__item"><a href="/2018/06/29/2018-06-29-ssh-%EC%82%AC%EC%9A%A9/">ssh 사용</a></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Archives</h3><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">9월 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">10월 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">6월 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">4월 2018</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">2월 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">1월 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">12월 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">6월 2017</a><span class="archive-list-count">1</span></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Categories</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/performance/">performance</a><span class="category-list-count">5</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/design-pattern/">design-pattern</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/elasticsearch/">elasticsearch</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/elasticsearch/maintenance/">maintenance</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/elasticsearch/monitoring/">monitoring</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/http/">http</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/http/RESTful/">RESTful</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/concurrency/">concurrency</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/spring/transaction/">transaction</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/ssh/">ssh</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%EC%9D%BC%ED%95%98%EB%8A%94%EB%B0%A9%EC%8B%9D/">일하는방식</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%EC%9D%BC%ED%95%98%EB%8A%94%EB%B0%A9%EC%8B%9D/%EC%A7%88%EB%AC%B8%ED%95%98%EA%B8%B0/">질문하기</a><span class="category-list-count">1</span></li></ul></li></ul></div></div></div><p class="copyright"><small>© 2022 Lee Hee Chang<br>Powered by <a href="https://hexo.io" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a>, Theme by <a href="https://github.com/hyunseob" rel="external nofollow noopener noreferrer" target="_blank">HyunSeob</a></small></p></footer><script src="/js/sharer.min.js"></script></body></html>
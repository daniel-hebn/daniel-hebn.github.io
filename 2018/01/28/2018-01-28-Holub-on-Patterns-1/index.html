<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Holub on Patterns(1) | greg.lee's blog</title><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/highlights/dracula.css"><link rel="canonical" href="https://daniel-hebn.github.io/2018/01/28/2018-01-28-Holub-on-Patterns-1/">
<meta name="description" content="2장 인터페이스로 프로그래밍하기 그리고 몇 개의 생성패턴간략히 인상적인 문구들만 정리한다.  디자인 패턴은 크게 보면 구현 상속(extends)을 인터페이스 상속(implements)으로 바꾸는 방법을 설명하고 있다. 구현 상속보다는 인터페이스…">
<meta property="og:type" content="article">
<meta property="og:title" content="Holub on Patterns(1)">
<meta property="og:url" content="https://daniel-hebn.github.io/2018/01/28/2018-01-28-Holub-on-Patterns-1/">
<meta property="og:site_name" content="greg.lee&#39;s blog">
<meta property="og:description" content="2장 인터페이스로 프로그래밍하기 그리고 몇 개의 생성패턴간략히 인상적인 문구들만 정리한다.  디자인 패턴은 크게 보면 구현 상속(extends)을 인터페이스 상속(implements)으로 바꾸는 방법을 설명하고 있다. 구현 상속보다는 인터페이스…">
<meta property="og:locale" content="ko_KR">
<meta property="og:image" content="https://daniel-hebn.github.io/images/logo/holub-on-patterns.png">
<meta property="article:published_time" content="2018-01-28T14:30:00.000Z">
<meta property="article:modified_time" content="2022-05-07T15:21:39.943Z">
<meta property="article:author" content="Lee Hee Chang">
<meta property="article:tag" content="design-pattern">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://daniel-hebn.github.io/images/logo/holub-on-patterns.png"><meta property="article:author" content="Lee Hee Chang"><meta property="twitter:label1" content="Published at"><meta property="twitter:data1" content="2018-01-28 23:30:00"><meta property="twitter:label2" content="Written by"><meta property="twitter:data2" content="Lee Hee Chang"><link rel="icon" href="/images/rocket.png"><script>(function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'G-1C42LL19JB', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/feed.xml" title="greg.lee's blog" type="application/rss+xml">
</head><body itemscope itemtype="https://schema.org/WebPage"><nav class="menu" id="menu"><div class="menu-inner"><div class="menu__left-area"><div class="menu__item"><a class="menu__item__link menu__item__link--brand" href="/" title="Home" rel="home"><img class="menu__item__link--brand__image" src="/images/rocket.png" alt="greg.lee's blog"><span class="menu__item__link--brand__label">greg.lee's blog</span></a></div></div><div class="menu__right-area"><div class="menu__item"><a class="menu__item__link" href="/">Home</a></div><div class="menu__item"><a class="menu__item__link" href="/about">About</a></div><div class="menu__item"><a class="menu__item__link" href="/archives">Archives</a></div></div></div></nav><div class="page-background"></div><div class="content-container"><div class="content-outer"><div class="content-inner" itemscope itemtype="https://schema.org/Blog"><article class="article" id="article" itemscope itemtype="https://schema.org/BlogPosting"><h1 class="article__title" itemprop="headline">Holub on Patterns(1)</h1><div class="article__meta"><time class="article__meta__time" datetime="2018-01-28T14:30:00.000Z" itemprop="datePublished">2018-01-28 23:30:00</time><div class="article__meta__categories"><a class="article__meta__categories__item" href="/categories/design-pattern/">design-pattern</a></div></div><div class="article__contents"><img src="/images/logo/holub-on-patterns.png"><h1 id="2장-인터페이스로-프로그래밍하기-그리고-몇-개의-생성패턴"><a href="#2장-인터페이스로-프로그래밍하기-그리고-몇-개의-생성패턴" class="headerlink" title="2장 인터페이스로 프로그래밍하기 그리고 몇 개의 생성패턴"></a>2장 인터페이스로 프로그래밍하기 그리고 몇 개의 생성패턴</h1><p>간략히 인상적인 문구들만 정리한다.</p>
<ul>
<li>디자인 패턴은 크게 보면 구현 상속(extends)을 인터페이스 상속(implements)으로 바꾸는 방법을 설명하고 있다.</li>
<li>구현 상속보다는 인터페이스 상속이 훨씬 바람직하다.</li>
<li>OO 원리를 충실히 지키면 결합도를 상당히 낮출 수 있다. 데이터와 구현을 은닉하고, 가능하면 인터페이스를 사용하여 프로그래밍하라</li>
<li>extends 는 깨지기 쉬운 기반 클래스 문제를 야기한다. 이는 부모 클래스와 자식 클래스 간의 강한 결합 관계 때문이다.</li>
<li>파생 클래스가 상속을 원치 않는 기반 클래스의 메서드에서 예외를 던지는 방법은 나쁜 방법이다. 이는 LSP 를 어기는 것이며 결과적으로 OCP 까지 지킬 수 없게 된다.</li>
<li>상속 대신 합성을 사용하라</li>
<li>인터페이스 상속을 이용하면 상속된 기능이 없기 때문에 잘못될 일도 없다. </li>
<li>인터페이스 관점에서 프로그래밍하라. 의존 관계 역전의 원칙(DIP)을 준수하라</li>
<li>추상화를 잘하면 유연해진다. 하지만 복잡성도 증가한다. 유연성과 복잡성 사이에서 적절한 트레이드 오프를 하라</li>
</ul>
<h2 id="올바른-OO-디자인-과정"><a href="#올바른-OO-디자인-과정" class="headerlink" title="올바른 OO 디자인 과정"></a>올바른 OO 디자인 과정</h2><ol>
<li>‘도메인 모델’ 에 대해 학습한다.</li>
<li>고객이 해결하려는 것이 무엇인지를, 즉 요구 사항을 유도한다</li>
<li>모든 문제에 대한 유스케이스를 규명한다. 이 때, 유스케이스란 사용자가 수행하여 유의미한 결과를 내놓는 단일 작업을 의미한다</li>
<li>유스케이스에 기술된 목적을 성취하기 위해 어떤 액티비티가 필요한지를 생각한다</li>
<li>전 단계에서 규명된 액티비티를 수행하기 위해 런타임에 객체들이 서로 어떻게 메시지를 보내는지를 보여주는 ‘동적 모델’을 생성한다.</li>
</ol>
<p>동적 모델링을 하는 동안 객체들이 어떻게 상호 작용을 하는지를 보여주는 클래스 다이어그램을 생성한다. </p>
<p>동적 모델링으로부터 클래스 다이어그램을 도출하라. 이렇게 하면 실제 필요한 연산과 관계만이 포함되기 때문에 정적 모델이 현실적이 되고 가벼워진다.</p>
<p>동적 모델링을 충분히 수행한 후 특정 객체들이 모두 사용하고 있는 공통 연산 집합이 식별되었다면, 공통 연산 집합을 기반 클래스에 구현한 후 구현 상속(extends)을 통해 재사용할 수 있다.</p>
<p>만약 두 클래스가 동일한 연산을 다른 방식으로 수행한다면 각 클래스가 공통의 인터페이스를 구현해야 한다. 예를 들어 Employee 인터페이스를 Manager 와 Engineer 클래스가 다른 방식으로 구현할 수 있다. 그리고 두 클래스에 공통적인 연산이 없다면 별도의 클래스를 통해 구현하며 extends 나 implements 관계는 필요 없다. 마지막으로 한 클래스가 다른 클래스에 약간의 연산을 추가한다면 extends 관계가 적절하다. (Manager 는 Employee 가 하는 모든 일을 하고, 여기에 추가적인 일도 한다)</p>
<p>정리하면</p>
<blockquote><dl><dt>Employee 와 Manager 가 동일한 연산을 동일한 방식으로 수행한다.</dt><dd>-&gt; <em>같은 클래스로 구현한다.</em></dd></dl><dl><dt>Employee 와 Manager 가 동일한 연산을 다른 방식으로 수행한다.</dt><dd>-&gt; <em>두 클래스가 공통의 인터페이스를 구현한다</em></dd></dl><dl><dt>Employee 와 Manager 가 공통의 연산이 없다.</dt><dd>-&gt; <em>별도의 클래스로 구현한다.</em></dd></dl><dl><dt>Manager 가 Employee 에 약간의 연산을 추가한다.</dt><dd>-&gt; <em>Manager 가 Employee 를 extends 하도록 한다.</em></dd></dl></blockquote>

<h2 id="extends-제거하기"><a href="#extends-제거하기" class="headerlink" title="extends 제거하기"></a>extends 제거하기</h2><ol>
<li>현재 클래스와 동일한 이름을 갖는 인터페이스를 생성한다.</li>
<li>현재 클래스의 이름을 변경하고 인터페이스를 구현하도록 한다.</li>
<li>new 를 사용하여 Employee 를 생성했던 모든 부분을 바꾸어 준다.</li>
</ol>
<p>허나 new 연산은 객체를 생성하는 클라이언트와 생성되는 객체를 결합시키기 때문에 애써 인터페이스를 도입한 효과가 없다. new 를 제거하거나 최소한 감추어야 한다.</p>
<p>모든 new 호출을 고쳐야만 하는 문제를 해결할 수 있는 좋은 전략 중 하나는 <strong>Abstract Factory 패턴</strong>을 사용하는 것이다. 많은 패턴들이 구현 시 Abstract Factory 패턴을 사용하는 경우가 많기 때문에 Abstract Factory 는 일종의 빌딩 블록이 되는 패턴이라 할 수 있다.</p>
<p>Abstract Factory 의 모든 실체화에서 공통되는 주제는 팩토리를 사용하여 정확한 타입을 모르는 객체를 생성한다는 것이다. 사용자(클라이언트)는 생성하려는 객체가 구현하고 있는 인터페이스만을 알 뿐, 생성 객체의 실제 타입은 알지 못한다. 예를 들어 EmployeeFactory 를 사용하여 new Employee() 를 EmployeeFactory.create() 로 대체할 수 있다. 이 때 create() 메서드는 Employee 인터페이스를 구현하는 어떤 클래스든 반환할 수 있기 때문에 클라이언트 코드는 구현 클래스와 격리된다. 그러므로 클라이언트 코드에 영향을 끼치지 않으면서 Employee 를 구현한 클래스를 마음대로 바꿀 수 있다.</p>
<p>또한 Singleton 을 사용하여 Abstract Factory 를 얻어 오고, Abstract Factory 를 사용하여 실제 클래스가 알려지지 않은 객체를 얻어 오는 것은 많이 사용되는 패턴이다.</p>
<p>‘하나의 객체’ 와 ‘전역 접근’ 이라는 Singleton 의 요구 사항을 만족시키는 가장 쉬운 방법은 모든 것을 static 으로 선언하는 것이다. 하지만 컴파일시에 모든 정보를 알 수 없거나 상속을 통한 커스터마이징이 필요한 경우에는 static 을 사용할 수 없다. 이런 경우에는 전형적인 GoF 식 Singleton 실체화가 필요하다. </p>
<h2 id="Abstract-Factory-패턴"><a href="#Abstract-Factory-패턴" class="headerlink" title="Abstract Factory 패턴"></a>Abstract Factory 패턴</h2><p>Abstract Factory 패턴은 인터페이스(Employee)를 통해 생성하려는 객체의 실체 타입을 은닉시켜 준다. 생성된 객체를 사용하는 클라이언트는 인터페이스만을 알고 있으므로 인터페이스를 구현하고 있는 구체 클래스의 변화로부터 자유롭다. 구체 클래스는 인터페이스보다 변하기 쉽기 때문에 가능하면 인터페이스를 사용하라는 ‘의존 역전의 원칙’(DIP) 을 생각해보자.</p>
<p>Java Collection 을 예로 들면 - Collection 인터페이스는 ArrayList, LinkedList 등의 구현체를 은닉 혹은 격리시켜 주며, Iterator 인터페이스는 각 Collection 구현체가 생성한 Iterator 구현체를 은닉시켜 준다. Collection 인터페이스를 사용하는 클라이언트는 자신이 어떤 Collection 구현체를 사용하고 있는지 알 필요가 없으며, Collection 구현체를 통해 생성한 Iterator 구현체의 경우도 마찬가지다. Collection 인터페이스와 Iterator 인터페이스만 알면 된다. 이와 같은 구조는 인터페이스를 통한 프로그래밍을 가능케 해주며 뛰어난 유연성을 보장해준다. </p>
<h2 id="Command-패턴과-Strategy-패턴"><a href="#Command-패턴과-Strategy-패턴" class="headerlink" title="Command 패턴과 Strategy 패턴"></a>Command 패턴과 Strategy 패턴</h2><p>Command 패턴은 빌딩 블록 패턴이며, Strategy 패턴은 Command 패턴의 특별한 경우이다. Command 패턴의 기본 아이디어는 무엇을 어떻게 해야 한다는 지식을 객체에 캡슐화하여 전달한다는 것이다. 자바 스레드는 전형적인 Command 패턴의 구현체이다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommandObj</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 스레드가 실행될 때 수행할 작업</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Thread controller = <span class="keyword">new</span> Thread( <span class="keyword">new</span> CommandObj() );</span><br><span class="line">controller.start();   <span class="comment">// 스레드를 시작한다.</span></span><br></pre></td></tr></table></figure>

<p>Command 패턴의 주요 특징 중 하나는 Command 객체를 사용하는 클라이언트 클래스가 Command 객체가 무엇을 할지에 대해 아무것도 모른다는 것이다. 또한 Command 패턴 자체를 좀 더 세련된 방식으로 사용하여 ‘되돌리기(undo)’ 시스템과 같은 복잡한 문제를 해결할 수도 있다.</p>
<p>Strategy 패턴은 특정 연산을 ‘어떻게’ 수행할 것인지에 대한 전략을 캡슐화한 Strategy 객체를 전달한다. 이 때 Strategy 객체는 무엇을 수행해야 하는가가 좀 더 명확한 Command 객체라 할 수 있다.</p>
<h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><ul>
<li>Singleton: 제한된 수의 객체를 생성한다.</li>
<li>Abstract Factory: 관련된 객체 군(family) 중 하나를 생성하도록 해주는 ‘팩토리’. 이 때 생성되는 객체의 구체 타입은 인터페이스를 통해 가려진다. 구체 타입이 아닌 인터페이스를 통해 프로그래밍하기 때문이다.</li>
<li>Template Method: 기반 클래스에서 일반 알고리즘을 정의하고, 파생 클래스에서 알고리즘이 사용하는 추상 메서드를 오버라이딩한다.</li>
<li>Factory Method: 구체 클래스가 알려지지 않은 객체를 생성하는 Template Method 이다. Factory Method 는 객체를 생성하는 Factory Method 일 뿐이다.</li>
<li>Command: 알려지지 않은 알고리즘을 캡슐화하는 객체이다.</li>
<li>Strategy: 알려진 문제를 해결하는 전략을 캡슐화하는 객체이다. 어떤 알고리즘을 다양한 전략을 통해 해결할 수 있도록 해준다. </li>
</ul>
<ol>
<li>캡슐화 </li>
</ol>
<ul>
<li>캡슐화는 데이터와 연산을 한데 묶는 것을 의미한다. 프로그램에서 흘러 다니는 데이터와 결합도는 보통 비례 관계에 있다. 캡슐화는 이와 같은 데이터 흐름으로 인한 결합도 증가를 막아주는 언어적 장치이다. </li>
<li>은닉이란 내부 데이터, 내부 연산을 외부에서 접근하지 못하도록 은닉(hiding) 혹은 격리(isolation)시키는 것을 의미한다. 객체는 서비스 제공자(Service Provider)이어야 한다. 그러므로 ‘어떻게’ 연산을 수행하는가는 철저히 은닉되어야 하며, 외부로 공개된 인터페이스 혹은 계약을 통해서만 프로그래밍해야 한다.</li>
<li>캡슐화와 은닉이 잘 되려면 객체에 책임을 적절히 분배해 주어야 한다. 단일 책임 원칙(SRP)은 좋은 기준이 된다.</li>
<li>getter/setter 는 가능한 사용을 자제해야 한다. 이는 ‘데이터를 요청하지 말고 도움을 요청하라’ 라는 OO 금언과 관련 있다. 구현이 잘 은닉되어 있고 책임이 제대로 분배되어 있다면 getter/setter 는 그리 필요치 않다.</li>
<li>구체 클래스는 인터페이스보다 변하기 쉽다. 그러므로 인터페이스를 이용하라는 의존 관계 역전의 원칙(DIP)을 생각하자. 인터페이스를 통해 구체 클래스를 은닉하도록 하자.</li>
<li>하나의 클래스가 전체적으로는 하나의 역할만을 맡고 있지만 관점에 따라서는 2개 이상의 인터페이스를 구현하고 있을 수 있다. 이런 경우에는 하나의 클래스가 여러 타입이 된다. </li>
</ul>
<ol start="2">
<li>캡슐화</li>
</ol>
<ul>
<li>상속에는 구현 상속(extends)과 인터페이스 상속(implements)이 있다.</li>
<li>구현 상속에는 재사용과 다형성 획득이라는 두 가지 기능이 있다.</li>
<li>인터페이스 상속에는 다형성 획득과 인터페이스를 통한 은닉이라는 기능이 있다. </li>
<li>구현 상속에는 ‘깨지기 쉬운 기반 클래스 문제’가 있기 때문에 다형성 획득이라는 측면에서 보자면 인터페이스 상속이 안전하고 낫다</li>
<li>재사용 측면에서 보자면 보통 상속보다는 합성이 좋다. 상속은 불필요한 결합도를 증가시키기 때문이다. </li>
<li>그러므로 다형성을 위해서는 인터페이스 상속을 사용하고, 재사용을 위해서는 합성을 사용하자. 구현 상속은 언제? 여러 클래스가 공통의 연산 집합을 공유하고 있을 때 정규화를 위해 사용하면 된다.</li>
<li>상속을 할 때는 상속한 메서드에서 예외를 던지면 안 된다. 예외를 던지면 다형성을 이용하기 어렵기 때문이다. LSP 를 지키자</li>
</ul>
<ol start="3">
<li>다형성</li>
</ol>
<ul>
<li>캡슐화와 은닉은 ‘무엇을’ 과 ‘어떻게’ 를 분리시켜 준다. 상속은 ‘어떻게’를 다양하게 정의하도록 해준다. 다형성은 이 둘을 조합하여 런타임에 ‘무엇을’ ‘어떻게’ 실행시킬 것인지를 동적으로 정하게 된다. 이는 OCP 를 지킬 수 있도록 해준다.</li>
<li>예를 들어 로그 메시지를 다양한 방식 (콘솔, 하나의 파일, 날짜별 파일, DB, Mail, TCP/IP) 으로 출력할 수 있을 것이다. 이곳이 바로 다형성이 등장할 곳이다. 로깅 라이브러리는 ‘무엇’(what) 에 해당하는 로그 찍기 메서드만 제공하면 된다. 그리고 설정 파일을 통해 ‘어떻게’(how)에 해당하는 로그 출력 방식을 다양하게 변경할 수 있도록 한다. </li>
</ul>
<ol start="4">
<li>정리</li>
</ol>
<ul>
<li>변하는 부분과 변하지 않는 부분을 분리하여 변화하는 부분에 다형성을 통해 확장과 수정의 가능성을 열어두는 것이 중요하다</li>
<li>변화가 예상되는 장소에 인터페이스를 삽입해 놓는 것은 복잡함을 크게 증가시키지 않는다. 인터페이스를 적극 도입하여 사용하라</li>
</ul>
</div><div class="article__tags"><a class="article__tags__item" href="/tags/design-pattern/">design-pattern</a></div><div class="article__author" itemscope itemprop="author" itemtype="https://schema.org/Person"><img class="article__author__image" src="/images/greg_lee_c.png" alt="Lee Hee Chang"><a class="article__author__link" title="About Lee Hee Chang" rel="author">Lee Hee Chang</a><p class="article__author__desc">greg.lee 의 프로그래밍과 여러 생각에 대해 끄적이는 공간입니다.</p><div class="article__author__socials"></div><meta itemprop="name" content="Lee Hee Chang"></div><div class="sharer" id="sharer"><div class="sharer-inner"><div class="sharer__right"><button class="sharer__item" id="sharer-facebook"><i class="fa fa-facebook-official"></i></button><button class="sharer__item" id="sharer-twitter"><i class="fa fa-twitter"></i></button><button class="sharer__item" id="sharer-pinterest"><i class="fa fa-pinterest"></i></button><button class="sharer__item" id="sharer-pocket"><i class="fa fa-get-pocket"></i></button></div></div></div><!-- Disqus Code--><!-- Meta Tags for Structured Data--><meta itemprop="dateModified" content="2022-05-07T15:21:39.943Z"><meta itemprop="articleBody" content="2장 인터페이스로 프로그래밍하기 그리고 몇 개의 생성패턴간략히 인상적인 문구들만 정리한다.

디자인 패턴은 크게 보면 구현 상속(extends)을 인터페이스 상속(implements)으로 바꾸는 방법을 설명하고 있다.
구현 상속보다는 인터페이스 상속이 훨씬 바람직하다.
OO 원리를 충실히 지키면 결합도를 상당히 낮출 수 있다. 데이터와 구현을..."><meta itemprop="url" content="https://daniel-hebn.github.io/2018/01/28/2018-01-28-Holub-on-Patterns-1/"><meta itemprop="mainEntityOfPage" content="https://daniel-hebn.github.io/2018/01/28/2018-01-28-Holub-on-Patterns-1/"><div itemscope itemtype="https://schema.org/Organization" itemprop="publisher"><meta itemprop="name" content="greg.lee's blog"><div itemscope itemprop="logo" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://daniel-hebn.github.io/images/rocket.png"></div></div><div itemscope itemtype="https://schema.org/ImageObject" itemprop="image"><meta itemprop="contentUrl" content="https://daniel-hebn.github.io/images/logo/holub-on-patterns.png"><meta itemprop="url" content="https://daniel-hebn.github.io/images/logo/holub-on-patterns.png"><meta itemprop="width" content="360"><meta itemprop="height" content="180"></div></article><section class="related-posts"><h3>Related posts</h3><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2018/01/29/2018-01-29-Holub-on-Patterns-2/"><div class="related-posts__item__background" style="background-image:url('/images/logo/holub-on-patterns.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">Holub on Patterns(2)</span></a></div></section></div></div></div><footer id="footer"><div class="widgets"><div class="widgets-inner"><!-- Jade doesn't support dynamic inclusion with `each`.--><!-- So, I just hard coded the file names that will be included.--><div class="widgets__item"><h3 class="widgets__item__heading">Recent posts</h3><ul class="recent-posts"><li class="recent-posts__item"><a href="/2021/09/16/2021-09-16-%EC%A0%9C%ED%92%88-%EA%B0%9C%EB%B0%9C%EC%A0%84%EC%97%90-%EA%B0%80%EC%9E%A5-%EB%A8%BC%EC%A0%80-%EC%83%9D%EA%B0%81%ED%95%B4%EB%B3%B4%EB%A9%B4-%EC%A2%8B%EC%9D%80-%EC%A7%88%EB%AC%B8/">제품 개발전에 가장 먼저 생각해보면 좋은 질문</a></li><li class="recent-posts__item"><a href="/2019/10/24/2019-10-24-elasticsearch-%EC%9D%B4%EC%8A%88-%EB%8C%80%EC%9D%91-1/">2019-10-24 elasticsearch 이슈 대응 (1)</a></li><li class="recent-posts__item"><a href="/2019/10/20/2019-10-20-elk-&amp;-kafka-%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%A1%9C%EA%B7%B8-%EC%88%98%EC%A7%91-%EB%B0%8F-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EA%B5%AC%EC%B6%95-(2)/">elk &amp; kafka 기반의 로그 수집 및 모니터링 구축 (2)</a></li><li class="recent-posts__item"><a href="/2019/10/18/2019-10-18-elk-&amp;-kafka-%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%A1%9C%EA%B7%B8-%EC%88%98%EC%A7%91-%EB%B0%8F-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EA%B5%AC%EC%B6%95-(1)/">elk &amp; kafka 기반의 로그 수집 및 모니터링 구축 (1)</a></li><li class="recent-posts__item"><a href="/2018/06/29/2018-06-29-ssh-%EC%82%AC%EC%9A%A9/">ssh 사용</a></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Archives</h3><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">9월 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">10월 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">6월 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">4월 2018</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">2월 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">1월 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">12월 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">6월 2017</a><span class="archive-list-count">1</span></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Categories</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/performance/">performance</a><span class="category-list-count">5</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/design-pattern/">design-pattern</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/elasticsearch/">elasticsearch</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/elasticsearch/maintenance/">maintenance</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/elasticsearch/monitoring/">monitoring</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/http/">http</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/http/RESTful/">RESTful</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/concurrency/">concurrency</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/spring/transaction/">transaction</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/ssh/">ssh</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%EC%9D%BC%ED%95%98%EB%8A%94%EB%B0%A9%EC%8B%9D/">일하는방식</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%EC%9D%BC%ED%95%98%EB%8A%94%EB%B0%A9%EC%8B%9D/%EC%A7%88%EB%AC%B8%ED%95%98%EA%B8%B0/">질문하기</a><span class="category-list-count">1</span></li></ul></li></ul></div></div></div><p class="copyright"><small>© 2022 Lee Hee Chang<br>Powered by <a href="https://hexo.io" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a>, Theme by <a href="https://github.com/hyunseob" rel="external nofollow noopener noreferrer" target="_blank">HyunSeob</a></small></p></footer><script src="/js/sharer.min.js"></script></body></html>
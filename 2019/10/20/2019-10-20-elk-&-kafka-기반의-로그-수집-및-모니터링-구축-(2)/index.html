<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>elk &amp; kafka 기반의 로그 수집 및 모니터링 구축 (2) | greg.lee's blog</title><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/highlights/dracula.css"><link rel="canonical" href="https://daniel-hebn.github.io/2019/10/20/2019-10-20-elk-&-kafka-기반의-로그-수집-및-모니터링-구축-(2)/">
<meta name="description" content="zookeeper 와 kafka 설치 및 구성본 포스팅에서는 지난 포스팅 의 아키텍쳐 중에서 zookeeper 와 kafka 의 간단한 소개 및 설치, 구성에 대한 내용을 기술한다.    zookeeper 소개주키퍼는 분산 시스템의 코디네이션…">
<meta property="og:type" content="article">
<meta property="og:title" content="elk &amp; kafka 기반의 로그 수집 및 모니터링 구축 (2)">
<meta property="og:url" content="https://daniel-hebn.github.io/2019/10/20/2019-10-20-elk-&-kafka-%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%A1%9C%EA%B7%B8-%EC%88%98%EC%A7%91-%EB%B0%8F-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EA%B5%AC%EC%B6%95-(2)/">
<meta property="og:site_name" content="greg.lee&#39;s blog">
<meta property="og:description" content="zookeeper 와 kafka 설치 및 구성본 포스팅에서는 지난 포스팅 의 아키텍쳐 중에서 zookeeper 와 kafka 의 간단한 소개 및 설치, 구성에 대한 내용을 기술한다.    zookeeper 소개주키퍼는 분산 시스템의 코디네이션…">
<meta property="og:locale" content="ko_KR">
<meta property="og:image" content="https://daniel-hebn.github.io/images/logo/elastic.png">
<meta property="article:published_time" content="2019-10-20T14:30:00.000Z">
<meta property="article:modified_time" content="2022-05-07T15:39:42.426Z">
<meta property="article:author" content="Lee Hee Chang">
<meta property="article:tag" content="monitoring">
<meta property="article:tag" content="log">
<meta property="article:tag" content="metric">
<meta property="article:tag" content="elasticsearch">
<meta property="article:tag" content="kafka">
<meta property="article:tag" content="logstash">
<meta property="article:tag" content="kibana">
<meta property="article:tag" content="zookeeper">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://daniel-hebn.github.io/images/logo/elastic.png"><meta property="article:author" content="Lee Hee Chang"><meta property="twitter:label1" content="Published at"><meta property="twitter:data1" content="2019-10-20 23:30:00"><meta property="twitter:label2" content="Written by"><meta property="twitter:data2" content="Lee Hee Chang"><link rel="icon" href="/images/rocket.png"><script>(function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'G-1C42LL19JB', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/feed.xml" title="greg.lee's blog" type="application/rss+xml">
</head><body itemscope itemtype="https://schema.org/WebPage"><nav class="menu" id="menu"><div class="menu-inner"><div class="menu__left-area"><div class="menu__item"><a class="menu__item__link menu__item__link--brand" href="/" title="Home" rel="home"><img class="menu__item__link--brand__image" src="/images/rocket.png" alt="greg.lee's blog"><span class="menu__item__link--brand__label">greg.lee's blog</span></a></div></div><div class="menu__right-area"><div class="menu__item"><a class="menu__item__link" href="/">Home</a></div><div class="menu__item"><a class="menu__item__link" href="/about">About</a></div><div class="menu__item"><a class="menu__item__link" href="/archives">Archives</a></div></div></div></nav><div class="page-background"></div><div class="content-container"><div class="content-outer"><div class="content-inner" itemscope itemtype="https://schema.org/Blog"><article class="article" id="article" itemscope itemtype="https://schema.org/BlogPosting"><h1 class="article__title" itemprop="headline">elk &amp; kafka 기반의 로그 수집 및 모니터링 구축 (2)</h1><div class="article__meta"><time class="article__meta__time" datetime="2019-10-20T14:30:00.000Z" itemprop="datePublished">2019-10-20 23:30:00</time><div class="article__meta__categories"><a class="article__meta__categories__item" href="/categories/elasticsearch/">elasticsearch</a><span class="article__meta__categories__separator">></span><a class="article__meta__categories__item" href="/categories/elasticsearch/monitoring/">monitoring</a></div></div><div class="article__contents"><img src="/images/logo/elastic.png"><h2 id="zookeeper-와-kafka-설치-및-구성"><a href="#zookeeper-와-kafka-설치-및-구성" class="headerlink" title="zookeeper 와 kafka 설치 및 구성"></a>zookeeper 와 kafka 설치 및 구성</h2><p>본 포스팅에서는 <a href="https://daniel-hebn.github.io/2019/10/18/2019-10-18-Elastic-Stack-kafka-%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%A1%9C%EA%B7%B8-%EC%88%98%EC%A7%91-%EB%B0%8F-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EA%B5%AC%EC%B6%95-1/#elastic-stack-amp-kafka">지난 포스팅</a> 의 아키텍쳐 중에서 <code>zookeeper</code> 와 <code>kafka</code> 의 간단한 소개 및 설치, 구성에 대한 내용을 기술한다. </p>
<img src="/2019/10/20/2019-10-20-elk-&-kafka-%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%A1%9C%EA%B7%B8-%EC%88%98%EC%A7%91-%EB%B0%8F-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EA%B5%AC%EC%B6%95-(2)/elastic_kafka_architecture2.png" class title="elasticsearch &amp; kafka Architecture">

<h3 id="zookeeper-소개"><a href="#zookeeper-소개" class="headerlink" title="zookeeper 소개"></a>zookeeper 소개</h3><p>주키퍼는 분산 시스템의 코디네이션 작업을 가능하게 하는 아파치 프로젝트 오픈소스이다. 코디네이션 작업은 여러 프로세스들에 대한 것인데, 이러한 작업의 목적은 프로세스들 간의 협력이나 경합을 조절하는 것이다.</p>
<ul>
<li><code>협력</code>이란 프로세스들이 작업을 함께 수행해야 하고 다른 프로세스가 진행될 수 있도록 어떤 일을 해야 하는 것을 의미한다. 예를 들어 마스터 워커 구조에서 워커는 자신이 일을 할 수 있는 상태임을 마스터에게 알리고, 이에 마스터는 워커에게 작업을 할당한다.</li>
<li><code>경합</code>은 두 프로세스가 동시에 작업을 진행할 수 없는 상황을 의미한다. 그래서 한 프로세스는 다른 프로세스가 끝날 때까지 기다려야 하는데, 예를 들어 읽기/쓰기 락 또는 글로벌 락과 같은 것이 있다.  </li>
</ul>
<p>또한, 프로세스 상호 간의 진행 상황을 전달하기 위한 설정(configuration) 과 같은 메타데이터를 주키퍼를 통하여 공유하기도 한다.  </p>
<p>주키퍼는 기본 요소를 표현하기 위해 파일 시스템의 트리(tree) 처럼 계층적으로 구성된 <code>znode</code> 라고 부르는 작은 데이터 노드를 사용하는데, 주키퍼의 API 는 이를 조작하는 일련의 작업(operation) 이다.</p>
<img src="/2019/10/20/2019-10-20-elk-&-kafka-%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%A1%9C%EA%B7%B8-%EC%88%98%EC%A7%91-%EB%B0%8F-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EA%B5%AC%EC%B6%95-(2)/zookeeper_tree.png" class title="zookeeper_tree">

<p>신규 <code>znode</code> 를 생성할 때는 모드를 명시하여 하는데 각 모드는 <code>znode</code> 의 동작 방법을 결정한다.</p>
<ul>
<li><strong>영구 znode (persistent)</strong>: 생성 후 명시적으로 delete API 가 호출되어야 삭제되는 <code>znode</code> 이다. 마스터가 작업을 할당하고 장애가 발생해도 워커에게 할당된 작업들은 유지되어야 한다. 이런 경우 <code>영구 znode</code> 가 유용하다.</li>
<li><strong>임시 znode (ephemeral)</strong>: 임시 znode 를 생성한 클라이언트가 주키퍼와 연결이 끊어지거나 클라이언트에 장애가 발생하면 삭제되는 <code>znode</code> 이다. 마스터 워커 예시에서 마스터 <code>znode</code> 는 <code>임시 znode</code> 이다. 만약 마스터에 문제가 발생했을 때 반드시 <code>znode</code> 도 제거되어야 하고 이런 경우 <code>임시 znode</code> 가 유용하다. </li>
<li><strong>순차 znode (sequential)</strong>: 순차 znode 는 유일하면서 점차 증가하는 정수로 할당된다. 예를 들어 클라이언트가 순차 <code>znode</code> 를 <em>/tasks/task-</em> 경로에 생성하는 경우, 주키퍼는 1 이라는 순차 번호를 할당하고 경로의 끝에 덧붙인다. <code>순차 znode</code> 는 유일한 이름의 <code>znode</code> 를 생성하는 편리한 방법을 제공한다. 또한 <code>znode</code> 의 생성 순서도 쉽게 확인이 가능하다.   </li>
</ul>
<p><small> &gt; 주키퍼 ZooKeeper 23 ~ 45p 참고 (에이콘출판사)</small></p>
<h3 id="zookeeper-설치-및-구성"><a href="#zookeeper-설치-및-구성" class="headerlink" title="zookeeper 설치 및 구성"></a>zookeeper 설치 및 구성</h3><p>아파치 카프카는 컨슈머 클라이언트와 카프카 클러스터에 관한 메타데이터를 저장하기 위해 주키퍼를 사용한다. 주키퍼는 카프카 배포판에 포함되어 있어서 이를 사용해도 되지만 여기서는 별도로 다운로드하여 설치를 진행한다.</p>
<p>설치 대상 서버에 아래와 같은 작업을 진행한다 (서버 1 ~ 5)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://apache.mirror.cdnetworks.com/zookeeper/zookeeper-3.5.5/apache-zookeeper-3.5.5-bin.tar.gz</span><br><span class="line">$ tar -xvf apache-zookeeper-3.5.5-bin.tar.gz</span><br><span class="line">$ mv apache-zookeeper-3.5.5-bin /usr/<span class="built_in">local</span>/zookeeper</span><br><span class="line">$ mkdir -p /var/lib/zookeeper</span><br><span class="line">$ cat &gt; /usr/<span class="built_in">local</span>/zookeeper/conf/zoo.cfg &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">&gt; tickTime=2000</span></span><br><span class="line"><span class="string">&gt; dataDir=/var/lib/zookeeper</span></span><br><span class="line"><span class="string">&gt; clientPort=2181</span></span><br><span class="line"><span class="string">&gt; EOF</span></span><br></pre></td></tr></table></figure>

<br>

<p>서버 한 대에서 주키퍼 설치 후 아래를 실행하면 독립 실행 모드로 동작한다. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/<span class="built_in">local</span>/zookeeper/bin/zkServer.sh start</span><br><span class="line"></span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure>

<p>개발 환경에서는 하나의 주키퍼와 카프카를 이용하여 개발을 진행하는 것이 가능하겠지만, 운영 환경에서는 주키퍼와 카프카의 클러스터를 구성하여 사용하는 것이 일반적이다. </p>
<p>주키퍼의 클러스터는 앙상블(<code>ensemble</code>) 이라는 별도의 명칭이 있고, 하나의 앙상블은 여러 개의 서버(노드) 를 맴버로 가질 수 있다.    </p>
<p>앙상블은 홀수 개의 서버를 맴버로 가지고, 앙상블의 서버 중 과반수가 작동 가능하다면 언제든지 요청 처리(데이터 읽기, 쓰기) 가 가능하다. 앙상블의 서버가 다섯 대로 구성된다면, 서버 한 대가 장애 중이라도 앙상블에 대한 유지보수 작업이 가능하므로 가능하다면 다섯 대 이상의 노드를 맴버로 가지도록 하자. </p>
<p>주키퍼 서버를 앙상블로 구성하려면 각 서버가 공통된 구성 파일을 가져야 한다. 또한, 각 서버는 자신의 ID 번호를 지정한 myid 파일을 데이터 디렉토리에 갖고 있어야 한다.<br>예를 들어 앙상블에 속한 서버들의 호스트 이름이 zoo1.example.com, zoo2.example.com, zoo3.example.com … 이라면 구성 파일의 내역은 다음과 같이 될 수 있다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ vi /usr/<span class="built_in">local</span>/zookeeper/conf/zoo.cfg 이 후 아래의 내용 반영</span><br><span class="line"></span><br><span class="line">tickTime=2000</span><br><span class="line">dataDir=/var/lib/zookeeper</span><br><span class="line">clientPort=2181</span><br><span class="line">initLimit=20</span><br><span class="line">syncLimit=5</span><br><span class="line">server.1=zoo1.example.com:2888:3888</span><br><span class="line">server.2=zoo2.example.com:2888:3888</span><br><span class="line">server.3=zoo3.example.com:2888:3888</span><br><span class="line">server.4=zoo4.example.com:2888:3888</span><br><span class="line">server.5=zoo5.example.com:2888:3888</span><br></pre></td></tr></table></figure>
<ul>
<li>X: 각 서버의 ID 번호이며 정수이다.</li>
<li>initLimit &amp; tickTime: initLimit 는 팔로어가 리더에 접속할 수 있는 시간이며 tickTime 을 기준으로 설정된다. 여기서는 initLimit 가 20 * 2000(밀리초) = 40초가 된다.</li>
<li>clientPort: 클라이언트가 앙상블에 연결 시 사용할 port </li>
<li>syncLimit: 리더가 될 수 있는 팔로어의 최대 갯수를 나타냄</li>
<li>hostname: 각 서버의 호스트 이름이나 IP </li>
<li>peerPort: 앙상블의 서버들이 상호 통신하는 데 사용하는 TCP 포트 (default: 2888)</li>
<li>leaderPort: 리더를 선출하는 데 사용하는 TCP 포트 (default: 3888)</li>
</ul>
<br>

<p>이 후 각 서버는 dataDir 에 지정된 디렉토리에 각각 myid 라는 이름의 파일을 가지고 있어야 한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zoo1.example.com 서버에서는 /var/lib/zookeeper/ 경로에 </span><br><span class="line">myid 라는 파일이 존재해야 하고, myid 의 내용은 1 이 있어야 한다.</span><br><span class="line"></span><br><span class="line">$ vi /var/lib/zookeeper/myid </span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<br> 

<p>여기까지 진행 후 5대의 서버에서 주키퍼를 각각 띄우면 앙상블 구성은 성공적으로 진행된 것이다.<br>(systemctl 를 이용하여 주키퍼를 서비스 등록 후 사용하는 것이 편리하다)<br><br></p>
<h3 id="kafka-소개"><a href="#kafka-소개" class="headerlink" title="kafka 소개"></a>kafka 소개</h3><p>카프카는 메시지 발행/구독 시스템이고 분산환경에 특화되어 설계되어 있다는 특징을 가지고 있다. 카프카의 데이터는 지속해서 저장하고 읽을 수 있고 시스템 장애에 대비하고 확장에 따른 성능 저하를 방지하기 위해 데이터가 분산 처리될 수 있다.</p>
<p>카프카의 데이터 기본 단위는 메시지(message)이고 이는 데이터베이스의 행(row)이나 레코드(record)에 비유될 수 있다. 카프카의 메시지는 바이트 배열의 데이터로 간주하므로 특정 형식이나 의미를 갖지 않는다. </p>
<p>카프카의 메시지 데이터는 토픽(<code>topic</code>)으로 분류된 파티션(<code>partition</code>)에 수록되는데, 이 때 데이터를 수록할 파티션을 결정하기 위해 일괸된 해시 값으로 키를 생성한다. 따라서 같은 키를 갖는 메시지는 항상 같은 파티션에 수록된다. </p>
<img src="/2019/10/20/2019-10-20-elk-&-kafka-%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%A1%9C%EA%B7%B8-%EC%88%98%EC%A7%91-%EB%B0%8F-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EA%B5%AC%EC%B6%95-(2)/anatomy_of_kafka.png" class title="anatomy_of_kafka">

<p>하나의 토픽은 여러 개의 파티션을 갖지만, 메시지 처리 순서는 토픽이 아닌 파티션별로 유지 관리된다. 또한 각 파티션은 서로 다른 서버에 분산되어 수평적인 확장이 가능하고 그렇기 때문에 단일 서버로 처리할 때보다 성능이 훨씬 우수하다. </p>
<br>

<p>카프카의 클라이언트는 기본적으로 프로듀서와 컨슈머라는 두 가지 형태가 있다.</p>
<ul>
<li>프로듀서는 새로운 메시지를 생성하고, 생성된 메시지는 특정 토픽의 파티션에 저장된다. 이 때 프로듀서는 메시지가 어떤 파티션에 수록되는지는 관여하지 않는다.</li>
<li>컨슈머는 하나 이상의 토픽을 구독하여 메시지가 생성된 순서로 읽으며, 메시지의 오프셋(<code>offset</code>)을 유지하여 읽는 메시지의 위치를 알 수 있다. 그리고 주키퍼나 카프카에서는 각 파티션에서 마지막에 읽은 메시지의 오프셋을 저장하고 있으므로 컨슈머가 읽기를 중단했다 하더라도 다시 언제든 그 다음 메시지를 읽을 수 있다.</li>
</ul>
<img src="/2019/10/20/2019-10-20-elk-&-kafka-%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%A1%9C%EA%B7%B8-%EC%88%98%EC%A7%91-%EB%B0%8F-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EA%B5%AC%EC%B6%95-(2)/kafka_producer_consumer.png" class title="kafka_producer_consumer">

<p>카프카의 장점은 다음과 같다</p>
<ul>
<li>다중 프로듀서: 여러 클라이언트가 많은 토픽을 사용하거나 같은 토픽을 같이 사용해도 카프카는 무리 없이 많은 프로듀서의 메시지를 처리할 수 있다. 즉, 여러 프로듀서가 하나의 토픽에 메시지 발급을 동시에 할 수 있다는 말이다.</li>
<li>다중 컨슈머: 여러 컨슈머가 상호 간섭 없이 어떤 메시지 스트림도 읽을 수 있다. 이는 특정 메시지를 소비하면 다른 클라이언트에서 그 메시지를 사용할 수 없는 큐(queue) 시스템과는 다르다. </li>
<li>디스크 기반의 보존: 카프카는 다중 컨슈머를 처리할 수 있을 뿐만 아니라 지속해서 메시지를 보존할 수도 있다. 따라서 컨슈머 애플리케이션이 항상 실시간으로 실행되지 않아도 된다. 메시지는 보존 옵션(보존 기간이나 토픽 크기)에 따라 디스크에 저장되어 보존된다. 또한 토픽별로 보존 옵션을 선택할 수도 있으므로 컨슈머의 요구에 맞게 메시지 보존 옵션을 가질 수 있다. 따라서 처리가 느리거나 접속 폭주로 인해 컨슈머가 메시지를 읽는 데 실패하더라도 데이터가 유실될 위험이 없다.</li>
<li>확장성: 처음에는 검증의 목적으로 하나의 브로커로 시작하되 점차적으로 브로커의 수를 늘려 클러스터의 크기를 키울 수 있다. 확장 작업은 시스템 전체의 사용에 영향을 주지 않고 클러스터가 온라인 상태일때 도 수행될 수 있다. </li>
</ul>
<p><small> &gt; 카프카 핵심 가이드 4 ~ 11p 참고 (제이펍출판사)</small></p>
<br>

<h3 id="kafka-설치-및-구성"><a href="#kafka-설치-및-구성" class="headerlink" title="kafka 설치 및 구성"></a>kafka 설치 및 구성</h3><p>설치 대상 서버에 아래와 같은 작업을 진행한다 (서버 6 ~ 8)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://apache.mirror.cdnetworks.com/kafka/2.3.0/kafka_2.11-2.3.0.tgz </span><br><span class="line">$ tar -xvf kafka_2.11-2.3.0.tgz</span><br><span class="line">$ mv kafka_2.11-2.3.0 /usr/<span class="built_in">local</span>/kafka</span><br><span class="line">$ mkdir /data/kafka-logs</span><br><span class="line">$ vi /usr/<span class="built_in">local</span>/kafka/config/server.properties</span><br><span class="line"></span><br><span class="line">[server.properties]</span><br><span class="line">broker.id=1</span><br><span class="line">log.dirs=/data/kafka-logs</span><br><span class="line">zookeeper.connect=zoo1.example.com:2181,zoo2.example.com:2181,zoo3.example.com:2181,zoo4.example.com:2181,zoo5.example.com:2181/kafka</span><br><span class="line">num.recovery.threads.per.data.dir=4</span><br><span class="line">log.retention.hours=672</span><br></pre></td></tr></table></figure>
<ul>
<li>broker.id: 모든 카프카 브로커는 broker.id 에 설정하는 정수로 된 번호(식별자)를 가져야 한다. 단, 하나의 카프카 클러스터 내에서는 고유한 값이어야 한다.</li>
<li>log.dirs: 카프카는 모든 메시지를 로그 세그먼트(segment) 파일을 모아서 디스크에 저장한다. 이 때 쉼표를 이용하여 여러 경로를 지정할 수 있다. </li>
<li>zookeeper.connect: 브로커의 메타데이터를 저장하기 위해 사용되는 주키퍼의 위치를 나타낸다. 기본 구성값은 localhost:2181 이고, <code>호스트이름:포트/경로</code> 의 형식으로 지정할 수 있다. 예시의 뒷 부분에 /kafka 가 있음을 유의하자 </li>
<li>num.recovery.threads.per.data.dir: 브로커의 시작 또는 종료 시의 로그를 복구할 때 사용할 스레드의 갯수를 말한다. 이 때 log.dirs 에 지정된 경로가 3 이고 num.recovery.threads.per.data.dir 가 8 이라면 전체 스레드의 갯수는 24가 된다.</li>
<li>log.retention.hours: 카프카가 얼마 동안 메시지를 보존할지를 설정한다. </li>
</ul>
<br>

<p>이후 각 서버에서 카프카를 실행하면 3대의 브로커로 이루어지는 카프카 클러스터가 형성된다고 볼 수 있다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/<span class="built_in">local</span>/kafka/bin/kafka-server-start.sh \</span><br><span class="line">-daemon /usr/<span class="built_in">local</span>/kafka/config/server.properties</span><br></pre></td></tr></table></figure>

<br>

<p>정상적인 구성의 확인을 위해 카프카 클러스터에 토픽을 생성하고 메시지를 읽고 쓰는 테스트를 진행하면 다음과 같다</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- 1. 토픽 생성</span><br><span class="line">$ /usr/<span class="built_in">local</span>/kafka/kafka-topics.sh --create \</span><br><span class="line">--zookeeper zoo1.example.com:2181,zoo2.example.com:2181,zoo3.example.com:2181,zoo4.example.com:2181,zoo5.example.com:2181/kafka \</span><br><span class="line">--replication-factor 1 --partitions 1 --topic <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">- 2. 토픽 확인</span><br><span class="line">$ /usr/<span class="built_in">local</span>/kafka/kafka-topics.sh \</span><br><span class="line">--zookeeper zoo1.example.com:2181,zoo2.example.com:2181,zoo3.example.com:2181,zoo4.example.com:2181,zoo5.example.com:2181/kafka \</span><br><span class="line">--describe --topic <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">Topic:<span class="built_in">test</span>	PartitionCount:1	ReplicationFactor:1	Configs:</span><br><span class="line">	Topic: <span class="built_in">test</span>	Partition: 0	Leader: 2	Replicas: 2	Isr: 2</span><br><span class="line"></span><br><span class="line">- 3. 메시지 저장</span><br><span class="line">$ /usr/<span class="built_in">local</span>/kafka/kafka-console-producer.sh \</span><br><span class="line">--broker-list kafka-server1:9092,kafka-server2:9092,kafka-server3:9092 \</span><br><span class="line">--topic <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">Test Message1</span><br><span class="line">Test Message2</span><br><span class="line">^C</span><br><span class="line"></span><br><span class="line">- 4. 메시지 읽기</span><br><span class="line">$ /usr/<span class="built_in">local</span>/kafka/kafka-console-consumer.sh </span><br><span class="line">--bootstrap-server kafka-server1:9092,kafka-server2:9092,kafka-server3:9092 \</span><br><span class="line">--topic <span class="built_in">test</span> --from-beginning</span><br><span class="line"></span><br><span class="line">Test Message 1</span><br><span class="line">Test Message 2</span><br></pre></td></tr></table></figure>

<p>여기까지 문제 없이 진행되었다면 3대의 브로커로 이루어진 카프카 클러스터가 정상적으로 설치되었다고 볼 수 있다.<br>(systemctl 를 이용하여 카프카를 서비스 등록 후 사용하는 것이 편리하다)</p>
<br>

<h2 id="logback-과-kafka-를-활용한-로그-수집"><a href="#logback-과-kafka-를-활용한-로그-수집" class="headerlink" title="logback 과 kafka 를 활용한 로그 수집"></a>logback 과 kafka 를 활용한 로그 수집</h2><p>이제 kafka 를 메시지 브로커로 활용하여 서비스의 로그 및 메트릭 수집을 진행하도록 하자</p>
<p>우선 해당 포스팅에서는 </p>
<ol>
<li>로깅용 kafka topic 을 생성한 후에</li>
<li>logback 의 kafka appender 를 활용하여 kafka 에 로그를 저장</li>
</ol>
<p>하는 과정을 진행한다.</p>
<p>이렇게 저장된 로그는 추후 logstash 를 통하여 elasticsearch 쪽으로 전달되고 kibana 를 통하여 visualizing 된 로그를 보게 될 것이다.</p>
<h3 id="로깅용-kafka-topic-생성"><a href="#로깅용-kafka-topic-생성" class="headerlink" title="로깅용 kafka topic 생성"></a>로깅용 kafka topic 생성</h3><p>카프카 클러스터 내에서 토픽의 크기가 확장되는 방법이 파티션이다. 따라서 브로커가 추가될 때 클러스터 전체에 걸쳐 메시지가 고르게 저장되도록 파티션 갯수를 설정하는 것이 중요한데, 보통 클러스터의 브로커 수와 같게 하거나 배수로 토픽의 파티션 개수를 설정한다. 이렇게 하면 브로커마다 파티션이 고르게 분산될 수 있으며, 저장 메시지도 고르게 분산될 것이다. </p>
<p>대개 프로듀서는 컨슈머보다 훨씬 빠르게 처리되므로 처리량을 조사하지 않아도 무방하고, 파티션 하나는 항상 한 컨슈머가 소비한다. 따라서 컨슈머의 처리 속도와 목표 처리량을 산정하여 파티션 개수를 산정해야 한다.</p>
<p>필자는 우선 브로커 3개에서 토픽당 파티션 3개, 복제 팩터도 3을 설정하여 로깅용 토픽을 구성하였다. 지난 포스팅에서 기술했듯이 초당 800여건 / 분당 5만여건의 메시지를 무리없이 처리하는 것을 확인하였고, 메트릭 수집을 통하여 지속적으로 확인할 것이기에 현재 구성에서 큰 이슈는 없을 것으로 판단하고 있다.</p>
<p>아래의 명령어로 로깅용 토픽을 생성한다. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/<span class="built_in">local</span>/kafka/kafka-topics.sh --create \</span><br><span class="line">--zookeeper zoo1.example.com:2181,zoo2.example.com:2181,zoo3.example.com:2181,zoo4.example.com:2181,zoo5.example.com:2181/kafka \</span><br><span class="line">--replication-factor 3 --partitions 3 --topic log-v1</span><br></pre></td></tr></table></figure>
<br>

<h3 id="logback-의-kafka-appender-를-활용한-로그-저장"><a href="#logback-의-kafka-appender-를-활용한-로그-저장" class="headerlink" title="logback 의 kafka appender 를 활용한 로그 저장"></a>logback 의 kafka appender 를 활용한 로그 저장</h3><blockquote>
<p>필자가 주로 사용하는 개발 환경은 java + spring boot 라서 logback 설정으로 kafka 에 로그를 저장하는 내용을 기술하지만, 카프카에 메시지를 저장하는 방법은 다양할 것이므로… 알아서 하실 것으로 기대한다.<br>도움이 되실 내용만 확인하셔도 된다. </p>
</blockquote>
<p>logback 에서 사용 가능한 custom appender 를 구현하려면 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.baeldung.com/custom-logback-appender">AppenderBase</a> 를 상속하여 자신만의 appender 를 구현하는 방법이 간단하지만, 이미 검증되어 충분히 사용되고 있는 누군가의 구현체를 활용하는 것도 아주 좋은 방법이다. (<del>나도 언젠가는 오픈소스 생태계에 약간이나마 공헌할 날이 오겠지</del>)</p>
<p>필자의 시스템에서는 logback 을 통하여 kafka 에 메시지를 저장하는 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/danielwegener/logback-kafka-appender">logback-kafka-appender</a> 를 활용한다.<br><br></p>
<p>우선 build.gradle 에 아래와 같이 선언한다.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(group = <span class="string">&quot;com.github.danielwegener&quot;</span>, name = <span class="string">&quot;logback-kafka-appender&quot;</span>, version = <span class="string">&quot;0.1.0&quot;</span>)</span><br><span class="line">    implementation(group = <span class="string">&quot;net.logstash.logback&quot;</span>, name = <span class="string">&quot;logstash-logback-encoder&quot;</span>, version = <span class="string">&quot;6.2&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이후 logback.xml 에서 아래와 같이 선언한다.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- logback 예시  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;LOG-KAFKA&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.github.danielwegener.logback.kafka.KafkaAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">&quot;com.github.danielwegener.logback.kafka.encoding.LayoutKafkaMessageEncoder&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.PatternLayout&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                &#123;</span><br><span class="line">                &quot;@timestamp&quot;:&quot;%d&#123;&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSS&#x27;+09:00&#x27;&quot;&#125;&quot;,</span><br><span class="line">                &quot;service&quot;:&quot;example-server&quot;,</span><br><span class="line">                &quot;phase&quot;:&quot;live&quot;,</span><br><span class="line">                &quot;level&quot;:&quot;%level&quot;,</span><br><span class="line">                &quot;thread&quot;:&quot;%thread&quot;,</span><br><span class="line">                &quot;eventId&quot;:&quot;%mdc&#123;key-event-id:--&#125;&quot;,</span><br><span class="line">                &quot;src&quot;:&quot;%logger&#123;0&#125;.%M\(%L\)&quot;,</span><br><span class="line">                &quot;message&quot;:&quot;%msg&quot;,</span><br><span class="line">                &quot;exception&quot;: &quot;%ex&#123;200&#125;&quot;,</span><br><span class="line">                &quot;host&quot;: &quot;%contextName&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">topic</span>&gt;</span>log-v1<span class="tag">&lt;/<span class="name">topic</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">keyingStrategy</span> <span class="attr">class</span>=<span class="string">&quot;com.github.danielwegener.logback.kafka.keying.RoundRobinKeyingStrategy&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">deliveryStrategy</span> <span class="attr">class</span>=<span class="string">&quot;com.github.danielwegener.logback.kafka.delivery.AsynchronousDeliveryStrategy&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">producerConfig</span>&gt;</span>compression.type=snappy<span class="tag">&lt;/<span class="name">producerConfig</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;producerConfig&gt;linger.ms=100&lt;/producerConfig&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;producerConfig&gt;batch.size=327680&lt;/producerConfig&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">producerConfig</span>&gt;</span>retries=1<span class="tag">&lt;/<span class="name">producerConfig</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">producerConfig</span>&gt;</span>max.block.ms=1000<span class="tag">&lt;/<span class="name">producerConfig</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">producerConfig</span>&gt;</span>bootstrap.servers=kafka1.server:9092,kafka2.server:9092,kafka3.server:9092<span class="tag">&lt;/<span class="name">producerConfig</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.example.service&quot;</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;LOG-KAFKA&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>logback 설정에서 topic 은 kafka 에서 로깅 목적으로 생성한 토픽명을 기술하고, producerConfig 중 bootstrap.servers 는 kafka 브로커의 주소를 기술한다.<br>그 외 자세한 설정은 다음의 링크를 참고한다. </p>
<ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://kafka.apache.org/23/javadoc/org/apache/kafka/clients/producer/ProducerConfig.html">kafka producer config</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/danielwegener/logback-kafka-appender">logback-kafka-appender</a></li>
</ul>
<p>logback 설정 이후 서버를 실행하여 지정된 로거로 로깅이 될 때, KafkaAppender 를 통하여 카프카 클러스터에 메시지가 전달되고, 추후 logstash 를 통하여 kafka 에서 메시지를 꺼낼 수 있게 된다. 이렇게 획득한 로그 데이터를 elasticsearch 에 실시간으로 저장한다면, 목적하는 로깅 및 모니터링이 가능한 기반이 시작된다고 할 수 있다.</p>
<br>

<p>다음 포스팅부터는 elasticsearch 및 logstash, kibana 에 대해 이야기하겠다.</p>
<h2 id="참고자료-및-사이트"><a href="#참고자료-및-사이트" class="headerlink" title="참고자료 및 사이트"></a>참고자료 및 사이트</h2><ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="http://acornpub.co.kr/book/zookeeper">주키퍼 ZooKeeper (고가용성 서버를 위한 분산 프로세스 코디네이션)</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://jpub.tistory.com/857">카프카 핵심 가이드: 실시간 데이터와 스트림 프로세싱</a></li>
</ul>
</div><div class="article__tags"><a class="article__tags__item" href="/tags/monitoring/">monitoring</a><a class="article__tags__item" href="/tags/log/">log</a><a class="article__tags__item" href="/tags/metric/">metric</a><a class="article__tags__item" href="/tags/elasticsearch/">elasticsearch</a><a class="article__tags__item" href="/tags/kafka/">kafka</a><a class="article__tags__item" href="/tags/logstash/">logstash</a><a class="article__tags__item" href="/tags/kibana/">kibana</a><a class="article__tags__item" href="/tags/zookeeper/">zookeeper</a></div><div class="article__author" itemscope itemprop="author" itemtype="https://schema.org/Person"><img class="article__author__image" src="/images/greg_lee_c.png" alt="Lee Hee Chang"><a class="article__author__link" title="About Lee Hee Chang" rel="author">Lee Hee Chang</a><p class="article__author__desc">greg.lee 의 프로그래밍과 여러 생각에 대해 끄적이는 공간입니다.</p><div class="article__author__socials"></div><meta itemprop="name" content="Lee Hee Chang"></div><div class="sharer" id="sharer"><div class="sharer-inner"><div class="sharer__right"><button class="sharer__item" id="sharer-facebook"><i class="fa fa-facebook-official"></i></button><button class="sharer__item" id="sharer-twitter"><i class="fa fa-twitter"></i></button><button class="sharer__item" id="sharer-pinterest"><i class="fa fa-pinterest"></i></button><button class="sharer__item" id="sharer-pocket"><i class="fa fa-get-pocket"></i></button></div></div></div><!-- Disqus Code--><!-- Meta Tags for Structured Data--><meta itemprop="dateModified" content="2022-05-07T15:39:42.426Z"><meta itemprop="articleBody" content="zookeeper 와 kafka 설치 및 구성본 포스팅에서는 지난 포스팅 의 아키텍쳐 중에서 zookeeper 와 kafka 의 간단한 소개 및 설치, 구성에 대한 내용을 기술한다. 


zookeeper 소개주키퍼는 분산 시스템의 코디네이션 작업을 가능하게 하는 아파치 프로젝트 오픈소스이다. 코디네이션 작업은 여러 프로세스들에 대한 것인데, 이러한..."><meta itemprop="url" content="https://daniel-hebn.github.io/2019/10/20/2019-10-20-elk-&amp;-kafka-기반의-로그-수집-및-모니터링-구축-(2)/"><meta itemprop="mainEntityOfPage" content="https://daniel-hebn.github.io/2019/10/20/2019-10-20-elk-&amp;-kafka-기반의-로그-수집-및-모니터링-구축-(2)/"><div itemscope itemtype="https://schema.org/Organization" itemprop="publisher"><meta itemprop="name" content="greg.lee's blog"><div itemscope itemprop="logo" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://daniel-hebn.github.io/images/rocket.png"></div></div><div itemscope itemtype="https://schema.org/ImageObject" itemprop="image"><meta itemprop="contentUrl" content="https://daniel-hebn.github.io/images/logo/elastic.png"><meta itemprop="url" content="https://daniel-hebn.github.io/images/logo/elastic.png"><meta itemprop="width" content="360"><meta itemprop="height" content="180"></div></article><section class="related-posts"><h3>Related posts</h3><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2019/10/18/2019-10-18-elk-&amp;-kafka-%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%A1%9C%EA%B7%B8-%EC%88%98%EC%A7%91-%EB%B0%8F-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EA%B5%AC%EC%B6%95-(1)/"><div class="related-posts__item__background" style="background-image:url('/images/logo/elastic.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">elk &amp; kafka 기반의 로그 수집 및 모니터링 구축 (1)</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2019/10/24/2019-10-24-elasticsearch-%EC%9D%B4%EC%8A%88-%EB%8C%80%EC%9D%91-1/"><div class="related-posts__item__background" style="background-image:url('/images/logo/elastic.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">elasticsearch 이슈 대응 (1)</span></a></div></section></div></div></div><footer id="footer"><div class="widgets"><div class="widgets-inner"><!-- Jade doesn't support dynamic inclusion with `each`.--><!-- So, I just hard coded the file names that will be included.--><div class="widgets__item"><h3 class="widgets__item__heading">Recent posts</h3><ul class="recent-posts"><li class="recent-posts__item"><a href="/2021/09/16/2021-09-16-%EC%A0%9C%ED%92%88-%EA%B0%9C%EB%B0%9C%EC%A0%84%EC%97%90-%EA%B0%80%EC%9E%A5-%EB%A8%BC%EC%A0%80-%EC%83%9D%EA%B0%81%ED%95%B4%EB%B3%B4%EB%A9%B4-%EC%A2%8B%EC%9D%80-%EC%A7%88%EB%AC%B8/">제품 개발전에 가장 먼저 생각해보면 좋은 질문</a></li><li class="recent-posts__item"><a href="/2019/10/24/2019-10-24-elasticsearch-%EC%9D%B4%EC%8A%88-%EB%8C%80%EC%9D%91-1/">elasticsearch 이슈 대응 (1)</a></li><li class="recent-posts__item"><a href="/2019/10/20/2019-10-20-elk-&amp;-kafka-%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%A1%9C%EA%B7%B8-%EC%88%98%EC%A7%91-%EB%B0%8F-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EA%B5%AC%EC%B6%95-(2)/">elk &amp; kafka 기반의 로그 수집 및 모니터링 구축 (2)</a></li><li class="recent-posts__item"><a href="/2019/10/18/2019-10-18-elk-&amp;-kafka-%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%A1%9C%EA%B7%B8-%EC%88%98%EC%A7%91-%EB%B0%8F-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EA%B5%AC%EC%B6%95-(1)/">elk &amp; kafka 기반의 로그 수집 및 모니터링 구축 (1)</a></li><li class="recent-posts__item"><a href="/2018/06/29/2018-06-29-ssh-%EC%82%AC%EC%9A%A9/">ssh 사용</a></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Archives</h3><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">9월 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">10월 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">6월 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">4월 2018</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">2월 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">1월 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">12월 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">6월 2017</a><span class="archive-list-count">1</span></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Categories</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/performance/">performance</a><span class="category-list-count">5</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/design-pattern/">design-pattern</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/elasticsearch/">elasticsearch</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/elasticsearch/maintenance/">maintenance</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/elasticsearch/monitoring/">monitoring</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/http/">http</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/http/RESTful/">RESTful</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/concurrency/">concurrency</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/spring/transaction/">transaction</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/ssh/">ssh</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%EC%9D%BC%ED%95%98%EB%8A%94%EB%B0%A9%EC%8B%9D/">일하는방식</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%EC%9D%BC%ED%95%98%EB%8A%94%EB%B0%A9%EC%8B%9D/%EC%A7%88%EB%AC%B8%ED%95%98%EA%B8%B0/">질문하기</a><span class="category-list-count">1</span></li></ul></li></ul></div></div></div><p class="copyright"><small>© 2022 Lee Hee Chang<br>Powered by <a href="https://hexo.io" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a>, Theme by <a href="https://github.com/hyunseob" rel="external nofollow noopener noreferrer" target="_blank">HyunSeob</a></small></p></footer><script src="/js/sharer.min.js"></script></body></html>
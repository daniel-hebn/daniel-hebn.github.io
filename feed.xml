<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>greg.lee&#39;s blog</title>
    <link>https://daniel-hebn.github.io/</link>
    
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    
    <description>greg.lee 의 프로그래밍과 여러 생각에 대해 끄적이는 공간입니다.</description>
    <pubDate>Sat, 07 May 2022 15:26:43 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>제품 개발전에 가장 먼저 생각해보면 좋은 질문</title>
      <link>https://daniel-hebn.github.io/2021/09/16/2021-09-16-%EC%A0%9C%ED%92%88-%EA%B0%9C%EB%B0%9C%EC%A0%84%EC%97%90-%EA%B0%80%EC%9E%A5-%EB%A8%BC%EC%A0%80-%EC%83%9D%EA%B0%81%ED%95%B4%EB%B3%B4%EB%A9%B4-%EC%A2%8B%EC%9D%80-%EC%A7%88%EB%AC%B8/</link>
      <guid>https://daniel-hebn.github.io/2021/09/16/2021-09-16-%EC%A0%9C%ED%92%88-%EA%B0%9C%EB%B0%9C%EC%A0%84%EC%97%90-%EA%B0%80%EC%9E%A5-%EB%A8%BC%EC%A0%80-%EC%83%9D%EA%B0%81%ED%95%B4%EB%B3%B4%EB%A9%B4-%EC%A2%8B%EC%9D%80-%EC%A7%88%EB%AC%B8/</guid>
      <pubDate>Thu, 16 Sep 2021 14:24:47 GMT</pubDate>
      <description>
      
        
        
          &lt;img src=&quot;/images/logo/question.png&quot;/&gt;&lt;h2 id=&quot;쿠팡-다닐-때-가장-인상-깊었던-것은&quot;&gt;&lt;a href=&quot;#쿠팡-다닐-때-가장-인상-깊었던-것은&quot; class=&quot;headerlink&quot; title=&quot;쿠팡 다닐 때 가장 인상 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<img src="/images/logo/question.png"/><h2 id="쿠팡-다닐-때-가장-인상-깊었던-것은"><a href="#쿠팡-다닐-때-가장-인상-깊었던-것은" class="headerlink" title="쿠팡 다닐 때 가장 인상 깊었던 것은.."></a>쿠팡 다닐 때 가장 인상 깊었던 것은..</h2><p>쿠팡에서 일하면서 많은 것을 얻고 배웠다</p><p>그 중에서도 나한테 가장 인상깊게 박혀 있는 것은 </p><ul><li>Spring JPA 와 테스트 코드 작성과 같은 기술적인 것이나 </li><li>애자일과 팀 간의 협업과 같은 업무 방식에 대한 것이 아니라</li><li>제품 개발을 시작하기 전에 스스로 생각하고 확인해봐야 하는 4가지 질문에 관한 것이다</li></ul><p>물론 매순간 아래의 질문을 생각하면서 개발하고 일해왔던 것은 아니지만<br>또 쿠팡 때에는 원하는 만큼의 책임과 권한이 주어지지는 않았지만</p><p>제품을 개발하는데 있어서 정말 좋은 질문이라는 생각을 다시금 하게 된다 </p><h2 id="제품을-설계하고-개발하기-전에-생각해봐야-하는-질문"><a href="#제품을-설계하고-개발하기-전에-생각해봐야-하는-질문" class="headerlink" title="제품을 설계하고 개발하기 전에 생각해봐야 하는 질문"></a>제품을 설계하고 개발하기 전에 생각해봐야 하는 질문</h2><p>제품 개발 전에 지금도 매번 생각해보는 질문은 아래와 같다 </p><p><strong>하기 4대 고객 중심 질문에 의거하여 이니셔티브를 소개해 주십시오</strong></p><blockquote><p>1. 직접 고객이 누구인가?<br>2. 고객을 위해 어떤 일을 하고자 하는가?<br>3. 우리는 어떤 부분을 10배 개선해야 하는가? 우리가 반드시 1위를 차지해야 하는 부분은 무엇인가?<br>4. 성공 여부를 판단하는 지표는 무엇인가?</p></blockquote><p>AND<br>보너스 질문: 윗단과 아랫단을 통틀어서 어떤 리스크가 있으며, 어떻게 리스크를 완화할 계획인가?</p><ul><li>최종 고객은 언제나 최종 소비자, 즉 구매자이다. 하지만 특정 프로젝트의 직접 고객은 최종 소비자가 아닐 수 있다. 그 예로 최종 고객을 지원하는 내부 고객을 지원하는 업무를 들 수 있다</li><li>글로벌 목표를 절대적인 성공 지표로 설정한 후 현지 인풋을 구체화한다. 현지에 맞춰 최적화하느라 글로벌 최적화를 놓치는 오류는 반드시 피해야 한다</li></ul><h2 id="일을-하다보면"><a href="#일을-하다보면" class="headerlink" title="일을 하다보면"></a>일을 하다보면</h2><p>나의 고객이 누구인지, 그 고객의 문제가 무엇인지를 명확히 파악하지 않고 일을 하다보면 엉뚱한 곳에서 리소스를 낭비하게 된다<br>기껏 만들어낸 기능은 고객과 시장에게서 환영 받지 못하고 얼마 지나지 않아 기능 자체가 없어지게 되는 경우도 많다 </p><p>나의 직접적인 고객이 누구이고, 고객을 위해 어떤 문제를 해결하려고 하는지를 항상 명심해야 한다<br>그것이 오래 오래 생존할 수 있는 제 1 원칙이라는 생각이다 </p>]]></content:encoded>
      
      <comments>https://daniel-hebn.github.io/2021/09/16/2021-09-16-%EC%A0%9C%ED%92%88-%EA%B0%9C%EB%B0%9C%EC%A0%84%EC%97%90-%EA%B0%80%EC%9E%A5-%EB%A8%BC%EC%A0%80-%EC%83%9D%EA%B0%81%ED%95%B4%EB%B3%B4%EB%A9%B4-%EC%A2%8B%EC%9D%80-%EC%A7%88%EB%AC%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>2019-10-24 elasticsearch 이슈 대응 (1)</title>
      <link>https://daniel-hebn.github.io/2019/10/24/2019-10-24-elasticsearch-%EC%9D%B4%EC%8A%88-%EB%8C%80%EC%9D%91-1/</link>
      <guid>https://daniel-hebn.github.io/2019/10/24/2019-10-24-elasticsearch-%EC%9D%B4%EC%8A%88-%EB%8C%80%EC%9D%91-1/</guid>
      <pubDate>Thu, 24 Oct 2019 14:34:08 GMT</pubDate>
      <description>
      
        
        
          &lt;img src=&quot;/images/logo/elastic.png&quot;/&gt;&lt;h2 id=&quot;사건의-개요&quot;&gt;&lt;a href=&quot;#사건의-개요&quot; class=&quot;headerlink&quot; title=&quot;사건의 개요&quot;&gt;&lt;/a&gt;사건의 개요&lt;/h2&gt;&lt;p&gt;19년 10월 24일 오후 즈음
        
      
      </description>
      
      
      <content:encoded><![CDATA[<img src="/images/logo/elastic.png"/><h2 id="사건의-개요"><a href="#사건의-개요" class="headerlink" title="사건의 개요"></a>사건의 개요</h2><p>19년 10월 24일 오후 즈음…<br>언제나 그렇듯이 바쁜 일상 속에서 업무 중요도에 따라 잠시 미뤄뒀던 task 로 인해 <del>오늘도</del> 작은 이슈가 발생하였다. </p><p>아래 이미지와 같이 elasticsearch 에서 로그가 쌓이지 않는 이슈가 발생하였고 그에 따라 업무에 필요한 로그 확인이 어려운 상황이었다. <del>심지어 로그가 쌓이지 않고 있다는 것도 너무 늦게 알았네</del> </p><img src="/2019/10/24/2019-10-24-elasticsearch-%EC%9D%B4%EC%8A%88-%EB%8C%80%EC%9D%91-1/1.can't_save_log.png" class="" title="cant_save_log"><p><a href="https://daniel-hebn.github.io/2019/10/18/2019-10-18-Elastic-Stack-kafka-%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%A1%9C%EA%B7%B8-%EC%88%98%EC%A7%91-%EB%B0%8F-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EA%B5%AC%EC%B6%95-1/#elastic-stack-amp-kafka">로그 수집에 대한 flow</a> 는 어렵지 않으므로 kafka 와 elasticsearch 사이에서 이슈 구간이 어디인지 알 수만 있다면, 문제 해결 자체는 어렵지 않을 것이라 생각하고 <del>늦게나마</del> 확인 작업을 시작하였다.</p><br/><h3 id="logback-gt-kafka-구간-확인"><a href="#logback-gt-kafka-구간-확인" class="headerlink" title="logback -&gt; kafka 구간 확인"></a>logback -&gt; kafka 구간 확인</h3><p>우선 was 의 logback 에서 kafka 로의 메시지 전달에 문제가 없는지 확인하기 위해, kafka 의 <code>kafka-console-producer.sh</code> 을 실행하여 로그용 topic 에 메시지가 쌓이고 있는지를 확인하였다. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/<span class="built_in">local</span>/kafka/kafka-console-consumer.sh </span><br><span class="line">--bootstrap-server kafka-server1:9092,kafka-server2:9092,kafka-server3:9092 \</span><br><span class="line">--topic log-v1</span><br></pre></td></tr></table></figure><p><code>--from-beginning</code> 옵션을 제거하면 <code>kafka-console-consumer.sh</code> 실행 이후의 시점부터 전달되는 메시지를 console 에 출력하게 된다. </p><p>실행결과 was 의 logback -&gt; kafka 구간에서는 이슈 없이 메시지 전달이 정상적으로 이루어지고 있는 것을 확인하였다.</p><img src="/2019/10/24/2019-10-24-elasticsearch-%EC%9D%B4%EC%8A%88-%EB%8C%80%EC%9D%91-1/4._kafka_console_log.png" class="" title="kafka_console_log"><br/><h3 id="kafka-gt-logstash-구간-확인"><a href="#kafka-gt-logstash-구간-확인" class="headerlink" title="kafka -&gt; logstash 구간 확인"></a>kafka -&gt; logstash 구간 확인</h3><p>다음으로 kafka 에서 logstash 구간을 확인하였다. kafka 자체의 동작에는 이슈가 없음을 확인하였기에, logstash 의 process 상태와 로그를 통하여 logstash 의 정상 동작 여부를 확인하고자 하였다.<br>logstash 의 로그 위치는 <code>/etc/logstash/logstash.yml</code> 에서의 <code>path.logs</code> 에 따라 <code>/var/log/logstash</code> 에 남고 있었고, 이를 <code>tail -f</code> 하여 실시간으로 로그를 확인하였다. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/logstash/logstash.yml | grep path.logs</span><br><span class="line">$ tail -f /var/<span class="built_in">log</span>/logstash/logstash-plain.log</span><br></pre></td></tr></table></figure><p>그 때의 로그 상황은 다음과 같다.</p><img src="/2019/10/24/2019-10-24-elasticsearch-%EC%9D%B4%EC%8A%88-%EB%8C%80%EC%9D%91-1/3_logstash_error_log.png" class="" title="logstash_error_log"><br/><p><code>FORBIDDEN</code> 이라는 <del>기분 나쁜</del> 문구와 함께 뭔가의 에러로그가 찍히고 있음을 확인하였다. </p><p>해당 문구를 구글링했을 때 비교적 많은 검색 결과를 얻을 수 있었고, 이슈 발생 원인은 elasticsearch 가 사용하는 disk space 가 부족할 때 elasticsearch 의 down 을 막기 위해서, 문제 시점 이후로는 index 의 읽기와 삭제만 허용하도록 자동적으로 설정이 바뀌기 때문임을 알게 되었다 (elasticsearch 에서 해당 설정값은 <code>read_only_allow_delete=true</code> 이다)</p><p>정리하면 </p><ol><li>elasticsearch 의 저장공간이 부족한 상황에서 추가적인 저장을 실행하면 elasticsearch 를 포함한 서버의 모든 프로세스가 영향을 받을 수 있기 때문에</li><li>elasticsearch 가 자체적으로 저장 operation 을 차단시키는 설정으로 변경되었고</li><li>이 후 kafka 에서 메시지를 읽어서 elasticsearch 에 저장하고자 했던 logstash 쪽에서 에러가 발생하는 것이었다.</li></ol><p>이 때, 필자는 elasticsearch 가 되게 스마트하다는 것에 감탄했었고, 이는 마치 MSA 에서 과도한 트래픽으로 인해 시스템이 다운되기전에 트래픽을 차단시키는 <code>circuit breaker</code> 와 맥락이 비슷하다는 것을 느꼈다.</p><p>더 상세한 설명은 다음의 링크를 참고한다 </p><ul><li><a href="https://stackoverflow.com/questions/48155774/elasticsearch-read-only-allow-delete-auto-setting?answertab=active#tab-top">참고 1</a></li><li><a href="https://help.aiven.io/en/articles/2303941-elasticsearch-watermark-levels">참고 2</a></li><li><a href="https://dev-yeon.tistory.com/12">참고 3</a></li></ul><p>어쨌든 문제 상황의 원인은 알았으니 빠르게 해결하는 일만 남았다.</p><br/><h2 id="해결"><a href="#해결" class="headerlink" title="해결!"></a>해결!</h2><h3 id="단기-해결책"><a href="#단기-해결책" class="headerlink" title="단기 해결책"></a>단기 해결책</h3><p>elasticsearch 의 용량이 부족한 상황을 알았으니 우선 용량을 확보하는 것이 급선무였다. </p><p>이를 위해</p><ol><li>elasticsearch 에서 오래된 index 삭제</li><li>elasticsearch 의 설정값 <code>read_only_allow_delete</code> 를 false 로 변경  </li></ol><p>을 진행하였고, read_only_allow_delete 를 false 로 바꾸자마자 로그가 다시 들어오는 것을 확인하였다.</p><p>read_only_allow_delete 를 false 로 바꿀 때에는 kibana 의 <code>Dev_tools</code> 메뉴를 이용하면 편리하다.</p><img src="/2019/10/24/2019-10-24-elasticsearch-%EC%9D%B4%EC%8A%88-%EB%8C%80%EC%9D%91-1/readonly_allow_delete_false.png" class="" title="readonly_allow_delete_false"><br/> <p>read_only_allow_delete=false 를 실행하는 즉시 logstash 를 통하여 elasticsearch 에 데이터가 저장되기 시작한다.</p><img src="/2019/10/24/2019-10-24-elasticsearch-%EC%9D%B4%EC%8A%88-%EB%8C%80%EC%9D%91-1/6._restore_logstash.png" class="" title="restore_logstash"><p><small> logstash 에서 elasticsearch 로의 output 이 성공하기 시작 </small></p><img src="/2019/10/24/2019-10-24-elasticsearch-%EC%9D%B4%EC%8A%88-%EB%8C%80%EC%9D%91-1/7._restore_in_fast.png" class="" title="restore_in_fast"><p><small> 순식간에 로그가 복구됨 </small></p><p>보통 elasticsearch 에 데이터를 저장할 때는 timestamp 를 기본 값으로 포함시키고, index 도 날짜를 기준으로 생성하는 것을 권장한다. 날짜별로 index 를 생성한다면 특정 기간이 지난 index 를 찾아서 삭제하기 쉽고, 날짜별 index 의 크기 및 특징을 확인하기에 편리한 장점이 있기 때문이다.</p><p>또한, kibana 를 통해 로그를 검색할 때에는 <code>topic-*</code> 같은 패턴으로 <code>kibana index pattern</code> 을 생성하면 날짜와 상관없이 topic 별로 데이터 검색도 가능하다. (즉, elasticsearch 의 index 저장 시에 날짜별로 구분해도 문제가 없다는 뜻이다)</p><p>참고로 필자가 근무하는 시스템의 logstash 에서는 elasticsearch 에 데이터를 저장할 때 아래와 같은 설정으로 저장하고 있다. <code>-%&#123;+YYYY.MM.dd&#125;&quot;</code> 를 선언하여 날짜별로 index 를 생성하는 것을 확인할 수 있다.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 설정 일부 </span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">       hosts =&gt; [<span class="string">&quot;elasticsearch1&quot;</span>,<span class="string">&quot;elasticsearch2&quot;</span>,<span class="string">&quot;elasticsearch3&quot;</span>,<span class="string">&quot;elasticsearch4&quot;</span>]</span><br><span class="line">       index =&gt; <span class="string">&quot;%&#123;es_index&#125;-%&#123;+YYYY.MM.dd&#125;&quot;</span></span><br><span class="line">       manage_template =&gt; <span class="literal">false</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="근본-해결책"><a href="#근본-해결책" class="headerlink" title="근본 해결책"></a>근본 해결책</h3><p>근본적인 해결 방법은 elasticsearch 의 disk space 가 부족한 상황이 되지 않도록 환경을 만드는 것이다.</p><p>이를 위해 </p><ol><li>elasticsearch 가 사용하기에 충분한 disk space 를 할당하고 </li><li>주기적으로 오래된 index 를 제거하는 것</li><li>disk 와 같은 리소스 부족 시 자동으로 notification 이루어지는 체계 구축 </li></ol><p>이 필요하다.</p><p>1번의 경우, elasticsearch.yml 의 <code>path.data</code> 와 <code>path.logs</code> 를 변경한 후에 elasticsearch cluster 를 재시작하면 데이터 및 로그 저장 경로를 변경할 수 있다. 자세한 처리 방법은 다음의 링크를 참고한다 (<a href="https://stackoverflow.com/questions/35143926/how-to-move-elasticsearch-data-directory">elasticsearch data 및 log 저장경로 변경</a>)</p><p>2번의 경우, kibana 의 메뉴에서 <code>management &gt; Index Lifecycle Policies</code> 에서 특정 topic 에 대한 삭제 주기를 설정하면, 삭제 없이 index 가 무한정으로 증가하는 것을 막을 수 있다.</p><p>아래 이미지는 kibana 의 <code>Index Lifecycle Policies</code> 의 상세 화면의 일부이다. <code>Maximum index size</code> 와 <code>Maximum age</code> 등을 통해서 용량별 / 기간별로 index 삭제 주기를 설정할 수 있다.</p><img src="/2019/10/24/2019-10-24-elasticsearch-%EC%9D%B4%EC%8A%88-%EB%8C%80%EC%9D%91-1/10._kibana_index_delete_policy.png" class="" title="kibana_index_delete_policy"><br/><p>3번의 경우, 서비스가 동작하는 서버와 서비스에 대한 메트릭을 수집하는 다양한 방법이 존재하므로, 현재의 상황에 맞게 찾아서 적용하면 될 것이다. 핵심은 문제 상황 시 이를 자동으로 notification 하는 시스템을 구축하는 것이 중요하다는 것이다. (<del>집중해서 개발도 해야 하잖아</del>)</p><h2 id="느낀점"><a href="#느낀점" class="headerlink" title="느낀점"></a>느낀점</h2><ul><li>(언제나 그렇듯이) 원인만 알면 문제해결 자체는 쉬운 편이다.</li><li>아무리 바빠도 최소한의 모니터링 체계는 갖추어야 한다.</li><li><del>리소스는 많을수록 편하다</del></li></ul><br/><p>오늘의 장애일지 끝 ㅋㅋ</p>]]></content:encoded>
      
      <comments>https://daniel-hebn.github.io/2019/10/24/2019-10-24-elasticsearch-%EC%9D%B4%EC%8A%88-%EB%8C%80%EC%9D%91-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>elk &amp; kafka 기반의 로그 수집 및 모니터링 구축 (2)</title>
      <link>https://daniel-hebn.github.io/2019/10/20/2019-10-20-elk-&amp;-kafka-%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%A1%9C%EA%B7%B8-%EC%88%98%EC%A7%91-%EB%B0%8F-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EA%B5%AC%EC%B6%95-(2)/</link>
      <guid>https://daniel-hebn.github.io/2019/10/20/2019-10-20-elk-&amp;-kafka-%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%A1%9C%EA%B7%B8-%EC%88%98%EC%A7%91-%EB%B0%8F-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EA%B5%AC%EC%B6%95-(2)/</guid>
      <pubDate>Sun, 20 Oct 2019 14:30:00 GMT</pubDate>
      <description>
      
        
        
          &lt;img src=&quot;/images/logo/elastic.png&quot;/&gt;&lt;h2 id=&quot;zookeeper-와-kafka-설치-및-구성&quot;&gt;&lt;a href=&quot;#zookeeper-와-kafka-설치-및-구성&quot; class=&quot;headerlink&quot; title=&quot;zooke
        
      
      </description>
      
      
      <content:encoded><![CDATA[<img src="/images/logo/elastic.png"/><h2 id="zookeeper-와-kafka-설치-및-구성"><a href="#zookeeper-와-kafka-설치-및-구성" class="headerlink" title="zookeeper 와 kafka 설치 및 구성"></a>zookeeper 와 kafka 설치 및 구성</h2><p>본 포스팅에서는 <a href="https://daniel-hebn.github.io/2019/10/18/2019-10-18-Elastic-Stack-kafka-%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%A1%9C%EA%B7%B8-%EC%88%98%EC%A7%91-%EB%B0%8F-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EA%B5%AC%EC%B6%95-1/#elastic-stack-amp-kafka">지난 포스팅</a> 의 아키텍쳐 중에서 <code>zookeeper</code> 와 <code>kafka</code> 의 간단한 소개 및 설치, 구성에 대한 내용을 기술한다. </p><img src="/2019/10/20/2019-10-20-elk-&-kafka-%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%A1%9C%EA%B7%B8-%EC%88%98%EC%A7%91-%EB%B0%8F-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EA%B5%AC%EC%B6%95-(2)/elastic_kafka_architecture2.png" class="" title="elasticsearch &amp; kafka Architecture"><h3 id="zookeeper-소개"><a href="#zookeeper-소개" class="headerlink" title="zookeeper 소개"></a>zookeeper 소개</h3><p>주키퍼는 분산 시스템의 코디네이션 작업을 가능하게 하는 아파치 프로젝트 오픈소스이다. 코디네이션 작업은 여러 프로세스들에 대한 것인데, 이러한 작업의 목적은 프로세스들 간의 협력이나 경합을 조절하는 것이다.</p><ul><li><code>협력</code>이란 프로세스들이 작업을 함께 수행해야 하고 다른 프로세스가 진행될 수 있도록 어떤 일을 해야 하는 것을 의미한다. 예를 들어 마스터 워커 구조에서 워커는 자신이 일을 할 수 있는 상태임을 마스터에게 알리고, 이에 마스터는 워커에게 작업을 할당한다.</li><li><code>경합</code>은 두 프로세스가 동시에 작업을 진행할 수 없는 상황을 의미한다. 그래서 한 프로세스는 다른 프로세스가 끝날 때까지 기다려야 하는데, 예를 들어 읽기/쓰기 락 또는 글로벌 락과 같은 것이 있다.  </li></ul><p>또한, 프로세스 상호 간의 진행 상황을 전달하기 위한 설정(configuration) 과 같은 메타데이터를 주키퍼를 통하여 공유하기도 한다.  </p><p>주키퍼는 기본 요소를 표현하기 위해 파일 시스템의 트리(tree) 처럼 계층적으로 구성된 <code>znode</code> 라고 부르는 작은 데이터 노드를 사용하는데, 주키퍼의 API 는 이를 조작하는 일련의 작업(operation) 이다.</p><img src="/2019/10/20/2019-10-20-elk-&-kafka-%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%A1%9C%EA%B7%B8-%EC%88%98%EC%A7%91-%EB%B0%8F-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EA%B5%AC%EC%B6%95-(2)/zookeeper_tree.png" class="" title="zookeeper_tree"><p>신규 <code>znode</code> 를 생성할 때는 모드를 명시하여 하는데 각 모드는 <code>znode</code> 의 동작 방법을 결정한다.</p><ul><li><strong>영구 znode (persistent)</strong>: 생성 후 명시적으로 delete API 가 호출되어야 삭제되는 <code>znode</code> 이다. 마스터가 작업을 할당하고 장애가 발생해도 워커에게 할당된 작업들은 유지되어야 한다. 이런 경우 <code>영구 znode</code> 가 유용하다.</li><li><strong>임시 znode (ephemeral)</strong>: 임시 znode 를 생성한 클라이언트가 주키퍼와 연결이 끊어지거나 클라이언트에 장애가 발생하면 삭제되는 <code>znode</code> 이다. 마스터 워커 예시에서 마스터 <code>znode</code> 는 <code>임시 znode</code> 이다. 만약 마스터에 문제가 발생했을 때 반드시 <code>znode</code> 도 제거되어야 하고 이런 경우 <code>임시 znode</code> 가 유용하다. </li><li><strong>순차 znode (sequential)</strong>: 순차 znode 는 유일하면서 점차 증가하는 정수로 할당된다. 예를 들어 클라이언트가 순차 <code>znode</code> 를 <em>/tasks/task-</em> 경로에 생성하는 경우, 주키퍼는 1 이라는 순차 번호를 할당하고 경로의 끝에 덧붙인다. <code>순차 znode</code> 는 유일한 이름의 <code>znode</code> 를 생성하는 편리한 방법을 제공한다. 또한 <code>znode</code> 의 생성 순서도 쉽게 확인이 가능하다.   </li></ul><p><small> &gt; 주키퍼 ZooKeeper 23 ~ 45p 참고 (에이콘출판사)</small></p><h3 id="zookeeper-설치-및-구성"><a href="#zookeeper-설치-및-구성" class="headerlink" title="zookeeper 설치 및 구성"></a>zookeeper 설치 및 구성</h3><p>아파치 카프카는 컨슈머 클라이언트와 카프카 클러스터에 관한 메타데이터를 저장하기 위해 주키퍼를 사용한다. 주키퍼는 카프카 배포판에 포함되어 있어서 이를 사용해도 되지만 여기서는 별도로 다운로드하여 설치를 진행한다.</p><p>설치 대상 서버에 아래와 같은 작업을 진행한다 (서버 1 ~ 5)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://apache.mirror.cdnetworks.com/zookeeper/zookeeper-3.5.5/apache-zookeeper-3.5.5-bin.tar.gz</span><br><span class="line">$ tar -xvf apache-zookeeper-3.5.5-bin.tar.gz</span><br><span class="line">$ mv apache-zookeeper-3.5.5-bin /usr/<span class="built_in">local</span>/zookeeper</span><br><span class="line">$ mkdir -p /var/lib/zookeeper</span><br><span class="line">$ cat &gt; /usr/<span class="built_in">local</span>/zookeeper/conf/zoo.cfg &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">&gt; tickTime=2000</span></span><br><span class="line"><span class="string">&gt; dataDir=/var/lib/zookeeper</span></span><br><span class="line"><span class="string">&gt; clientPort=2181</span></span><br><span class="line"><span class="string">&gt; EOF</span></span><br></pre></td></tr></table></figure><br/><p>서버 한 대에서 주키퍼 설치 후 아래를 실행하면 독립 실행 모드로 동작한다. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/<span class="built_in">local</span>/zookeeper/bin/zkServer.sh start</span><br><span class="line"></span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure><p>개발 환경에서는 하나의 주키퍼와 카프카를 이용하여 개발을 진행하는 것이 가능하겠지만, 운영 환경에서는 주키퍼와 카프카의 클러스터를 구성하여 사용하는 것이 일반적이다. </p><p>주키퍼의 클러스터는 앙상블(<code>ensemble</code>) 이라는 별도의 명칭이 있고, 하나의 앙상블은 여러 개의 서버(노드) 를 맴버로 가질 수 있다.    </p><p>앙상블은 홀수 개의 서버를 맴버로 가지고, 앙상블의 서버 중 과반수가 작동 가능하다면 언제든지 요청 처리(데이터 읽기, 쓰기) 가 가능하다. 앙상블의 서버가 다섯 대로 구성된다면, 서버 한 대가 장애 중이라도 앙상블에 대한 유지보수 작업이 가능하므로 가능하다면 다섯 대 이상의 노드를 맴버로 가지도록 하자. </p><p>주키퍼 서버를 앙상블로 구성하려면 각 서버가 공통된 구성 파일을 가져야 한다. 또한, 각 서버는 자신의 ID 번호를 지정한 myid 파일을 데이터 디렉토리에 갖고 있어야 한다.<br>예를 들어 앙상블에 속한 서버들의 호스트 이름이 zoo1.example.com, zoo2.example.com, zoo3.example.com … 이라면 구성 파일의 내역은 다음과 같이 될 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ vi /usr/<span class="built_in">local</span>/zookeeper/conf/zoo.cfg 이 후 아래의 내용 반영</span><br><span class="line"></span><br><span class="line">tickTime=2000</span><br><span class="line">dataDir=/var/lib/zookeeper</span><br><span class="line">clientPort=2181</span><br><span class="line">initLimit=20</span><br><span class="line">syncLimit=5</span><br><span class="line">server.1=zoo1.example.com:2888:3888</span><br><span class="line">server.2=zoo2.example.com:2888:3888</span><br><span class="line">server.3=zoo3.example.com:2888:3888</span><br><span class="line">server.4=zoo4.example.com:2888:3888</span><br><span class="line">server.5=zoo5.example.com:2888:3888</span><br></pre></td></tr></table></figure><ul><li>X: 각 서버의 ID 번호이며 정수이다.</li><li>initLimit &amp; tickTime: initLimit 는 팔로어가 리더에 접속할 수 있는 시간이며 tickTime 을 기준으로 설정된다. 여기서는 initLimit 가 20 * 2000(밀리초) = 40초가 된다.</li><li>clientPort: 클라이언트가 앙상블에 연결 시 사용할 port </li><li>syncLimit: 리더가 될 수 있는 팔로어의 최대 갯수를 나타냄</li><li>hostname: 각 서버의 호스트 이름이나 IP </li><li>peerPort: 앙상블의 서버들이 상호 통신하는 데 사용하는 TCP 포트 (default: 2888)</li><li>leaderPort: 리더를 선출하는 데 사용하는 TCP 포트 (default: 3888)</li></ul><br/><p>이 후 각 서버는 dataDir 에 지정된 디렉토리에 각각 myid 라는 이름의 파일을 가지고 있어야 한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zoo1.example.com 서버에서는 /var/lib/zookeeper/ 경로에 </span><br><span class="line">myid 라는 파일이 존재해야 하고, myid 의 내용은 1 이 있어야 한다.</span><br><span class="line"></span><br><span class="line">$ vi /var/lib/zookeeper/myid </span><br><span class="line">1</span><br></pre></td></tr></table></figure><br/> <p>여기까지 진행 후 5대의 서버에서 주키퍼를 각각 띄우면 앙상블 구성은 성공적으로 진행된 것이다.<br>(systemctl 를 이용하여 주키퍼를 서비스 등록 후 사용하는 것이 편리하다)<br><br/></p><h3 id="kafka-소개"><a href="#kafka-소개" class="headerlink" title="kafka 소개"></a>kafka 소개</h3><p>카프카는 메시지 발행/구독 시스템이고 분산환경에 특화되어 설계되어 있다는 특징을 가지고 있다. 카프카의 데이터는 지속해서 저장하고 읽을 수 있고 시스템 장애에 대비하고 확장에 따른 성능 저하를 방지하기 위해 데이터가 분산 처리될 수 있다.</p><p>카프카의 데이터 기본 단위는 메시지(message)이고 이는 데이터베이스의 행(row)이나 레코드(record)에 비유될 수 있다. 카프카의 메시지는 바이트 배열의 데이터로 간주하므로 특정 형식이나 의미를 갖지 않는다. </p><p>카프카의 메시지 데이터는 토픽(<code>topic</code>)으로 분류된 파티션(<code>partition</code>)에 수록되는데, 이 때 데이터를 수록할 파티션을 결정하기 위해 일괸된 해시 값으로 키를 생성한다. 따라서 같은 키를 갖는 메시지는 항상 같은 파티션에 수록된다. </p><img src="/2019/10/20/2019-10-20-elk-&-kafka-%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%A1%9C%EA%B7%B8-%EC%88%98%EC%A7%91-%EB%B0%8F-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EA%B5%AC%EC%B6%95-(2)/anatomy_of_kafka.png" class="" title="anatomy_of_kafka"><p>하나의 토픽은 여러 개의 파티션을 갖지만, 메시지 처리 순서는 토픽이 아닌 파티션별로 유지 관리된다. 또한 각 파티션은 서로 다른 서버에 분산되어 수평적인 확장이 가능하고 그렇기 때문에 단일 서버로 처리할 때보다 성능이 훨씬 우수하다. </p><br/><p>카프카의 클라이언트는 기본적으로 프로듀서와 컨슈머라는 두 가지 형태가 있다.</p><ul><li>프로듀서는 새로운 메시지를 생성하고, 생성된 메시지는 특정 토픽의 파티션에 저장된다. 이 때 프로듀서는 메시지가 어떤 파티션에 수록되는지는 관여하지 않는다.</li><li>컨슈머는 하나 이상의 토픽을 구독하여 메시지가 생성된 순서로 읽으며, 메시지의 오프셋(<code>offset</code>)을 유지하여 읽는 메시지의 위치를 알 수 있다. 그리고 주키퍼나 카프카에서는 각 파티션에서 마지막에 읽은 메시지의 오프셋을 저장하고 있으므로 컨슈머가 읽기를 중단했다 하더라도 다시 언제든 그 다음 메시지를 읽을 수 있다.</li></ul><img src="/2019/10/20/2019-10-20-elk-&-kafka-%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%A1%9C%EA%B7%B8-%EC%88%98%EC%A7%91-%EB%B0%8F-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EA%B5%AC%EC%B6%95-(2)/kafka_producer_consumer.png" class="" title="kafka_producer_consumer"><p>카프카의 장점은 다음과 같다</p><ul><li>다중 프로듀서: 여러 클라이언트가 많은 토픽을 사용하거나 같은 토픽을 같이 사용해도 카프카는 무리 없이 많은 프로듀서의 메시지를 처리할 수 있다. 즉, 여러 프로듀서가 하나의 토픽에 메시지 발급을 동시에 할 수 있다는 말이다.</li><li>다중 컨슈머: 여러 컨슈머가 상호 간섭 없이 어떤 메시지 스트림도 읽을 수 있다. 이는 특정 메시지를 소비하면 다른 클라이언트에서 그 메시지를 사용할 수 없는 큐(queue) 시스템과는 다르다. </li><li>디스크 기반의 보존: 카프카는 다중 컨슈머를 처리할 수 있을 뿐만 아니라 지속해서 메시지를 보존할 수도 있다. 따라서 컨슈머 애플리케이션이 항상 실시간으로 실행되지 않아도 된다. 메시지는 보존 옵션(보존 기간이나 토픽 크기)에 따라 디스크에 저장되어 보존된다. 또한 토픽별로 보존 옵션을 선택할 수도 있으므로 컨슈머의 요구에 맞게 메시지 보존 옵션을 가질 수 있다. 따라서 처리가 느리거나 접속 폭주로 인해 컨슈머가 메시지를 읽는 데 실패하더라도 데이터가 유실될 위험이 없다.</li><li>확장성: 처음에는 검증의 목적으로 하나의 브로커로 시작하되 점차적으로 브로커의 수를 늘려 클러스터의 크기를 키울 수 있다. 확장 작업은 시스템 전체의 사용에 영향을 주지 않고 클러스터가 온라인 상태일때 도 수행될 수 있다. </li></ul><p><small> &gt; 카프카 핵심 가이드 4 ~ 11p 참고 (제이펍출판사)</small></p><br/><h3 id="kafka-설치-및-구성"><a href="#kafka-설치-및-구성" class="headerlink" title="kafka 설치 및 구성"></a>kafka 설치 및 구성</h3><p>설치 대상 서버에 아래와 같은 작업을 진행한다 (서버 6 ~ 8)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://apache.mirror.cdnetworks.com/kafka/2.3.0/kafka_2.11-2.3.0.tgz </span><br><span class="line">$ tar -xvf kafka_2.11-2.3.0.tgz</span><br><span class="line">$ mv kafka_2.11-2.3.0 /usr/<span class="built_in">local</span>/kafka</span><br><span class="line">$ mkdir /data/kafka-logs</span><br><span class="line">$ vi /usr/<span class="built_in">local</span>/kafka/config/server.properties</span><br><span class="line"></span><br><span class="line">[server.properties]</span><br><span class="line">broker.id=1</span><br><span class="line">log.dirs=/data/kafka-logs</span><br><span class="line">zookeeper.connect=zoo1.example.com:2181,zoo2.example.com:2181,zoo3.example.com:2181,zoo4.example.com:2181,zoo5.example.com:2181/kafka</span><br><span class="line">num.recovery.threads.per.data.dir=4</span><br><span class="line">log.retention.hours=672</span><br></pre></td></tr></table></figure><ul><li>broker.id: 모든 카프카 브로커는 broker.id 에 설정하는 정수로 된 번호(식별자)를 가져야 한다. 단, 하나의 카프카 클러스터 내에서는 고유한 값이어야 한다.</li><li>log.dirs: 카프카는 모든 메시지를 로그 세그먼트(segment) 파일을 모아서 디스크에 저장한다. 이 때 쉼표를 이용하여 여러 경로를 지정할 수 있다. </li><li>zookeeper.connect: 브로커의 메타데이터를 저장하기 위해 사용되는 주키퍼의 위치를 나타낸다. 기본 구성값은 localhost:2181 이고, <code>호스트이름:포트/경로</code> 의 형식으로 지정할 수 있다. 예시의 뒷 부분에 /kafka 가 있음을 유의하자 </li><li>num.recovery.threads.per.data.dir: 브로커의 시작 또는 종료 시의 로그를 복구할 때 사용할 스레드의 갯수를 말한다. 이 때 log.dirs 에 지정된 경로가 3 이고 num.recovery.threads.per.data.dir 가 8 이라면 전체 스레드의 갯수는 24가 된다.</li><li>log.retention.hours: 카프카가 얼마 동안 메시지를 보존할지를 설정한다. </li></ul><br/><p>이후 각 서버에서 카프카를 실행하면 3대의 브로커로 이루어지는 카프카 클러스터가 형성된다고 볼 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/<span class="built_in">local</span>/kafka/bin/kafka-server-start.sh \</span><br><span class="line">-daemon /usr/<span class="built_in">local</span>/kafka/config/server.properties</span><br></pre></td></tr></table></figure><br/><p>정상적인 구성의 확인을 위해 카프카 클러스터에 토픽을 생성하고 메시지를 읽고 쓰는 테스트를 진행하면 다음과 같다</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- 1. 토픽 생성</span><br><span class="line">$ /usr/<span class="built_in">local</span>/kafka/kafka-topics.sh --create \</span><br><span class="line">--zookeeper zoo1.example.com:2181,zoo2.example.com:2181,zoo3.example.com:2181,zoo4.example.com:2181,zoo5.example.com:2181/kafka \</span><br><span class="line">--replication-factor 1 --partitions 1 --topic <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">- 2. 토픽 확인</span><br><span class="line">$ /usr/<span class="built_in">local</span>/kafka/kafka-topics.sh \</span><br><span class="line">--zookeeper zoo1.example.com:2181,zoo2.example.com:2181,zoo3.example.com:2181,zoo4.example.com:2181,zoo5.example.com:2181/kafka \</span><br><span class="line">--describe --topic <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">Topic:<span class="built_in">test</span>PartitionCount:1ReplicationFactor:1Configs:</span><br><span class="line">Topic: <span class="built_in">test</span>Partition: 0Leader: 2Replicas: 2Isr: 2</span><br><span class="line"></span><br><span class="line">- 3. 메시지 저장</span><br><span class="line">$ /usr/<span class="built_in">local</span>/kafka/kafka-console-producer.sh \</span><br><span class="line">--broker-list kafka-server1:9092,kafka-server2:9092,kafka-server3:9092 \</span><br><span class="line">--topic <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">Test Message1</span><br><span class="line">Test Message2</span><br><span class="line">^C</span><br><span class="line"></span><br><span class="line">- 4. 메시지 읽기</span><br><span class="line">$ /usr/<span class="built_in">local</span>/kafka/kafka-console-consumer.sh </span><br><span class="line">--bootstrap-server kafka-server1:9092,kafka-server2:9092,kafka-server3:9092 \</span><br><span class="line">--topic <span class="built_in">test</span> --from-beginning</span><br><span class="line"></span><br><span class="line">Test Message 1</span><br><span class="line">Test Message 2</span><br></pre></td></tr></table></figure><p>여기까지 문제 없이 진행되었다면 3대의 브로커로 이루어진 카프카 클러스터가 정상적으로 설치되었다고 볼 수 있다.<br>(systemctl 를 이용하여 카프카를 서비스 등록 후 사용하는 것이 편리하다)</p><br/><h2 id="logback-과-kafka-를-활용한-로그-수집"><a href="#logback-과-kafka-를-활용한-로그-수집" class="headerlink" title="logback 과 kafka 를 활용한 로그 수집"></a>logback 과 kafka 를 활용한 로그 수집</h2><p>이제 kafka 를 메시지 브로커로 활용하여 서비스의 로그 및 메트릭 수집을 진행하도록 하자</p><p>우선 해당 포스팅에서는 </p><ol><li>로깅용 kafka topic 을 생성한 후에</li><li>logback 의 kafka appender 를 활용하여 kafka 에 로그를 저장</li></ol><p>하는 과정을 진행한다.</p><p>이렇게 저장된 로그는 추후 logstash 를 통하여 elasticsearch 쪽으로 전달되고 kibana 를 통하여 visualizing 된 로그를 보게 될 것이다.</p><h3 id="로깅용-kafka-topic-생성"><a href="#로깅용-kafka-topic-생성" class="headerlink" title="로깅용 kafka topic 생성"></a>로깅용 kafka topic 생성</h3><p>카프카 클러스터 내에서 토픽의 크기가 확장되는 방법이 파티션이다. 따라서 브로커가 추가될 때 클러스터 전체에 걸쳐 메시지가 고르게 저장되도록 파티션 갯수를 설정하는 것이 중요한데, 보통 클러스터의 브로커 수와 같게 하거나 배수로 토픽의 파티션 개수를 설정한다. 이렇게 하면 브로커마다 파티션이 고르게 분산될 수 있으며, 저장 메시지도 고르게 분산될 것이다. </p><p>대개 프로듀서는 컨슈머보다 훨씬 빠르게 처리되므로 처리량을 조사하지 않아도 무방하고, 파티션 하나는 항상 한 컨슈머가 소비한다. 따라서 컨슈머의 처리 속도와 목표 처리량을 산정하여 파티션 개수를 산정해야 한다.</p><p>필자는 우선 브로커 3개에서 토픽당 파티션 3개, 복제 팩터도 3을 설정하여 로깅용 토픽을 구성하였다. 지난 포스팅에서 기술했듯이 초당 800여건 / 분당 5만여건의 메시지를 무리없이 처리하는 것을 확인하였고, 메트릭 수집을 통하여 지속적으로 확인할 것이기에 현재 구성에서 큰 이슈는 없을 것으로 판단하고 있다.</p><p>아래의 명령어로 로깅용 토픽을 생성한다. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/<span class="built_in">local</span>/kafka/kafka-topics.sh --create \</span><br><span class="line">--zookeeper zoo1.example.com:2181,zoo2.example.com:2181,zoo3.example.com:2181,zoo4.example.com:2181,zoo5.example.com:2181/kafka \</span><br><span class="line">--replication-factor 3 --partitions 3 --topic log-v1</span><br></pre></td></tr></table></figure><br/><h3 id="logback-의-kafka-appender-를-활용한-로그-저장"><a href="#logback-의-kafka-appender-를-활용한-로그-저장" class="headerlink" title="logback 의 kafka appender 를 활용한 로그 저장"></a>logback 의 kafka appender 를 활용한 로그 저장</h3><blockquote><p>필자가 주로 사용하는 개발 환경은 java + spring boot 라서 logback 설정으로 kafka 에 로그를 저장하는 내용을 기술하지만, 카프카에 메시지를 저장하는 방법은 다양할 것이므로… 알아서 하실 것으로 기대한다.<br>도움이 되실 내용만 확인하셔도 된다. </p></blockquote><p>logback 에서 사용 가능한 custom appender 를 구현하려면 <a href="https://www.baeldung.com/custom-logback-appender">AppenderBase</a> 를 상속하여 자신만의 appender 를 구현하는 방법이 간단하지만, 이미 검증되어 충분히 사용되고 있는 누군가의 구현체를 활용하는 것도 아주 좋은 방법이다. (<del>나도 언젠가는 오픈소스 생태계에 약간이나마 공헌할 날이 오겠지</del>)</p><p>필자의 시스템에서는 logback 을 통하여 kafka 에 메시지를 저장하는 <a href="https://github.com/danielwegener/logback-kafka-appender">logback-kafka-appender</a> 를 활용한다.<br><br/></p><p>우선 build.gradle 에 아래와 같이 선언한다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(group = <span class="string">&quot;com.github.danielwegener&quot;</span>, name = <span class="string">&quot;logback-kafka-appender&quot;</span>, version = <span class="string">&quot;0.1.0&quot;</span>)</span><br><span class="line">    implementation(group = <span class="string">&quot;net.logstash.logback&quot;</span>, name = <span class="string">&quot;logstash-logback-encoder&quot;</span>, version = <span class="string">&quot;6.2&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이후 logback.xml 에서 아래와 같이 선언한다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- logback 예시  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;LOG-KAFKA&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.github.danielwegener.logback.kafka.KafkaAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">&quot;com.github.danielwegener.logback.kafka.encoding.LayoutKafkaMessageEncoder&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.PatternLayout&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                &#123;</span><br><span class="line">                &quot;@timestamp&quot;:&quot;%d&#123;&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSS&#x27;+09:00&#x27;&quot;&#125;&quot;,</span><br><span class="line">                &quot;service&quot;:&quot;example-server&quot;,</span><br><span class="line">                &quot;phase&quot;:&quot;live&quot;,</span><br><span class="line">                &quot;level&quot;:&quot;%level&quot;,</span><br><span class="line">                &quot;thread&quot;:&quot;%thread&quot;,</span><br><span class="line">                &quot;eventId&quot;:&quot;%mdc&#123;key-event-id:--&#125;&quot;,</span><br><span class="line">                &quot;src&quot;:&quot;%logger&#123;0&#125;.%M\(%L\)&quot;,</span><br><span class="line">                &quot;message&quot;:&quot;%msg&quot;,</span><br><span class="line">                &quot;exception&quot;: &quot;%ex&#123;200&#125;&quot;,</span><br><span class="line">                &quot;host&quot;: &quot;%contextName&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">topic</span>&gt;</span>log-v1<span class="tag">&lt;/<span class="name">topic</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">keyingStrategy</span> <span class="attr">class</span>=<span class="string">&quot;com.github.danielwegener.logback.kafka.keying.RoundRobinKeyingStrategy&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">deliveryStrategy</span> <span class="attr">class</span>=<span class="string">&quot;com.github.danielwegener.logback.kafka.delivery.AsynchronousDeliveryStrategy&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">producerConfig</span>&gt;</span>compression.type=snappy<span class="tag">&lt;/<span class="name">producerConfig</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;producerConfig&gt;linger.ms=100&lt;/producerConfig&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;producerConfig&gt;batch.size=327680&lt;/producerConfig&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">producerConfig</span>&gt;</span>retries=1<span class="tag">&lt;/<span class="name">producerConfig</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">producerConfig</span>&gt;</span>max.block.ms=1000<span class="tag">&lt;/<span class="name">producerConfig</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">producerConfig</span>&gt;</span>bootstrap.servers=kafka1.server:9092,kafka2.server:9092,kafka3.server:9092<span class="tag">&lt;/<span class="name">producerConfig</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.example.service&quot;</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;LOG-KAFKA&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br></pre></td></tr></table></figure><p>logback 설정에서 topic 은 kafka 에서 로깅 목적으로 생성한 토픽명을 기술하고, producerConfig 중 bootstrap.servers 는 kafka 브로커의 주소를 기술한다.<br>그 외 자세한 설정은 다음의 링크를 참고한다. </p><ul><li><a href="https://kafka.apache.org/23/javadoc/org/apache/kafka/clients/producer/ProducerConfig.html">kafka producer config</a></li><li><a href="https://github.com/danielwegener/logback-kafka-appender">logback-kafka-appender</a></li></ul><p>logback 설정 이후 서버를 실행하여 지정된 로거로 로깅이 될 때, KafkaAppender 를 통하여 카프카 클러스터에 메시지가 전달되고, 추후 logstash 를 통하여 kafka 에서 메시지를 꺼낼 수 있게 된다. 이렇게 획득한 로그 데이터를 elasticsearch 에 실시간으로 저장한다면, 목적하는 로깅 및 모니터링이 가능한 기반이 시작된다고 할 수 있다.</p><br/><p>다음 포스팅부터는 elasticsearch 및 logstash, kibana 에 대해 이야기하겠다.</p><h2 id="참고자료-및-사이트"><a href="#참고자료-및-사이트" class="headerlink" title="참고자료 및 사이트"></a>참고자료 및 사이트</h2><ul><li><a href="http://acornpub.co.kr/book/zookeeper">주키퍼 ZooKeeper (고가용성 서버를 위한 분산 프로세스 코디네이션)</a></li><li><a href="https://jpub.tistory.com/857">카프카 핵심 가이드: 실시간 데이터와 스트림 프로세싱</a></li></ul>]]></content:encoded>
      
      <comments>https://daniel-hebn.github.io/2019/10/20/2019-10-20-elk-&amp;-kafka-%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%A1%9C%EA%B7%B8-%EC%88%98%EC%A7%91-%EB%B0%8F-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EA%B5%AC%EC%B6%95-(2)/#disqus_thread</comments>
    </item>
    
    <item>
      <title>elk &amp; kafka 기반의 로그 수집 및 모니터링 구축 (1)</title>
      <link>https://daniel-hebn.github.io/2019/10/18/2019-10-18-elk-&amp;-kafka-%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%A1%9C%EA%B7%B8-%EC%88%98%EC%A7%91-%EB%B0%8F-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EA%B5%AC%EC%B6%95-(1)/</link>
      <guid>https://daniel-hebn.github.io/2019/10/18/2019-10-18-elk-&amp;-kafka-%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%A1%9C%EA%B7%B8-%EC%88%98%EC%A7%91-%EB%B0%8F-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EA%B5%AC%EC%B6%95-(1)/</guid>
      <pubDate>Fri, 18 Oct 2019 14:30:00 GMT</pubDate>
      <description>
      
        
        
          &lt;img src=&quot;/images/logo/elastic.png&quot;/&gt;&lt;h2 id=&quot;모니터링의-중요성&quot;&gt;&lt;a href=&quot;#모니터링의-중요성&quot; class=&quot;headerlink&quot; title=&quot;모니터링의 중요성&quot;&gt;&lt;/a&gt;모니터링의 중요성&lt;/h2&gt;&lt;h3 id=&quot;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<img src="/images/logo/elastic.png"/><h2 id="모니터링의-중요성"><a href="#모니터링의-중요성" class="headerlink" title="모니터링의 중요성"></a>모니터링의 중요성</h2><h3 id="모니터링"><a href="#모니터링" class="headerlink" title="모니터링?"></a>모니터링?</h3><p>IT 업무를 하면서 모니터링이라는 용어를 접해보지 않은 사람은 없을 것이다. </p><p><del>사놓기만 하고 아직 제대로 읽어보지 못한</del> <a href="https://jpub.tistory.com/756">사이트 신뢰성 엔지니어링</a> 에서는 모니터링에 대한 정의를 아래와 같이 말하고 있다. </p><blockquote><p>쿼리의 수와 종류, 에러의 수와 종류, 처리 시간 및 서버의 활동 시간 등 시스템에 대한 정량적 실시간 데이터를 모으고 처리하고 집계해서 보여주는 것을 말한다. (참고: 사이트 신뢰성 엔지니어링. 64p. 제이펍출판사)</p></blockquote><p>필자는 특정 기능에 대한 구현과 전반적인 아키텍처 설계만큼이나 모니터링이 정말로 중요하다고 생각하는데, 이는 자신이 구현하고 관리하는 시스템의 상태를 지속적으로 관찰하고, 문제가 발견될 때마다 능동적으로 대응하는 것은 서비스 운영의 필수 요소라고 생각하기 때문이다.</p><p>그렇기 때문에 실력이나 경력을 막론하고 자신이 맡은 서비스와 회사의 전반적인 시스템에 대한 모니터링을 열심히 하는 개발자에게 애정이 큰 편이다. <del>자기 서비스에 대한 모니터링도 안하는 인간들하고는 같이 일하기 싫은 것이 당연지사</del></p><p><code>작전의 실패는 용서할 수 있어도, 경계의 실패는 용서할 수 없다</code> 는 더글러스 맥아더의 말이 없더라도.. 모니터링은 너무도 당연하고 중요한 업무가 아니던가?  </p><h3 id="그런데-현실은"><a href="#그런데-현실은" class="headerlink" title="그런데.. 현실은?"></a>그런데.. 현실은?</h3><p>개발자는 항상 바쁘다. 같이 일하는 디자이너와 PO 도 바쁘고 모두 바쁘다. 그리고 일은 항상 많다. 눈 앞의 업무, 이번 스프린트 안에 끝내야 하는 업무, 분기 안에 달성해야 하는 업무 등등을 생각하면.. 일은 항상 많고 바쁜 것이 IT 쪽의 현실이 아닐까 한다.</p><p>그래도 <del>쿠팡이나 토스처럼</del> 모니터링 시스템이 이미 잘 구축되어 있고, 이를 전담하는 팀이 별도로 존재한다면 모니터링 구축에 대한 부담은 없기 때문에, 이슈 발생 시마다 모니터링에 기반한 알람을 바탕으로 이슈를 대응하거나, 지속적으로 매트릭의 추이를 관찰하면서 서비스 안정성을 유지하기 위한 next action item 을 도출할 수 있겠지만..</p><p>문제는 <del>모니터링의 중요성을 아예 모르거나</del> 현재 일하는 회사에서 모니터링 시스템이 구축되어 있지 않고, 그것을 구축하기에는 리소스가 너무 부족한 상황이 아닐까 한다.  </p><p>멀리 볼 것도 없이 필자가 19년 8월부터 겪게 되었던 상황이 바로 그 상황이었다. 신규 시스템에서 기능을 구현하고 운영해야 하는 상황이었는데 - 워낙 빠르고 바쁘게 돌아가는 상황 속에서 시스템에 대한 모니터링 구축이 가능한 리소스가 전혀 없었고, 그랬기 때문에 로그 및 메트릭 수집, 이를 기반한 알림이 미흡한 상황이었다.   </p><p>결국 10월에 성능 이슈와 함께 시스템이 급격히 느려진 때가 있었는데, 메트릭 수집과 모니터링이 있었다면 단숨에 이슈를 잡았거나 이슈 발생 전에 미리 대응이 가능했겠지만 - 그 때는 그게 없었고 조금 긴 시간 후에 원인을 찾아 대응할 수 있었다. </p><h2 id="구축에-대한-원칙과-실행-계획"><a href="#구축에-대한-원칙과-실행-계획" class="headerlink" title="구축에 대한 원칙과 실행 계획"></a>구축에 대한 원칙과 실행 계획</h2><p>1주일 정도의 리소스를 사용하여 모니터링 시스템을 구축하기로 결정한 후에, 아래와 같은 원칙을 세우고 관련한 stack 을 찾아봤다.</p><ol><li>널리 쓰이고 검증된 기술을 사용하고 싶다</li><li>구축과 유지보수에 큰 노력이 들지 않았으면 한다</li><li>메트릭 수집과 로그 수집, 그것에 기반한 알림 기능이 가능해야 한다.</li><li>보기에 예뻐야 한다. <del>예뻐야 자주 본다</del></li></ol><p>그에 따라 이미 적당히 익숙하고 검증된 <code>elastic stack</code> 에 <code>kafka</code> 를 이용한 <code>로그 및 메트릭 수집</code> 을 구축하기로 하였다. </p><p>참고로.. <code>AWS</code> 나 <code>google cloud</code>, <code>azure</code> 와 같은 클라우드 기반에서 업무가 가능하다면 당연히 그 쪽의 서비스를 이용했겠지만, 필자가 근무하는 <a href="https://team.toss.im/">회사</a>는 금융을 다루는 곳이기에 자체적인 서버 내에서 모니터링을 구축해야 하는 상황이었다. (<del>회사 좋아요. 지원 강추</del>)</p><p>사실 elastic stack 은 14년부터 지속적으로 사용해왔고, 해당 stack 에 대한 기술적인 지식이 약간은 있었기 때문에 선택에 있어서 크게 고민되는 점은 없었다. 다만, 과거에는 이미 누군가가 만들어놓은 elastic stack 을 활용하면서 모니터링에 참여했었다면, 지금은 내가 나와 동료를 위해 이것을 만들고 사용하고 운영해야 하는 것에서 기존과 다른 차이점이 있었다.</p><h2 id="elastic-stack-amp-kafka"><a href="#elastic-stack-amp-kafka" class="headerlink" title="elastic stack &amp; kafka"></a>elastic stack &amp; kafka</h2><p>운영 시스템의 규모와 각 stack 의 특징, 모니터링에 투입 가능한 시스템 자원 등을 고려하여 구상한 전반적인 아키텍처는 아래와 같다.</p><img src="/2019/10/18/2019-10-18-elk-&-kafka-%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%A1%9C%EA%B7%B8-%EC%88%98%EC%A7%91-%EB%B0%8F-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EA%B5%AC%EC%B6%95-(1)/elastic_kafka_architecture.png" class="" title="elasticsearch &amp; kafka Architecture"><table><thead><tr><th></th><th>설치1</th><th>설치2</th></tr></thead><tbody><tr><td>서버1</td><td>zookeeper1</td><td>elasticsearch1</td></tr><tr><td>서버2</td><td>zookeeper2</td><td>elasticsearch2</td></tr><tr><td>서버3</td><td>zookeeper3</td><td>elasticsearch3</td></tr><tr><td>서버4</td><td>zookeeper4</td><td>elasticsearch4</td></tr><tr><td>서버5</td><td>zookeeper5</td><td>kibana</td></tr><tr><td>서버6</td><td>kafka1</td><td>logstash1</td></tr><tr><td>서버7</td><td>kafka2</td><td>logstash2</td></tr><tr><td>서버8</td><td>kafka3</td><td>logstash3</td></tr></tbody></table><p><small>서버 사양은 모두  cpu: 8 core / mem: 8G / disk: SSD 30G</small><br><br/></p><h3 id="구성의-근거"><a href="#구성의-근거" class="headerlink" title="구성의 근거"></a>구성의 근거</h3><p>비교적 적은 리소스로 메트릭과 로그 수집이 가능한 시스템을 만들고 싶지만, 카프카 클러스터의 복제(replication)와 브로커 서버들의 물리적인 위치를 고려하면서 구축하는 수준은 고려하지 않았다. 추후 확장이 필요한 상황이 생긴다면 그 때 처리하는 것으로…</p><p>시스템에 할당된 리소스마다 다르겠지만 해당 구성에서 초당 800여건 / 분당 5만여건의 메시지를 무리없이 처리하는 것을 확인하였다. 현재는 그 이상의 메시지 처리를 받을 일은 없기 때문에 적절한 수준의 성능이라고 생각하고 있다.</p><br/><h4 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h4><p><code>주키퍼</code>의 클러스터를 <code>앙상블</code>(ensemble) 이라고 하며, 하나의 앙상블은 여러 개의 서버(노드)를 맴버로 가질 수 있다. 주키퍼 앙상블은 다섯 개의 서버 노드로 구성하는 것을 추천한다. 그 이유는 다음과 같다.</p><p>앙상블의 구성을 변경(ex. 노드 교체) 하려면 한 번에 하나의 서버 노드를 중단했다가 다시 로딩해야 한다. 그러나 만일 하나 이상의 노드를 중단할 수 없는 앙상블이라면 유지보수 작업에 위험이 따르게 된다. </p><p>그리고 서버가 너무 많으면 오히려 성능이 저하될 수 있으므로 노드를 다섯 개보다 많게 구성하는 것은 바람직하지 않다. (참고: 카프카 핵심 가이드. 22p. 제이펍출판사)</p><br/><h4 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h4><p><code>카프카</code>의 브로커 및 파티션 개수 산정은 당연히 단위 시간당 메시지 처리량을 고려하여 산정되어야 한다. 허나 시스템의 전반적인 메시지 처리량에 대한 예측이 어렵다면 우선은 메트릭과 로그 수집에 대한 시스템을 구축하여 사용하면서, 필요 시 브로커의 수를 늘리는 것도 방법이 될 수 있다. (클러스터에 브로커를 추가하는 것은 전혀 어려운 것이 아니기 때문에)</p><p>하나의 카프카 서버로도 잘 동작할 수 있지만, 다수의 브로커로 하나의 클러스터를 구성하면 장점이 많다. 다수의 서버로 처리량을 분산시켜 확장할 수 있고, 각 서버의 장애에 따른 데이터 유실을 막기 위해 복제(<code>replication</code>)를 사용 할 수도 있다. 복제를 사용하면 현재 사용 중인 카프카 시스템을 중단시키지 않고 유지보수 작업을 수행할 수도 있다. </p><p>필자의 경우는 큰 고민 없이 브로커 3개를 하나의 클러스터로 구성하였다.  </p><br/><h4 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h4><p><code>엘라스틱서치</code>에 관한 설치와 설정은 엘라스틱서치에서 일하고 계신 <a href="http://kimjmin.net/2018/01/2018-01-setting-es-cluster-1/">김종민님의 블로그</a> 를 적극 활용하였다. 엘라스틱서치의 경우는 구글링하면 공식 사이트와 여러 곳에서 다양한 인사이트를 쉽게 얻을 수 있기 때문에 마음만 먹으면 쉽게 활용이 가능하다고 생각한다.</p><p>필자의 경우는 김종민님의 블로그의 내용 그대로 - 3개의 데이터 전용 노드, 1개의 마스터 전용 노드로 클러스터를 구성하였다.</p><br/><p>다음 포스팅부터는 실제의 설치와 구성에 대해 이야기하겠다.</p><br/><h2 id="참고자료-및-사이트"><a href="#참고자료-및-사이트" class="headerlink" title="참고자료 및 사이트"></a>참고자료 및 사이트</h2><ul><li><a href="https://jpub.tistory.com/756">사이트 신뢰성 엔지니어링</a></li><li><a href="https://jpub.tistory.com/857">카프카 핵심 가이드: 실시간 데이터와 스트림 프로세싱</a></li><li><a href="http://kimjmin.net/2018/01/2018-01-setting-es-cluster-1/">김종민님 블로그</a> </li></ul>]]></content:encoded>
      
      <comments>https://daniel-hebn.github.io/2019/10/18/2019-10-18-elk-&amp;-kafka-%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%A1%9C%EA%B7%B8-%EC%88%98%EC%A7%91-%EB%B0%8F-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EA%B5%AC%EC%B6%95-(1)/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ssh 사용</title>
      <link>https://daniel-hebn.github.io/2018/06/29/2018-06-29-ssh-%EC%82%AC%EC%9A%A9/</link>
      <guid>https://daniel-hebn.github.io/2018/06/29/2018-06-29-ssh-%EC%82%AC%EC%9A%A9/</guid>
      <pubDate>Fri, 29 Jun 2018 08:53:45 GMT</pubDate>
      <description>
      
        
        
          &lt;img src=&quot;/images/logo/ssh.png&quot;/&gt;&lt;h2 id=&quot;인증서-생성-방법&quot;&gt;&lt;a href=&quot;#인증서-생성-방법&quot; class=&quot;headerlink&quot; title=&quot;인증서 생성 방법&quot;&gt;&lt;/a&gt;인증서 생성 방법&lt;/h2&gt;&lt;p&gt;리눅스의 경우 아
        
      
      </description>
      
      
      <content:encoded><![CDATA[<img src="/images/logo/ssh.png"/><h2 id="인증서-생성-방법"><a href="#인증서-생성-방법" class="headerlink" title="인증서 생성 방법"></a>인증서 생성 방법</h2><p>리눅스의 경우 아래의 순서대로 생성한다. <br/></p><ul><li>Run: <strong>ssh-keygen -t rsa</strong>. For a more secure 4096-bit key, run: <strong>ssh-keygen -t rsa -b 4096</strong></li><li>Press enter when asked where you want to save the key (this will use the default location). <br/><br>서버별로 인증서를 생성하고 싶다면 default 가 아닌 파일명을 입력하여 생성하면 된다. <br/><br>ex) Enter file in which to save the key (/root/.ssh/id_rsa): ./vultr_rsa</li><li>Enter a passphrase for your key.</li><li>Run <strong>cat ~/.ssh/id_rsa.pub</strong> - this will give you the key in the proper format to paste into the control panel.<br/><br>서버별로 인증서를 생성했다면 생성된 파일명과 동일하게 설정한다. <br/><br>ex) ./vultr_rsa.pub</li><li>Make sure you backup the <strong>~/.ssh/id_rsa</strong> file. This cannot be recovered if it is lost. </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@greg ~]<span class="comment"># ssh-keygen -t rsa -b 4096</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/root/.ssh/id_rsa):</span><br><span class="line">Created directory <span class="string">&#x27;/root/.ssh&#x27;</span>.</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /root/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /root/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:tRA6/GzG8DevAa+euo6DX4WrLf+f+Bbdcw8Nfy+JVLs root@greg.lee</span><br><span class="line">The key<span class="string">&#x27;s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 4096]----+</span></span><br><span class="line"><span class="string">|        .        |</span></span><br><span class="line"><span class="string">|     . . .       |</span></span><br><span class="line"><span class="string">|      = . .      |</span></span><br><span class="line"><span class="string">|       O o .  o  |</span></span><br><span class="line"><span class="string">|      . S +. o = |</span></span><br><span class="line"><span class="string">|       = +.oo = =|</span></span><br><span class="line"><span class="string">|   .  o   oo.. + |</span></span><br><span class="line"><span class="string">|  . o=   +.+. E o|</span></span><br><span class="line"><span class="string">|   .+==+=    .   |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br></pre></td></tr></table></figure><h2 id="ssh-명령-기본-사용법"><a href="#ssh-명령-기본-사용법" class="headerlink" title="ssh 명령 기본 사용법"></a>ssh 명령 기본 사용법</h2><p>ssh 명령의 기본 사용은 아래와 같다</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@greg: ~] ssh &#123;사용자ID&#125;@&#123;서버명&#125;</span><br></pre></td></tr></table></figure><p>아래와 같은 명령을 내릴 때 ssh 명령은 <strong>~/.ssh/id_rsa</strong> 키 파일을 사용하여 vultr 서버에 root 계정으로 로그인을 시도한다. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@greg: ~] ssh root@vultr</span><br></pre></td></tr></table></figure><p>기본 ssh 키 (~/.ssh/id_rsa) 가 아닌 다른 ssh 키 파일을 사용해야 한다면, 다음과 같이 -i 옵션을 사용해야 한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@greg: ~] ssh root@vultr -i ~/.ssh/vultr.pem </span><br></pre></td></tr></table></figure><h2 id="ssh-config-설정-파일"><a href="#ssh-config-설정-파일" class="headerlink" title="~/.ssh/config 설정 파일"></a>~/.ssh/config 설정 파일</h2><p>여러 ssh 키 파일을 사용할 때 발생하는 문제는 ~/.ssh/config 파일로 해결할 수 있다. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### for vultr</span></span><br><span class="line">Host vultr</span><br><span class="line">HostName 123.123.123.123</span><br><span class="line">User root</span><br><span class="line">IdentityFile ~/.ssh/vultr.pem</span><br><span class="line"></span><br><span class="line"><span class="comment">### for git </span></span><br><span class="line">Host github.com</span><br><span class="line">User git</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_xxxxxxxxxxx</span><br></pre></td></tr></table></figure><p>이렇게 설정할 경우 단순히 아래의 명령으로 해당 서버의 접속이 가능하다</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@greg: ~] ssh root@vultr</span><br></pre></td></tr></table></figure><p>이제 파일 소유권자만 설정 파일을 읽을 수 있도록 권한을 제한해야 한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@greg: ~] chmod 440 ~/.ssh/config</span><br></pre></td></tr></table></figure><h2 id="ssh-config-설정-파일-구성"><a href="#ssh-config-설정-파일-구성" class="headerlink" title="~/.ssh/config 설정 파일 구성"></a>~/.ssh/config 설정 파일 구성</h2><h3 id="호스트-매핑"><a href="#호스트-매핑" class="headerlink" title="호스트 매핑"></a>호스트 매핑</h3><p>호스트 매핑은 Host 속성과 HostName 속성을 이용하여 실제 호스트 URL 에 매핑을 한다. </p><ul><li>Host: ssh 명령에 사용하는 이름</li><li>HostName: host 에 지정된 이름이 매핑되는 실제 호스트명 </li></ul><p>와일드 카드를 이용하여 서브 도메인 지정도 가능하다. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### for vultr</span></span><br><span class="line">Host vultr</span><br><span class="line">HostName 123.123.123.123</span><br><span class="line">User root</span><br><span class="line">IdentityFile ~/.ssh/vultr.pem</span><br><span class="line">Port 12345</span><br><span class="line"></span><br><span class="line"><span class="comment">### for git </span></span><br><span class="line">Host x.greg.com </span><br><span class="line">User git</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_xxxxxxxxxxx</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://daniel-hebn.github.io/2018/06/29/2018-06-29-ssh-%EC%82%AC%EC%9A%A9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>MySQL 성능최적화 (5)</title>
      <link>https://daniel-hebn.github.io/2018/04/14/2018-04-14-MySQL-%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%81%ED%99%94-5/</link>
      <guid>https://daniel-hebn.github.io/2018/04/14/2018-04-14-MySQL-%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%81%ED%99%94-5/</guid>
      <pubDate>Sat, 14 Apr 2018 14:55:00 GMT</pubDate>
      <description>
      
        
        
          &lt;img src=&quot;/images/logo/MySQL_performance_tuning.png&quot;/&gt;&lt;h1 id=&quot;6장-서버-설정-최적화&quot;&gt;&lt;a href=&quot;#6장-서버-설정-최적화&quot; class=&quot;headerlink&quot; title=&quot;6장 서버 설정 최적화&quot;&gt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<img src="/images/logo/MySQL_performance_tuning.png"/><h1 id="6장-서버-설정-최적화"><a href="#6장-서버-설정-최적화" class="headerlink" title="6장 서버 설정 최적화"></a>6장 서버 설정 최적화</h1><h2 id="기본-설정-방법"><a href="#기본-설정-방법" class="headerlink" title="기본 설정 방법"></a>기본 설정 방법</h2><p>MySQL 은 구성 정보를 명령줄 인수와 configuration file 설정에서 받는데 보통 /etc/my.cnf 또는 /etc/mysql/my.cnf 에 있다. 서버가 읽는 설정 파일의 위치를 확인하려면 다음과 같다</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> mysqld </span><br><span class="line">/usr/sbin/mysqld</span><br><span class="line">$ /usr/sbin/mysqld --verbose --<span class="built_in">help</span> | grep -A 1 <span class="string">&#x27;Default options&#x27;</span></span><br><span class="line">/etc/mysql/my.cnf ~/.my.cnf /usr/etc/my.cnf </span><br></pre></td></tr></table></figure><h2 id="문법과-변수의-범위-그리고-동적-재설정"><a href="#문법과-변수의-범위-그리고-동적-재설정" class="headerlink" title="문법과 변수의 범위 그리고 동적 재설정"></a>문법과 변수의 범위 그리고 동적 재설정</h2><p>설정은 모두 소문자로 적고 단어는 _ 나 - 로 구분한다. 둘 다 사용가능한 단어이지만 한 가지 형식만 골라 일관되게 사용할 것을 권장한다. 설정은 여러 범위를 가질 수 있다. 서버 전체에 적용되는 전역 범위 설정, 연결마다 설정이 다르게 가지는 세션 범위 설정 등이 있다. 많은 세션 범위 변수는 그와 동등한 전역 범위 변수를 갖는데 이를 기본값으로 간주할 수 있다.</p><p>설정 파일에 변수를 직접 선언할 수 있지만, 서버가 실행되는 동안에도 여러 가지를 변경할 수 있다. MySQL 에서는 이를 동적 설정 변수라 부른다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> sort_buffer_size <span class="operator">=</span> &#123;<span class="keyword">value</span>&#125;;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> sort_buffer_size <span class="operator">=</span> &#123;<span class="keyword">value</span>&#125;;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@sort</span>_buffer_size :<span class="operator">=</span> &#123;<span class="keyword">value</span>&#125;;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.sort_buffer_size :<span class="operator">=</span> &#123;<span class="keyword">value</span>&#125;;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@global</span>.sort_buffer_size :<span class="operator">=</span> &#123;<span class="keyword">value</span>&#125;;</span><br></pre></td></tr></table></figure><p>서버가 실행되는 동안 변수의 전역 값을 설정하면 현 세션 값과 기존의 다른 세션 값에는 영향을 미치지 않는다. 연결이 생성됐을 때 세션 값이 전역 값에서 초기화되기 때문이다. 따라서 설정을 변경할 때마다 SHOW GLOBAL VARIABLES 의 출력 값을 보고 원하는 결과가 나왔는지 확인해야 한다.</p><h2 id="일반적인-튜닝"><a href="#일반적인-튜닝" class="headerlink" title="일반적인 튜닝"></a>일반적인 튜닝</h2><h3 id="메모리-사용-튜닝하기"><a href="#메모리-사용-튜닝하기" class="headerlink" title="메모리 사용 튜닝하기"></a>메모리 사용 튜닝하기</h3><p>MySQL 의 메모리 소비는 조절할 수 있는 메모리와 조절 할 수 없는 메모리로 나뉜다.</p><p>메모리 튜닝은 다음 단계를 거친다.</p><ol><li>MySQL 이 사용 가능한 최대 메모리를 정한다.</li><li>MySQL 이 정렬 버퍼나 임시 테이블 등의 개별적인 연결에 필요한 메모리 양을 정한다.</li><li>운영체제가 제대로 실행되는 데 필요한 메모리 양을 정한다. 같은 장비에서 실행되는 주기적 배치 작업 등 다른 프로그램이 실행되는 데 필요한 메모리를 포함시킨다.</li><li>나머지 메모리를 InnoDB 버퍼 풀과 같은 MySQL 캐시로 사용한다. </li></ol><h3 id="InnoDB-버퍼-풀"><a href="#InnoDB-버퍼-풀" class="headerlink" title="InnoDB 버퍼 풀"></a>InnoDB 버퍼 풀</h3><p>InnoDB 를 사용한다면 버퍼 풀에 메모리를 많이 할당해야 한다. InnoDB 버퍼 풀은 인덱스를 캐시할 뿐 아니라 레코드 데이터, 어댑티브 해시 인덱스, 인서트 버퍼, 잠금 및 그 밖의 내부 구조를 가지고 있다. 또한, InnoDB 는 여러 쓰기 작업을 통합하고 순차적으로 실행하기 위해 버퍼 풀을 사용해 쓰기를 지연시킨다.</p>]]></content:encoded>
      
      <comments>https://daniel-hebn.github.io/2018/04/14/2018-04-14-MySQL-%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%81%ED%99%94-5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>MySQL 성능최적화 (4)</title>
      <link>https://daniel-hebn.github.io/2018/04/14/2018-04-14-MySQL-%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%81%ED%99%94-4/</link>
      <guid>https://daniel-hebn.github.io/2018/04/14/2018-04-14-MySQL-%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%81%ED%99%94-4/</guid>
      <pubDate>Sat, 14 Apr 2018 14:50:00 GMT</pubDate>
      <description>
      
        
        
          &lt;img src=&quot;/images/logo/MySQL_performance_tuning.png&quot;/&gt;&lt;h1 id=&quot;4장-쿼리-성능-최적화&quot;&gt;&lt;a href=&quot;#4장-쿼리-성능-최적화&quot; class=&quot;headerlink&quot; title=&quot;4장 쿼리 성능 최적화&quot;&gt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<img src="/images/logo/MySQL_performance_tuning.png"/><h1 id="4장-쿼리-성능-최적화"><a href="#4장-쿼리-성능-최적화" class="headerlink" title="4장 쿼리 성능 최적화"></a>4장 쿼리 성능 최적화</h1><p>일반적으로 MySQL 은 WHERE 절을 세 가지 방법으로 사용할 수 있다. 제일 좋은 방법부터 알아보면 다음과 같다.</p><ul><li>적용되지 않는 행을 제거하기 위해 인덱스 탐색에 조건을 적용한다. 이는 스토리지 엔진 계층에서 동작한다.</li><li>적절한 커버링 인덱스를 사용하여, 행에 접근하지 않고 인덱스로부터 결과를 가져온 뒤 조건에 맞지 않는 행을 제거한다 (Extra 컬럼의 Using Index) 이는 서버 계층에서 동작하지만 테이블로부터 행을 읽을 필요는 없다.</li><li>테이블로부터 값을 가져온 뒤, 조건에 맞지 않는 행을 제거하는 데 사용한다 (Extra 컬럼의 Using where) 이는 서버 계층에서 일어나며, 조건에 맞지 않는 것을 제거하기 전에 테이블로부터 값을 읽어들여야 한다.</li></ul><p>상대적으로 적은 행을 얻기 위해 많은 수의 행을 조사하는 쿼리를 찾았다면 다음과 같은 방법을 통해 수정해보자.</p><ul><li>스토리지 엔진이 전체 행을 가져올 필요가 없도록 데이터를 저장하고 있는 인덱스를 사용한다</li><li>스키마를 변경한다. 그 중 한가지 예는 집계 테이블을 사용하는 것이다.</li><li>복잡한 쿼리를 MySQL 옵티마이저가 적절하게 최적화할 수 있는 방식으로 다시 작성한다.</li></ul><h2 id="쿼리를-재구성하는-방법"><a href="#쿼리를-재구성하는-방법" class="headerlink" title="쿼리를 재구성하는 방법"></a>쿼리를 재구성하는 방법</h2><p>문제 있는 쿼리를 최적화하는 것은 원하는 결과를 보이면서 이 쿼리를 대체할 수 있는 다른 쿼리를 찾는 것이다. 하지만 이 말은 MySQL 로부터 같은 결과를 돌려받아야 하는 것을 의미하지는 않는다. 같은 결과셋을 반환하면서도 성능이 더 좋게 나오도록 쿼리를 변경할 수 있는 경우도 있지만, 때로는 성능상의 이점을 고려하여 쿼리를 다른 결과셋을 반환하는 쿼리로 변경하는 것을 고려해야 한다. </p><h3 id="복잡한-쿼리-vs-여러-개의-쿼리"><a href="#복잡한-쿼리-vs-여러-개의-쿼리" class="headerlink" title="복잡한 쿼리 vs 여러 개의 쿼리"></a>복잡한 쿼리 vs 여러 개의 쿼리</h3><p>전통적으로 데이터베이스를 설계할 때는 소수의 쿼리로 가능한 많은 일을 하도록 해왔다. 이런 방식은 네트워크 통신 비용과 쿼리 파싱 및 최적화 단계의 오버헤드 때문에 역사적으로 좋은 결과를 보여왔다.</p><p>하지만 MySQL 은 접속을 하고 끊는 걸 매우 효율적으로 하도록 설계되었고, 작고 간단한 쿼리들에 아주 빠르게 응답한다. 게다가 최신 네트워크는 예전에 비해 굉장히 빨라졌고, 네트워크 지연도 줄어들었으므로 MySQL 에서는 위에서 얘기한 문제가 발생하지 않는다.</p><p>MySQL 은 간단한 쿼리를 1초에 50,000 개도 넘게 처리할 수 있으므로 각각의 경우에 대한 비용을 계산해 본 뒤 더 가벼워 보이는 방법을 사용하자. </p><h3 id="조인-분해"><a href="#조인-분해" class="headerlink" title="조인 분해"></a>조인 분해</h3><p>높은 성능을 내는 웹사이트들은 조인 분해 (join decomposition)를 사용한다. 다중 테이블을 조인하기보단 여러 개의 단일 테이블 쿼리들을 실행한 뒤 애플리케이션에서 값을 조인하는 방법을 통해 조인을 분해할 수 있다. 이런 식으로 쿼리를 재구성하면 성능상에선 확실히 이득이 있다.</p><ul><li>많은 애플리케이션에서는 테이블에 직접 매핑되는 ‘객체’를 캐시하므로, 캐시가 더 효율적으로 동작할 수 있다. 어떤 한 테이블만 빈번하게 변한다면, 조인을 분해하는 것을 통해 캐시 무효화를 줄일 수 있다.</li><li>애플리케이션에서 조인을 하게 되면 테이블들을 여러 서버로 분산시켜서 큰 규모로 쉽게 만들 수 있다.</li><li>쿼리 자체도 효율성이 더 높아진다. 예를 들어 MySQL 에서 조인 대신 IN() 리스트를 사용하게 되면 조인을 사용할 때보다 더 적절한 방법을 이용해서 행 ID들을 정렬하고 가져온다. </li><li>행을 중복해서 접근하는 것을 줄일 수 있다. 애플리케이션에서 조인을 하게 되면 각 행을 단 한번만 가져오면 되는 반면 조인을 사용할 떄에는 같은 데이터에 반복해서 접근하는 비정규화가 필요해진다. 그렇기 때문에 이런 식으로 쿼리를 변경하면 전체 네트워크 트래픽이나 메모리 사용량을 줄일 수 있다</li></ul><h2 id="쿼리-실행의-기초"><a href="#쿼리-실행의-기초" class="headerlink" title="쿼리 실행의 기초"></a>쿼리 실행의 기초</h2><img src="/2018/04/14/2018-04-14-MySQL-%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%81%ED%99%94-4/query_execute_path.jpg" class="" title="쿼리 실행 경로"><ol><li>클라이언트는 서버로 SQL 구문을 보낸다.</li><li>서버는 쿼리 캐시를 체크하고, 만약 캐시에 쿼리가 있다면 캐시에 저장된 결과를 반환한다. 만약 캐시에 쿼리가 없다면 SQL 구문은 다음 단계로 넘어간다.</li><li>서버는 SQL 을 파싱하고, 전처리하고, 최적화한 뒤 쿼리 실행 계획으로 만든다.</li><li>쿼리 실행 엔진은 스토리지 엔진 API 를 호출하는 것을 통해 계획을 실행한다.</li><li>서버는 결과를 클라이언트로 보내준다.</li></ol><h3 id="MySQL-클라이언트-서버-프로토콜"><a href="#MySQL-클라이언트-서버-프로토콜" class="headerlink" title="MySQL 클라이언트/서버 프로토콜"></a>MySQL 클라이언트/서버 프로토콜</h3><p>MySQL 의 클라이언트/서버 프로토콜은 반이중 방식이므로 MySQL 서버가 메시지를 보내고 받는 건 모두 가능하지만, 이 두 가지 동작을 동시에 수행하지는 못한다. 그렇기 때문에 메시지를 짧게 자를 수는 없다. 이런 프로토콜로 인해 MySQL 은 간단하고 빠르게 통신할 수 있지만 약간의 제약을 받기도 한다. </p><p>그 중 하나로는 흐름을 제어할 수 없다는 점이 있다. 한 쪽에서 메시지를 보내기 시작하면 다른 쪽에서는 메시지 전체를 받기 전에는 응답할 수 없다. 어떤 때에든 공은 한쪽만이 가지고 있고, 공을 가지고 있지 않는다면 공을 토스할 수 없다.</p><p>클라이언트는 쿼리를 단일 패킷 형태로 전송하므로 커다란 쿼리를 사용해야 한다면 <code>max_packet_size</code> 설정 값을 잘 설정해야 한다. 쿼리를 보내고 나면 클라이언트는 결과를 기다리는 것 외엔 아무 것도 할 수 없다.</p><p>반면에 서버로부터의 응답은 여러 패킷에 걸쳐서 전송된다. 서버가 응답하게 되면 클라이언트는 모든 결과 셋을 받아야 하며, 필요한 행 몇 개만 받은 뒤 나머지는 보내지 말라고 요청하는 것은 불가능하다. 이렇기에 적합한 LIMIT 절을 사용하는 것이 필요하겠다.</p><p>MySQL 서버가 행들을 생성하자마자 클라이언트에 밀어주고, 클라이언트는 밀려온 행들을 받는 역할밖에 하지 않는다. 서버 측에 행을 그만 보내라는 얘기를 전할 방법이 없기 때문에 클라이언트 측은 ‘소방 호스로부터 물을 마시는 상황’ (drinking from the fire hose) 일 수 밖에 없다.</p><p>MySQL 에 접속하기 위한 라이브러리들은 대부분 전체 결과 셋을 가져온 뒤 메모리에 저장해두거나 필요할 때 행을 하나씩 가져온다. 일반적으로 기본 동작은 전체 결과 셋을 메모리에 저장해두는 것이다. 서버는 행들을 모두 가져가기 전에는 쿼리에 필요한 락과 리소스들을 해제하지 않고, 쿼리를 ‘Sending data’ 상태로 만든다. 클라이언트 라이브러리가 결과를 한 번에 패치하게 되면, 서버가 할 일이 줄어들므로 쿼리를 가능한 빠르게 마무리할 수 있다.<br><br/></p><h4 id="쿼리-상태"><a href="#쿼리-상태" class="headerlink" title="쿼리 상태"></a>쿼리 상태</h4><p>각 MySQL 연결이나 스레드는 어떤 시점에 뭘 하고 있는지를 나타내는 상태를 가지고 있다. 이런 상태를 확인하는 방법은 여러 가지가 있고, 그 중 가장 사용하기 쉬운 것은 SHOW FULL PROCESSLIST 명령이다. 쿼리가 수행되는 동안 상태는 여러 번 바뀌게 되며, 이 상태는 여러 가지가 있다. </p><ul><li>Sleep : 스레드가 클라이언트로부터 새로운 쿼리를 기다림</li><li>Query : 스레드가 쿼리를 실행하거 있거나 결과를 클라이언트로 보내고 있음</li><li>Locked : 스레드가 서버 레벨에서 권한을 얻기 위해 테이블 락을 기다리고 있음. 락은 InnoDB 의 레코드 락처럼 스토리지 엔진에 의해 구현되며, 스토리지 엔진이 구현한 락은 스레드 자체를 Locked 상태로 만들진 않는다. </li><li>Analyzing 과 statics : 스레드가 스토리지 엔진의 통계 체크 및 쿼리 최적화를 수행 중임</li><li>Copying to tmp table (on disk) : 스레드가 쿼리를 실행하고, GROUP BY, UNION, 파일 정렬 등을 처리하기 위해 임시 테이블로 결과를 복사하고 있음. 상태가 ‘on disk’로 끝난다면 MySQL 은 메모리에 있는 테이블을 디스크에 있는 테이블로 변환하고 있다는 것을 의미한다</li><li>Sorting result : 스레드는 결과 셋을 정렬 중임</li><li>Sending data : 이 상태는 여러 가지 상황을 의미한다. 현재 스레드는 쿼리의 단계 사이에서 데이터를 전송하고 있을 수도 있고, 결과를 만들어내고 있을 수도, 클라이언트에게 결과 셋을 보내주고 있을 수도 있다. <br/></li></ul><h3 id="쿼리-캐시"><a href="#쿼리-캐시" class="headerlink" title="쿼리 캐시"></a>쿼리 캐시</h3><p>캐시가 활성화된 경우 MySQL 은 쿼리를 파싱하기도 전에 쿼리 캐시부터 검사한다. 검사를 위해서는 대소문자를 구별하는 해시 탐색을 이용하며, 모든 바이트가 정확히 일치하는 쿼리가 없다면 캐시에 쿼리가 없다고 판단하고, 다음 단계로 넘어가게 된다.</p><p>MySQL 이 캐시에서 동일한 쿼리를 찾으면, 캐시된 쿼리를 돌려주기 전에 권한을 검사해야 한다. MySQL 에서는 캐시된 쿼리가 사용하는 테이블 정보를 저장해두고 있기 때문에 쿼리를 파싱하지 않더라도 권한 체크가 가능하다. </p><h3 id="쿼리-최적화-단계"><a href="#쿼리-최적화-단계" class="headerlink" title="쿼리 최적화 단계"></a>쿼리 최적화 단계</h3><p>생략…<br><br/></p><h2 id="특정-형식의-쿼리-최적화하기"><a href="#특정-형식의-쿼리-최적화하기" class="headerlink" title="특정 형식의 쿼리 최적화하기"></a>특정 형식의 쿼리 최적화하기</h2><h3 id="1-count-쿼리-최적화하기"><a href="#1-count-쿼리-최적화하기" class="headerlink" title="1. count() 쿼리 최적화하기"></a>1. count() 쿼리 최적화하기</h3><p>COUNT() 는 두 가지 방식으로 동작하는 특별한 함수다. 이 함수를 통해 값을 셀 수도 있고, 행을 셀 수도 있으며 값은 NULL 이 아닌 것을 의미한다. 괄호 안에 컬럼 이름이나 다른 표현을 넣는다면, COUNT() 는 이 표현이 몇 번이나 값을 가지는지를 세게 된다.</p><p>다른 형태의 COUNT() 는 단순히 결과에 있는 행 수를 세게 된다. 괄호 안에 있는 표현이 절대 NULL 을 가질 수 없는 경우 이런 식으로 동작하게 되며 일반적인 예로는 COUNT(*) 를 들 수 있다.</p><p>일반적으로 자주 하는 실수로는 행 수를 세기 위해 괄호 안에 컬럼 이름을 적어주는 경우를 들 수 잇다. 결과에 있는 행 수를 알고 싶을 때에는 꼭 COUNT(*) 를 사용해야 한다. </p><h3 id="2-복잡한-최적화"><a href="#2-복잡한-최적화" class="headerlink" title="2. 복잡한 최적화"></a>2. 복잡한 최적화</h3><p>일반적으로 COUNT()를 사용하는 쿼리들은 많은 행을 세어야 하며 따라서 많은 데이터에 접근해야 하므로 최적화하기가 쉽지 않다. 그나마 사용 가능한 방법으로는 커버링 인덱스를 사용할 수 있게 만드는 정도 밖에 없으며, 이 정도로 충분하지 않은 경우에는 애플리케이션 구조를 바꾸는 것 외에는 도리가 없다. 집계 테이블을 사용하거나 memcached 같은 외부 캐시 시스템을 사용하는 것도 한번 생각해보자.</p><h2 id="조인-쿼리-최적화하기"><a href="#조인-쿼리-최적화하기" class="headerlink" title="조인 쿼리 최적화하기"></a>조인 쿼리 최적화하기</h2><ul><li>ON 이나 USING 절에 사용되는 컬럼에 대해 꼭 인덱스를 추가해주자. 그리고 인덱스를 추가해줄 때는 조인이 되는 순서를 고려해야 한다. 만약 컬럼 c 를 이용해서 테이블 A 와 B 를 조인하고, 쿼리 옵티마이저가 테이블을 B, A 순서로 조인하게 된다면 테이블 B 에는 c 컬럼에 대한 인덱스를 만들 필요가 없다. 사용되지 않는 인덱스는 불필요한 오버헤드일 뿐이다. 일반적으로 다른 이유가 없으면 조인할 때 두 번째 테이블에만 인덱스를 추가하게 된다.</li><li>GROUP BY 나 ORDER BY 를 사용할 때는 MySQL 이 인덱스를 활용할 수 있게끔 한 테이블에 있는 컬럼만 이용하도록 하자</li><li>조인 구문이나 명령어 우선 순위, 혹은 어떤 동작 방식 등이 바뀔 수 있으므로 MySQL 업그레이드 할 때는 항상 조심해야 한다. </li></ul><h2 id="파티션-테이블"><a href="#파티션-테이블" class="headerlink" title="파티션 테이블"></a>파티션 테이블</h2><p>파티션 테이블의 중요한 이점은 다음과 같다.</p><ul><li>특정 행들이 한 파티션에 저장됨을 명시할 수 있는데 이는 서버가 검사해야 할 데이터 양을 줄이고 쿼리를 더 빠르게 한다. 예를 들어, 날짜 범위에 따라 파티션한 후 한 파티션에만 접근하는 날짜 범위로 질의하면 서버는 그 파티션만 읽는다.</li><li>파티션된 데이터는 그렇지 않은 데이터보다 관리하기 쉽고 파티션 전체를 제거하는 식으로 오래된 데이터를 버리기도 쉽다.</li><li>파티션된 데이터는 물리적으로 분산될 수 있고 이는 서버가 여러 개의 하드 드라이브를 더욱 효율적으로 사용하게 해준다.</li></ul><p>파티션에 관한 수많은 자료를 읽어본 후 CREATE TABLE, SHOW CREATE TABLE, ALTER TABLE, INFORMATION_SCHEMA.PARTITIONS, EXPLAIN 에 대한 설명을 살펴봐야 한다. 파티션 때문에 CREATE TABLE, ALTER TABLE 이 훨씬 복잡하다.</p><p>파티션 테이블은 실제로는 스토리지 엔진 수준에서 별개의 인덱스를 가진 별개의 테이블(파티션)을 묶은 컬렉션이다. 이는 파티션 테이블의 메모리와 파일 기술자에 대한 요구사항이 파티션 테이블의 경우와 비슷하지만, 파티션은 테이블에서 독립적으로 접근이 안 되며 각 파티션은 한 테이블에만 속한다.</p><p>MySQL 은 파티션 함수를 이용해 어느 행을 어느 파티션에 저장할지 결정한다. 함수는 상수가 아닌 확정적으로 정수값을 반환해야 한다. 파티션은 여러 종류가 있는데 범위 파티션은 파티션마다 일정 범위의 값을 정하고, 행의 값이 어느 범위에 속하는지에 따라 행을 파티션에 할당한다. MySQL 은 키, 해시, 리스트 할당 메서드도 제공한다. </p><h3 id="파티션이-효율적인-이유"><a href="#파티션이-효율적인-이유" class="headerlink" title="파티션이 효율적인 이유"></a>파티션이 효율적인 이유</h3><p>MySQL 에 파티션 테이블을 설계할 때의 핵심은 파티션을 결이 거친 인덱스 정도로 생각하는 것이다. 날짜별 쿼리의 속도를 높이는 접근방법 중 하나는 (day, itemno) 컬럼에 기본 키를 추가하고 InnoDB 를 쓰는 것이다. 이렇게 하면 각 날짜의 데이터가 물리적으로 묶이고, 따라서 범위 질의는 데이터를 더 적게 검사한다. 기본 키를 빼고 데이터를 날짜별로 파티션하는 방법도 있다. 파티션은 MySQL 에 해당 행을 어디서 찾으면 되는지 대략 알려준다.</p><h3 id="파티션-사례"><a href="#파티션-사례" class="headerlink" title="파티션 사례"></a>파티션 사례</h3><ol><li>날짜 기반의 데이터를 저장하는 파티션 테이블을 설계하는 법을 살펴보자. 제품별 주문 및 판매에 대한 성능 통계를 모았다고 해보자. 날짜 범위에 따라 쿼리를 자주 실행하기 때문에 기본 키의 첫 번째 위치에 주문 날짜를 두고 InnoDB 스토리지 엔진을 이용해 날짜별로 데이터를 클러스터링 한다. 이제 날짜 범위에 따라 테이블을 파티션 함으로써 상위 수준에서 데이터를 ‘클러스터링’ 할 수 있다.</li></ol><p>아래는 파티션 명세를 제외한 기본적인 테이블 정의 예시다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sales_by_day (</span><br><span class="line"><span class="keyword">day</span> <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">product <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">sales <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">returns</span> <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(<span class="keyword">day</span>, product)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure><p>연도별 파티션은 날짜별 파티션과 더불어 날짜 기반의 데이터를 다룰 때 흔히 쓰는 방법이다. YEAR() 와 TO_DAYS() 함수는 이런 경우에 파티션 함수로 쓰기 좋다. 일반적으로 범위 파티션에 좋은 함수는 파티션하고자 하는 값과 선형 관계가 있고 YEAR() 와 TO_DAYS() 같은 함수는 그러한 조건에 잘 맞는다. 이제 연도별로 파티션 해보자</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sales_by_day </span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(<span class="keyword">YEAR</span>(<span class="keyword">day</span>)) (</span><br><span class="line"><span class="keyword">PARTITION</span> p_2014 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2015</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p_2015 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2016</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p_2016 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2017</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p_2017 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2018</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p_catchall <span class="keyword">VALUES</span> LESS THAN MAXVALUE);</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>이제 행을 삽입하면 날짜(day) 컬럼의 값에 따라 알맞은 파티션에 저장된다. </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> sales_by_day (<span class="keyword">day</span>, product, sales, <span class="keyword">returns</span>) <span class="keyword">VALUES</span> </span><br><span class="line">   (<span class="string">&#x27;2017-01-15&#x27;</span>, <span class="number">19</span>, <span class="number">50.00</span>, <span class="number">52.00</span>),</span><br><span class="line">   (<span class="string">&#x27;2017-09-23&#x27;</span>, <span class="number">11</span>, <span class="number">41.00</span>, <span class="number">42.00</span>);</span><br></pre></td></tr></table></figure><p>그런데 이 테이블 구조에는 한계점이 존재한다. 나중에 연도를 추가하려면 테이블을 고쳐야 하는데(alter) 테이블이 클 땐 비용이 많이 든다. 일단 필요하리라 생각하는 양보다 더 많은 연도를 정의하는 편이 좋을지 모른다. 미리 포함시킨다고 해서 성능에 영향을 미치지는 않기 때문이다.</p><p>파티션 테이블은 큰 테이블의 행을 단순히 분산시킬 때에도 많이 쓴다. 거대한 테이블이 있고 쿼리 여러 개가 그 테이블에서 동작한다고 가정해보자. 물리적으로 다른 여러 디스크가 데이터를 제공하길 바란다면, MySQL 이 행을 여러 디스크에 걸쳐 분산시켜야 한다. 이 경우에는 관련 있는 데이터를 가까이 두는 것에는 관심이 없으며, 그저 데이터를 고르게 분산시킬 수만 있으면 된다. 아래의 DDL 은 MySQL 이 행을 기본 키 계수에 따라 행을 분산하게 한다. 이는 파티션 사이에 데이터를 고르게 퍼뜨리기에 좋은 방법이다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mydb.very_big_table</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> KEY (<span class="keyword">primary</span> key columns) (</span><br><span class="line"><span class="keyword">PARTITION</span> p0 DATA DIRECTORY <span class="operator">=</span> <span class="string">&#x27;/data/mydb/big_table_p0&#x27;</span>,</span><br><span class="line"><span class="keyword">PARTITION</span> p1 DATA DIRECTORY <span class="operator">=</span> <span class="string">&#x27;/data/mydb/big_table_p1&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="파티션-테이블의-제약-사항"><a href="#파티션-테이블의-제약-사항" class="headerlink" title="파티션 테이블의 제약 사항"></a>파티션 테이블의 제약 사항</h3><ul><li>모든 테이블이 동일한 스토리지 엔진을 써야 한다.</li><li>파티션 테이블의 유니크 인덱스는 모두 파티션 함수가 참조하는 컬럼을 포함해야 한다. </li><li>MySQL 이 쿼리 처리 중에 파티션 테이블의 모든 파티션에 접근하지 않아도 될지라도 여전히 모든 파티션을 잠근다.</li><li>파티션 함수에 써도 되는 함수와 표현식에 제약이 아주 많다.</li><li>외래 키가 동작하지 않는다</li><li>LOAD INDEX INTO CACHE 를 못 쓴다.</li></ul><h3 id="파티션된-테이블용-쿼리-최적화하기"><a href="#파티션된-테이블용-쿼리-최적화하기" class="headerlink" title="파티션된 테이블용 쿼리 최적화하기"></a>파티션된 테이블용 쿼리 최적화하기</h3><p>WHERE 절에 파티션된 키를 명시하는 일은 아주 중요하다. 이렇게 하지 않으면 쿼리 실행 엔진이 테이블의 모든 파티션에 접근해야 한다. MySQL 은 파티션 함수의 컬럼과 비교한 결과에 따라 쳐내는 것만 가능하다. 표현식의 결과에 근거를 두고 쳐내진 못한다. </p>]]></content:encoded>
      
      <comments>https://daniel-hebn.github.io/2018/04/14/2018-04-14-MySQL-%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%81%ED%99%94-4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>MySQL 성능최적화 (3)</title>
      <link>https://daniel-hebn.github.io/2018/04/14/2018-04-14-MySQL-%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%81%ED%99%94-3/</link>
      <guid>https://daniel-hebn.github.io/2018/04/14/2018-04-14-MySQL-%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%81%ED%99%94-3/</guid>
      <pubDate>Sat, 14 Apr 2018 14:45:00 GMT</pubDate>
      <description>
      
        
        
          &lt;img src=&quot;/images/logo/MySQL_performance_tuning.png&quot;/&gt;&lt;h1 id=&quot;3장-스키마-최적화와-인덱싱&quot;&gt;&lt;a href=&quot;#3장-스키마-최적화와-인덱싱&quot; class=&quot;headerlink&quot; title=&quot;3장 스키마 최
        
      
      </description>
      
      
      <content:encoded><![CDATA[<img src="/images/logo/MySQL_performance_tuning.png"/><h1 id="3장-스키마-최적화와-인덱싱"><a href="#3장-스키마-최적화와-인덱싱" class="headerlink" title="3장 스키마 최적화와 인덱싱"></a>3장 스키마 최적화와 인덱싱</h1><h2 id="최적의-데이터-타입-고르기"><a href="#최적의-데이터-타입-고르기" class="headerlink" title="최적의 데이터 타입 고르기"></a>최적의 데이터 타입 고르기</h2><p>MySQL 은 꽤 다양한 데이터 타입을 지원하는데, 데이터를 저장하는 데 적합한 데이터 타입을 고르는 것은 좋은 성능을 얻는데 필수적이다. 데이터 타입 선택의 주요 원칙은 아래와 같다. </p><ul><li>대체로 작을수록 좋다</li><li>단순한게 최고다 : 날짜와 시간은 문자열로 저장하지 말고, MySQL 의 내장 형식에 저장해야 하며 IP 주소는 정수를 이용해 저장해야 한다. </li><li>가능하면 NULL 을 쓰지 말자 : NULL 허용 컬럼으로 인해 인덱스, 인덱스 통계, 값 비교 등이 더 복잡해진다. 게다가 NULL 허용 컬럼은 저장 공간도 더 많이 사용하며, MySQL 내부에서 특별하게 처리해 줄 필요가 있다. NULL 대신 0 이나 특수한 어떤 값, 빈 문자열 등을 사용하는 것을 고려해보자. 대체로 NULL 컬럼을 NOT NULL 로 바꾼다고 성능이 크게 개선되지는 않으니 기존 스키마에서 NULL 허용 컬럼을 찾아 수정하지는 말자. 하지만 컬럼을 인덱싱할 계획이라면 최대한 NULL 을 허용하지 말자 </li></ul><p>컬럼에 어떤 데이터 타입을 쓸지 결정할 때는 숫자, 문자열, 시간 같은 개괄적인 범위의 타입부터 결정한 후에 구체적인 데이터 타입을 선택하자. MySQL의 데이터 타입은 같은 데이터 종류를 다루면서 저장할 수 있는 값의 범위와 필요한 물리적 공간의 양이 다르고, 어떤 데이터 타입은 특별한 행동 양식을 보이기도 한다.</p><p>한 예로 <strong>DATETIME</strong> 과 <strong>TIMESTAMP</strong> 컬럼은 똑같은 종류의 데이터인 날짜/시간을 초 단위로 저장할 수 있다. 그러나 <strong>TIMESTAMP</strong> 는 <strong>DATETIME</strong> 보다 저장 공간을 절반 밖에 사용하지 않고, 서버측 시간대를 사용하며, 자동 업데이트라는 특별한 기능이 있다. 반면 허용되는 값의 범위가 훨씬 작고 때로는 특수한 기능이 약점이 되기도 한다. </p><h3 id="1-정수-타입"><a href="#1-정수-타입" class="headerlink" title="1. 정수 타입"></a>1. 정수 타입</h3><p>정수를 저장한다면 <strong>TINYINT</strong>, <strong>SMALLINT</strong>, <strong>MEDIUMINT</strong>, <strong>INT</strong>, <strong>BIGINT</strong> 중 하나를 사용하자. 이 타입들은 순서대로 8, 16, 24, 32, 64비트의 저장 공간이 필요하다. 정수 타입에는 UNSIGNED 속성을 사용할 수도 있으며, 이 속성은 음수 값을 허용하지 않는 대신 저장 가능한 양수 값의 한도를 거의 두배로 늘려준다.</p><p>MySQL 에선 INT(11)과 같이 정수 타입의 ‘길이’를 명시할 수 있다. 하지만 이 기능은 값의 유효 범위를 제한하진 않고, MySQL 클라이언트 같은 프로그램의 화면 출력용으로 예약하는 문자의 개수를 정할 뿐이므로 대부분의 응용프로그램에선 별다른 의미가 없다. 저장이나 계산 측면에선 INT(1) 과 INT(20) 은 동일하다. </p><h3 id="2-실수-타입"><a href="#2-실수-타입" class="headerlink" title="2. 실수 타입"></a>2. 실수 타입</h3><p>실수는 소수부가 있는 숫자다. 하지만 단지 수소부 때문에 실수가 있는 건 아니다. <strong>BIGINT</strong> 로 표현할 수 없을 만큼 큰 정수도 <strong>DECIMAL</strong> 을 이용하면 저장 가능하다. MySQL 에서는 정확한 타입과 부정확한 타입을 모두 지원한다.</p><p><strong>DECIMAL</strong> 타입은 소수부를 정확하게 저장하는 용도로 사용한다. MySQL 5.0 이상에선 <strong>DECIMAL</strong> 타입을 통해 정확한 계산을 지원한다. (<strong>DECIMAL</strong> 하나에 최대 65개의 수를 저장할 수 있다) <strong>DECIMAL</strong> 을 사용하면 저장 공간과 연산 비용이 더 들기 때문에 금융 데이터를 저장하는 경우처럼 소수부에 대한 정확한 결과 값이 필요할 때에만 <strong>DECIMAL</strong> 을 사용하자.</p><h3 id="3-문자열-타입"><a href="#3-문자열-타입" class="headerlink" title="3. 문자열 타입"></a>3. 문자열 타입</h3><h4 id="VARCHAR-타입과-CHAR-타입"><a href="#VARCHAR-타입과-CHAR-타입" class="headerlink" title="VARCHAR 타입과 CHAR 타입"></a>VARCHAR 타입과 CHAR 타입</h4><p>스토리지 엔진에 따라 저장하는 방식과 서버가 스토리지 엔진에서 값을 꺼낼 때 다른 스토리지 포맷으로 변환할 수도 있으니 주의하자. </p><ul><li>VARCHAR: <strong>VARCHAR</strong> 는 가변 길이의 문자열을 저장하는 가장 흔한 문자열 데이터 타입이다. <strong>VARCHAR</strong> 는 필요한 만큼만 공간을 사용하기 때문에 고정 길이 타입보다 저장 공간을 적게 사용하기도 한다. <strong>VARCHAR</strong> 는 값의 길이를 기록하기 위해 추가로 1~2 바이트를 사용한다. 칼럼의 최대 길이가 255 바이트 이하면 1바이트를 사용하고, 최대 길이가 그보다 길면 2바이트를 사용한다.</li><li>VARCHAR 는 공간을 절약하므로 성능에 도움이 된다. 하지만 행이 가변 길이이므로 행을 업데이트할 때 행의 길이가 길어지기도 하고, 이 때문에 추가적인 작업이 필요할 수도 있다. 그리고 MySQL 버전 5.0 이상에서는 문자열 뒤에 붙은 공백을 보존한다. 하지만 4.1 버전이나 이전 버전의 경우엔 뒤에 붙는 공백을 제거한다. </li><li>CHAR: <strong>CHAR</strong> 는 고정 길이이므로 MySQL 에선 항상 지정된 문자 개수에 맞춰 충분한 공간을 할당한다. CHAR 값을 저장할 때 MySQL 에서는 뒤에 붙은 공백을 제거한다. CHAR 는 아주 짧은 문자열을 저장하고자 할 때나 모든 값이 거의 같은 길이일 때 유용하다. 예를 들어 MD5 의 경우 값의 길이가 언제나 같기 때문에 이 값을 저장할 땐 <strong>CHAR</strong> 가 적합하다. 고정 길이의 행은 단편화가 거의 발생하지 않으므로 자주 바뀌는 데이터를 저장할 때라면 <strong>CHAR</strong> 가 <strong>VARCHAR</strong> 보다 낫다. 아주 짧은 컬럼에도 <strong>CHAR</strong> 를 쓰는 것이 <strong>VARCHAR</strong> 를 쓰는 것보다 효율적이다. Y 와 N 값만 저장하는 것처럼 한 바이트 문자셋이라면 CHAR(1) 는 1바이트만 쓰지만 VARCHAR(1) 에선 길이 바이트 때문에 2바이트를 쓴다.</li><li>BINARY 와 VARBINARY: 바이너리 문자열은 전통적인 문자열과 매우 비슷하지만 문자가 아닌 바이너리를 저장하며 여백을 채우는 방법이 다르다. MySQL 은 바이너리 값에 공백이 아닌 \0 (값이 0 인 바이트)을 덧붙이고 값을 가져올 때도 여백 값을 잘라내지 않는다. 이 타입은 바이너리 데이터를 저장해야 하며, MySQL 에서 값을 문자가 아닌 바이트로써 비교하고 싶을 때 유용하게 사용할 수 있다. MySQL 에서는 문자 그대로 <strong>BINARY</strong> 문자열을 각 바이트의 숫자 값에 따라 한번에 한 바이트씩 비교하므로 문자열 비교보다 간단하고 훨씬 빠르다.</li></ul><h4 id="BLOB-타입과-TEXT-타입"><a href="#BLOB-타입과-TEXT-타입" class="headerlink" title="BLOB 타입과 TEXT 타입"></a>BLOB 타입과 TEXT 타입</h4><p><strong>BLOB</strong> 과 <strong>TEXT</strong> 는 각각 커다란 바이너리 문자열과 문자열을 저장하려고 고안된 데이터 타입이다. InnoDB 에선 <strong>BLOB</strong> 또는 <strong>TEXT</strong> 의 값이 큰 경우 별도의 ‘외부’ 저장 공간을 사용한다. <strong>BLOB</strong> 과 <strong>TEXT</strong> 의 유일한 차이점은 <strong>BLOB</strong> 은 문자 셋이나 콜레이션이 없는 바이너리를 저장하는 반면, <strong>TEXT</strong> 타입은 문자 셋과 콜레이션이 있다는 것밖에 없다.</p><p>MySQL 은 <strong>BLOB</strong> 과 <strong>TEXT</strong> 를 다른 타입과 다른 방법으로 정렬한다. 문자열을 통쨰로 정렬하지는 않으며, 컬럼에서 <code>max_sort_length</code> 바이트 값만큼 문자열을 가져와서 정렬한다. MySQL 은 이런 데이터 타입의 값 전체를 가지고 인덱스를 만들진 못하고, 정렬을 하는 데 인덱스를 사용할 수도 없다. </p><h4 id="문자열-타입-대신-ENUM-사용"><a href="#문자열-타입-대신-ENUM-사용" class="headerlink" title="문자열 타입 대신 ENUM 사용"></a>문자열 타입 대신 ENUM 사용</h4><p><strong>ENUM</strong> 컬럼은 독립적인 문자열 값들을 65,535개 까지 저장한다. MySQL 은 ENUM 값을 매우 효율적으로 저장한다.</p><p><strong>ENUM</strong> 의 가장 큰 문제는 문자열 목록이 고정되며, 문자열을 추가하거나 지우려면 <code>ALTER TABLE</code> 을 사용해야 한다는 것이다. 또한 MySQL 에선 <strong>ENUM</strong> 컬럼의 값을 정수로 저장하고, 값을 가져올 때는 이를 문자열 표현으로 변환하기 때문에 추가적인 비용이 든다. </p><h3 id="4-날짜-및-시간-타입"><a href="#4-날짜-및-시간-타입" class="headerlink" title="4. 날짜 및 시간 타입"></a>4. 날짜 및 시간 타입</h3><h4 id="DATETIME"><a href="#DATETIME" class="headerlink" title="DATETIME"></a>DATETIME</h4><p>이 타입은 매우 큰 범위의 값, 즉 1001년부터 9999년까지의 값을 1초 단위로 저장할 수 있다. <strong>DATETIME</strong> 은 날짜와 시각을 YYYYMMDDHHMMSS` 포맷의 정수 값으로 묶는데, 시간대에는 영향을 받지 않는다. <strong>DATETIME</strong> 은 8 바이트의 저장 공간을 사용한다. </p><h4 id="TIMESTAMP"><a href="#TIMESTAMP" class="headerlink" title="TIMESTAMP"></a>TIMESTAMP</h4><p>이름이 암시하듯, <strong>TIMESTAMP</strong> 타입은 <strong>1970년 1월 1일 자정(그리니치 평균시)을 기준</strong>으로 몇초가 지났는지를 저장하며, Unix 타임스탬프와 동일하다. <strong>TIMESTAMP</strong> 는 저장 공간을 4 바이트만 사용하므로 값의 범위가 DATETIME 보다 훨씬 작고, 1970년부터 2038년 사이의 값만을 저장할 수 있다. MySQL 에서는 <code>FROM_UNIXTIME()</code>, UNIX_TIMESTAMP()` 같은 함수를 제공하는데 이 함수를 이용하면 Unix 타임스탬프를 날짜로 바꾸거나 그 날짜를 Unix 타임스탬프로 바꿀 수 있다.</p><p><strong>TIMESTAMP</strong> 에 출력되는 값은 시간대에 따라 다르다. MySQL 서버, 운영체제, 클라이언트 연결은 모두 시간대 설정이 있다. 또한 <strong>TIMESTAMP</strong> 에는 <strong>DATETIME</strong> 에는 없는 특별한 특성들이 있다. 기본적으로 <strong>TIMESTAMP</strong> 컬럼에 값을 지정하지 않은 채로 행을 추가하면 첫 번째 <strong>TIMESTAMP</strong> 컬럼에 현재 시각을 넣는다. 또, UPDATE 실행 시 <strong>TIMESTAMP</strong> 값을 명시적으로 할당하지 않고 실행하면 <strong>TIMESTAMP</strong> 컬럼의 값이 자동으로 업데이트 된다. (즉, <strong>TIMESTAMP</strong> 는 기본적으로 <code>NOT NULL</code>)</p><h3 id="5-비트-Bit-로-구성된-데이터-타입"><a href="#5-비트-Bit-로-구성된-데이터-타입" class="headerlink" title="5. 비트(Bit)로 구성된 데이터 타입"></a>5. 비트(Bit)로 구성된 데이터 타입</h3><p>대부분의 응용프로그램에선 <strong>Bit</strong> 타입을 쓰지 않는 편이 낫다. <strong>Bit</strong> 타입을 사용할 만한 응용프로그램의 예로는 권한을 저장하는 접근 제어 목록(ACL)이 있다. </p><h3 id="6-식별자-고르기"><a href="#6-식별자-고르기" class="headerlink" title="6. 식별자 고르기"></a>6. 식별자 고르기</h3><p>식별자(ID) 컬럼에 맞는 데이터 타입을 고르는 일은 매우 중요하다. 다른 컬럼에 비해 식별자 컬럼은 다른 값과 비교되거나 값을 조회하는데 사용되는 경우가 많다. 또한 다른 테이블에서 외부 키로 사용되기도 한다. 따라서 연관된 테이블 끼리는 같은 데이터 타입을 쓰는 편이 좋다. <code>UNSIGNED</code> 과 같은 특성까지 타입이 정확히 일치해야 한다. </p><p>동일하지 않은 데이터 타입을 섞어 쓸 경우 성능 문제가 발생할 수 있고, 성능상의 문제가 없더라도 값을 비교할 경우 암시적으로 형변환을 하기 때문에 찾기 힘든 오류가 발생할 수 있다. 이런 문제는 느닷없이 나타나게 되는데 이 때쯤에는 다른 데이터 타입끼리 비교한다는 사실조차 잊어버리고 있을 것이다.</p><h4 id="정수-타입"><a href="#정수-타입" class="headerlink" title="정수 타입"></a>정수 타입</h4><p>빠른데다 <code>AUTO_INCREMENT</code> 도 잘 동작하므로 대체로 식별자에는 정수를 사용하는 것이 가장 좋다.</p><h4 id="ENUM-과-SET"><a href="#ENUM-과-SET" class="headerlink" title="ENUM 과 SET"></a>ENUM 과 SET</h4><p>식별자로는 적합하지 않다. </p><h4 id="문자열-타입"><a href="#문자열-타입" class="headerlink" title="문자열 타입"></a>문자열 타입</h4><p>되도록 식별자에는 문자열 타입을 쓰지 말자. 문자열 타입은 공간을 많이 차지하며, 보통 정수 타입보다 느리다. <code>MyISAM</code> 테이블에서 문자열 식별자를 사용할 땐 특히나 주의해야 한다. 기본적으로 <code>MyISAM</code> 은 문자열에 압축된 인덱스를 사용하는데 이로 인해 조회가 굉장히 느리다. <code>MD5()</code>, <code>SHA1()</code>, <code>UUID()</code> 로 만든 문자열처럼 완전히 ‘무작위’ 인 문자열을 사용할 경우에도 매우 신중해야 한다. 이런 함수로 만들어진 값들은 방대한 영역에 걸쳐 무작위로 분산되는데 이로 인해 INSERT 나 특정 타입의 SELECT 쿼리가 느려질 수 있다. </p><ul><li>무작위 문자열은, 삽입되는 값이 임의 위치의 인덱스로 가야 하기 때문에 INSERT 쿼리를 느리게 만들며, 클러스터 스토리지 엔진에 대해 페이지 분할, 임의 디스크 접근, 클러스터 인덱스 단편화 등을 일으킨다.</li><li>무작위 문자열은 논리적으로 가까운 행들이 디스크와 메모리 상에선 넓게 퍼져 있게 만들기 때문에 SELECT 쿼리를 느리게 한다.</li><li>무작위 값은 참조되는 값들이 모여 있지 못하게 만들며, 캐시는 참조되는 값들이 모여 있어야 효과를 낼 수 있으므로 무작위 값은 모든 타입의 쿼리에 대해 캐시 성능을 떨어뜨린다. 데이터 집합이 전부 접근 빈도가 비슷하다면, 데이터 일부를 메모리에 캐시하는 정도론 큰 이득을 얻을 수 없다. 그리고 작업 집합(워킹셋)이 메모리에 통째로 들어가지 못할 정도로 크면 캐시 미스와 플러시가 엄청나게 일어날 것이다. </li></ul><p>UUID 값을 저장한다면 대시 기호를 제거한 후 <code>UNHEX()</code> 함수를 써서 UUID 값을 16바이트짜리 숫자로 변환한 다음 <code>BINARY(16)</code> 컬럼에 저장하는 것이 좋다. 그렇게 저장한 값은 <code>HEX()</code> 함수를 써서 16진수 포맷으로 찾아내면 된다. </p><h2 id="인덱싱-기초"><a href="#인덱싱-기초" class="headerlink" title="인덱싱 기초"></a>인덱싱 기초</h2><p>인덱스는 MySQL 이 데이터를 효율적으로 조회할 수 있도록 돕는 데이터 구조다. 인덱스는 테이블에서 지정된 하나 이상의 컬럼 값을 포함하고 있다. 두 개 이상의 컬럼을 묶어 인덱스로 만들 땐 컬럼의 순서가 매우 중요하다. MySQL 은 인덱스의 최좌측 프리픽스에 대해서만 효율적으로 검색할 수 있기 때문이다. </p><h3 id="인덱스의-종류"><a href="#인덱스의-종류" class="headerlink" title="인덱스의 종류"></a>인덱스의 종류</h3><p>인덱스의 종류는 많으며, 각 인덱스는 서로 다른 용도로 작동하도록 설계되어 있다. 인덱스는 서버 계층이 아닌 스토리지 엔진 계층에서 구현되므로 표준화되어 있지 않다. </p><h4 id="1-B-트리-인덱스"><a href="#1-B-트리-인덱스" class="headerlink" title="1. B-트리 인덱스"></a>1. B-트리 인덱스</h4><p>스토리지 엔진은 B-트리 인덱스를 다양한 방식으로 디스크에 저장하는데, 저장 방식에 따라 성능 차이가 크다. 예를 들어, <code>MyISAM</code> 의 경우 인덱스를 작게 만드는 프리픽스 압축 기법을 쓰는데, 압축된 인덱스로는 최적화를 일부 적용할 수 없으므로 <code>InnoDB</code> 에서는 인덱스를 압축하지 않고 놔둔다.</p><p>B-트리는 모든 값을 순서대로 저장하며, 각 리프 페이지는 루트에서 같은 거리만큼 떨어져 있다. B-트리 인덱스를 사용하면 스토리지 엔진에서 원하는 데이터를 찾기 위해 테이블 전체를 뒤지지 않아도 되므로 데이터의 접근 속도가 빨라진다. </p><p>B-트리 인덱스는 루트 노드에서 시작한다. 루트 노드의 슬롯은 자식 노드를 가리키는 포인터를 보관하며, 스토리지 엔진은 이 포인터를 따라간다. 스토리지 엔진은 노드 페이지 안의 값을 살펴본 뒤 올바른 포인터를 찾아가는데, 이 값에는 자식 노드의 상한값과 하한값이 정의되어 있다. </p><p>결국 스토리지 엔진은 리프 페이지에 성공적으로 도달하거나 원하는 값이 존재하지 않는다고 판단하게 된다. (리프 페이지는 다른 페이지에 대한 포인터가 아닌 인덱스된 데이터에 대한 포인터를 가지므로 특별하다.)</p><p>B-트리는 인덱스된 컬럼을 순서대로 저장하기 때문에 데이터의 특정 범위를 검색할 때 유용하다. B-트리 인덱스를 사용할 수 있는 쿼리의 유형은 다음과 같다. (예시 인덱스는 성, 이름, 생일 순으로 생성된 인덱스가 있다)</p><ul><li>값 전부와 일치하는 경우</li><li>가장 왼쪽 프리픽스와 일치하는 경우: 성이 동일한 것을 찾을 때</li><li>컬럼 프리픽스와 일치하는 경우: 성이 J 로 시작할 때</li><li>일정 범위의 값과 일치하는 경우: 성이 A 와 C 인 사이의 사람을 찾을 때 </li><li>한 부분과 정확히 일치하고 다른 부분에서는 일정 범위의 값과 일치하는 경우: 성이 일치하고 이름이 A~K 범위일 때</li><li>인덱스에만 쿼리하기: 커버링 인덱스를 말한다. </li></ul><p>B-트리 인덱스에는 다음과 같은 제약이 있다. </p><ul><li>인덱스된 컬럼 중 가장 좌측에 있는 것부터 조회하지 않는 경우 인덱스는 쓸모가 없다</li><li>인덱스의 컬럼을 건너뛰지는 못한다: 성이 Smith 이면서 특정 날짜에 태어난 사람은 인덱스 사용 불가</li></ul><h4 id="2-해시-인덱스"><a href="#2-해시-인덱스" class="headerlink" title="2. 해시 인덱스"></a>2. 해시 인덱스</h4><p>해시 인덱스는 해시 테이블 기반이며, 인덱스를 구성하는 모든 컬럼을 이용하는 경우에만 유용하다. 스토리지 엔진은 각 행마다 인덱스된 컬럼의 해시 코드를 계산하는데, 이 해시 코드는 작은 값을 가진다. 그리고 키 값이 다른 행이라면 해시 코드 값이 달라지게 된다. 스토리지 엔진은 해시 코드를 인덱스에 저장하며, 각 행을 가리키는 포인터는 해시 테이블에 저장된다.</p><p>(그런데 큰 의미는 없는 것이) MySQL 에서 해시 인덱스는 Memory 스토리지 엔진에서만 지원하고 있다.</p><p><code>InnoDB</code> 스토리지 엔진은 어뎁티브 해시 인덱스라는 특별한 기능이 있다. <code>InnoDB</code> 는 매우 자주 접근하는 인덱스 값이 있다는 것을 알게 될 경우 B-트리 인덱스 위에 메모리 해시 인덱스를 만든다. 이로 인해 매우 빠른 해시된 조회 등 해시 인덱스의 특성을 B-트리 인덱스에 일부 부여할 수 있게 된다. 허나 이런 과정은 모두 자동으로 이루어지며 사용자가 제어하거나 설정하지는 못한다.</p><p>스토리지 엔진이 해시 인덱스를 지원하지 않으면 스스로 <code>InnoDB</code> 와 비슷한 방식으로 해시 인덱스를 흉내내면 된다. 이렇게 하면 키가 아주 길어도 인덱스 크기는 매우 작은 것 같은 해시 인덱스의 특성을 누리게 된다.</p><p>이런 접근법이 유효한 사례로는 URL 조회가 있다. URL 은 일반적으로 B-트리 인덱스를 커지게 하는데 이는 URL 이 아주 길기 때문이다. 보통 이런 식으로 쿼리를 날리게 된다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> url <span class="keyword">WHERE</span> url <span class="operator">=</span> <span class="string">&#x27;http://www.mysql.com&#x27;</span>;</span><br></pre></td></tr></table></figure><p>하지만 url 컬럼의 인덱스를 제거하고 인덱스된 url_crc 컬럼을 테이블에 추가하면 이렇게 쿼리를 사용할 수 있다. </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> url <span class="keyword">WHERE</span> url <span class="operator">=</span> <span class="string">&#x27;http://www.mysql.com&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> url_crc<span class="operator">=</span>CRC32(&quot;http://www.mysql.com&quot;);</span><br></pre></td></tr></table></figure><p>이 쿼리는 잘 동작하는데 MySQL 쿼리 옵티마이저가 url_crc 컬럼에 대한 작고 선택도가 매우 높은 인덱스가 있다는 것을 알고 해당 값(이 경우엔 1560514994)을 가진 엔트리를 인덱스 조회하기 때문이다. </p><p>예닐곱 개의 행이 똑같은 url_crc 값을 갖더라도 정수 비교가 빠르므로 해당 url_crc 값을 가진 행들을 찾아내고 검사하여 전체 URL 값이 정확히 일치하는 행을 찾기는 아주 쉽다. URL 을 전체 인덱스 하는 것에 비하면 훨씬 빠르다.</p><p>이 방식의 한 가지 약점은 해시 값을 유지해야 한다는 것이다. 스스로 해도 되고 아니면 MySQL 5.0 이상에선 트리거를 사용하면 된다. 또한 해시 충돌 가능성을 항상 생각하여 WHERE 조건에 해시 값 뿐만 아니라 원본 값도 항상 포함하여 조회해야 한다. </p><h4 id="3-공간-R-트리-인덱스"><a href="#3-공간-R-트리-인덱스" class="headerlink" title="3. 공간(R 트리) 인덱스"></a>3. 공간(R 트리) 인덱스</h4><p>생략</p><h4 id="4-전문-인덱스"><a href="#4-전문-인덱스" class="headerlink" title="4. 전문 인덱스"></a>4. 전문 인덱스</h4><p>생략</p><h3 id="고성능을-위한-인덱싱-전략"><a href="#고성능을-위한-인덱싱-전략" class="headerlink" title="고성능을 위한 인덱싱 전략"></a>고성능을 위한 인덱싱 전략</h3><h4 id="전략1-컬럼을-격리시키기"><a href="#전략1-컬럼을-격리시키기" class="headerlink" title="전략1. 컬럼을 격리시키기"></a>전략1. 컬럼을 격리시키기</h4><p>MySQL 은 일반적으로 쿼리의 컬럼이 격리되지 않으면 인덱스를 활용하지 못한다. 컬럼을 ‘고립시킨다’ 함은 그 컬럼이 표현식의 일부여선 안 되고 쿼리의 함수 내부에 있어서도 안 된다는 뜻이다.</p><p>예를 들어 actor_id 컬럼의 인덱스를 활용하지 못하는 쿼리를 살펴보자.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><br/><p> 비슷한 예시를 다시 보자</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">WHERE</span> TO_DAYS(<span class="built_in">CURRENT_DATE</span>) <span class="operator">-</span> TO_DAYS(date_col) <span class="operator">&lt;=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><br/><p>이 쿼리는 date_col 의 값을 보고 10일이 지나지 않은 행을 모두 찾지만 <code>TO_DAYS()</code> 함수 떄문에 인덱스를 활용하지 못한다. 이런 쿼리를 짜는 더 나은 방법을 보자.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">WHERE</span> date_col <span class="operator">&gt;=</span> DATE_SUB(<span class="built_in">CURRENT_DATE</span>, <span class="type">INTERVAL</span> <span class="number">10</span> <span class="keyword">DAY</span>);</span><br></pre></td></tr></table></figure><br/><p>이 쿼리는 인덱스를 활용하는 데 아무런 문제가 없지만 다른 방식으로 개선할 여지가 있다. <code>CURRENT_DATE</code> 에 대한 참조 때문에 쿼리 캐시가 결과를 캐싱하지 못한다. <code>CURRENT_DATE</code> 를 리터럴로 바꾸면 이 문제를 고칠 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">WHERE</span> date_col <span class="operator">&gt;=</span> DATE_SUB(<span class="string">&#x27;2018-04-15&#x27;</span>, <span class="type">INTERVAL</span> <span class="number">10</span> <span class="keyword">DAY</span>);</span><br></pre></td></tr></table></figure><br/><h4 id="전략2-프리픽스-인덱스와-인덱스-선택도"><a href="#전략2-프리픽스-인덱스와-인덱스-선택도" class="headerlink" title="전략2. 프리픽스 인덱스와 인덱스 선택도"></a>전략2. 프리픽스 인덱스와 인덱스 선택도</h4><p>아주 긴 문자열 컬럼, 그러니까 인덱스가 크고 느려지는 원인이 되는 컬럼을 인덱싱해야 할 때도 있다. 이 때, 값 전체가 아닌 첫 문자 몇 개만 인덱싱함으로써 공간을 절약하고 더 나은 성능을 얻을 때도 있다. 이렇게 하면 인덱스가 공간을 덜 쓰지만 선택도가 낮아지기도 한다. </p><p>인덱스 선택도는 테이블에 든 행의 개수(#T) 대비 다른 것과 구별되는 인덱스 값의 개수(카디널리티)이며 1 / #T 와 1 사이의 값이다. 선택도가 높은 인덱스가 좋은데 이런 인덱스는 MySQL 이 일치하는 값을 찾을 때 더 많은 행을 필터링 해주기 때문이다. 유니크 인덱스는 선택도가 1이고 그만큼 좋다.</p><p><strong>BLOB</strong>, <strong>TEXT</strong> 컬럼이나 아주 긴 <strong>VARCHAR</strong> 컬럼을 인덱싱한다면 프리픽스 인덱스를 정의해야 한다. MySQL 은 그런 컬럼을 몽땅 인덱싱하도록 허용하지 않기 때문이다.</p><p>중요한 건 선택도를 충분히 확보할 정도로 길지만 공간을 절약할 만큼은 짧은 프리픽스를 선택하는 일이다. 프리픽스는 컬럼 전체를 인덱싱한 것과 거의 유사한 정도의 선택도가 나올만큼 충분히 길어야 한다. 달리 말해 프리픽스의 카디널리티가 컬럼 전체의 카디널리티에 근접한 편이 좋다.</p><p>알맞은 프리픽스 길이를 계산하는 다른 방법은 전체 컬럼의 선택도를 계산한 후 프리픽스의 선택도가 그 값에 가까워지게 만드는 것이다. 전체 컬럼의 선택도를 알아내는 방법은 이렇다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(DICTINCT city) <span class="operator">/</span> <span class="built_in">COUNT</span>(x) <span class="keyword">FROM</span> sakila.city_demo;</span><br></pre></td></tr></table></figure><p>예시 결과가 0.0312 라고 가정해보자  </p><p>목표 선택도를 0.031 정도로 잡으면 프리픽스는 평균적으로 만족스러울 것이다. 쿼리 하나로 다양한 길이를 평가하는 것도 가능한데 이는 테이블이 아주 클 때 유용하다. </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">   <span class="built_in">COUNT</span>(DICTINCT <span class="keyword">LEFT</span>(city, <span class="number">3</span>) <span class="operator">/</span> <span class="built_in">COUNT</span>(x) <span class="keyword">AS</span> sel3,</span><br><span class="line">   <span class="built_in">COUNT</span>(DICTINCT <span class="keyword">LEFT</span>(city, <span class="number">4</span>) <span class="operator">/</span> <span class="built_in">COUNT</span>(x) <span class="keyword">AS</span> sel4,</span><br><span class="line">   <span class="built_in">COUNT</span>(DICTINCT <span class="keyword">LEFT</span>(city, <span class="number">5</span>) <span class="operator">/</span> <span class="built_in">COUNT</span>(x) <span class="keyword">AS</span> sel5,</span><br><span class="line">   <span class="built_in">COUNT</span>(DICTINCT <span class="keyword">LEFT</span>(city, <span class="number">6</span>) <span class="operator">/</span> <span class="built_in">COUNT</span>(x) <span class="keyword">AS</span> sel6,</span><br><span class="line">   <span class="built_in">COUNT</span>(DICTINCT <span class="keyword">LEFT</span>(city, <span class="number">7</span>) <span class="operator">/</span> <span class="built_in">COUNT</span>(x) <span class="keyword">AS</span> sel7</span><br><span class="line"><span class="keyword">FROM</span> sakila.city_demo;</span><br><span class="line"></span><br><span class="line">sel3: <span class="number">0.0238</span></span><br><span class="line">sel4: <span class="number">0.0293</span></span><br><span class="line">sel5: <span class="number">0.0305</span></span><br><span class="line">sel6: <span class="number">0.0309</span></span><br><span class="line">sel7: <span class="number">0.0310</span></span><br></pre></td></tr></table></figure><p>이 쿼리는 일곱 글자에 가까워지면서 프리픽스의 길이 증가가 조금씩 선택도를 개선시킴을 보여준다. </p><p>평균 선택도만 바라보는 건 좋은 생각이 아니다. 최악의 선택도에 대해서도 생각해야 한다. 데이터가 고르지 못하다면 그런 생각이 함정이 될 수 있다.</p><p>이제 예제 데이터에서 알맞은 값을 찾았으니 컬럼에 대한 프리픽스 인덱스를 생성하는 법을 알아보자</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sakila.city_demo <span class="keyword">ADD</span> KEY (city(<span class="number">7</span>));</span><br></pre></td></tr></table></figure><p>프리픽스 인덱스의 단점이라면 MySQL 은 프리픽스 인덱스를 ORDER BY 또는 GROUP BY 쿼리에 활용하지도 커버링 인덱스로 활용하지도 못한다.<br><br/></p><h4 id="전략3-클러스터링-인덱스"><a href="#전략3-클러스터링-인덱스" class="headerlink" title="전략3. 클러스터링 인덱스"></a>전략3. 클러스터링 인덱스</h4><p>테이블에 클러스터 인덱스가 있으면 그 테이블의 행들은 실제로 인덱스의 리프 페이지에 저장된다. ‘클러스터된’ 이란 용어는 인접된 키 값을 가지는 레코드들이 서로 가까운 데 저장된다는 사실을 가리킨다. 테이블 하나는 클러스터링 인덱스 하나만 가질 수 있는데 행들을 동시에 두 곳에 저장할 수는 없기 때문이다. 하나의 열에 Primary Key를 지정하면 자동으로 클러스터형 인덱스가 생성된다. </p><p><code>InnoDB</code> 에서 클러스터 인덱스는 테이블 ‘그 자체’다. 클러스터 인덱스의 각 리프 노드에는 기본 키 값, `InnoDB 가 트랜잭션이나 MVCC 목적으로 사용하는 트랜잭션 아이디와 롤백 포인터, 그리고 나머지 컬럼이 들어 있다. </p><br/><h4 id="전략4-InnoDB-에서-기본-키-순서대로-행을-삽입하기"><a href="#전략4-InnoDB-에서-기본-키-순서대로-행을-삽입하기" class="headerlink" title="전략4. InnoDB 에서 기본 키 순서대로 행을 삽입하기"></a>전략4. InnoDB 에서 기본 키 순서대로 행을 삽입하기</h4><p><code>InnoDB</code> 를 사용하고 특별히 클러스터링이 필요치 않다면, 인조 키(surrogate key)를 정의하는 것도 좋은 생각이다. 인조 키는 응용프로그램에서 파생되지 않은 값을 기본 키로 삼는다. 인조 키를 정의하는 제일 쉬운 방법은 보통 <code>AUTO_INCREMENT</code> 컬럼을 이용하는 것이다. 이렇게 하면 행이 순차적으로 삽입되고, 기본 키를 사용해 조인할 때 성능이 나아진다.</p><p>무작위(순차적이지 않은) 클러스터 키는 피하는 게 상책이다. 예를 들어 UUID 값은 성능이란 관점에서 보면 좋지 않은 선택이다. UUID 는 클러스터 인덱스가 무작위로 삽입되게 만드는 데 이는 최악의 시나리오이고 쓸만한 데이터 클러스터링을 전혀 제공하지 않는다. UUID 를 insert 할 때, 새 행이 이전 행보다 꼭 기본 키 값이 더 크다는 보장이 없기 때문에 <code>InnoDB</code> 는 항상 인덱스 끝에 새 행을 놓지는 못한다. 이 이야기의 교훈은 <code>InnoDB</code> 를 쓸 땐 기본 키 순서에 따라 데이터를 삽입하려고 애써야 하고, 또한 새 행마다 값이 단조롭게 증가하는 클러스터 키를 사용하려 노력해야 한다는 것이다. </p><br/><h4 id="전략5-커버링-인덱스"><a href="#전략5-커버링-인덱스" class="headerlink" title="전략5. 커버링 인덱스"></a>전략5. 커버링 인덱스</h4><p>인덱스의 리프 노드엔 자기가 인덱스한 값이 있다. 만약 인덱스를 읽어서 자신이 원하는 데이터를 얻을 수 있다면 행을 뭐하러 읽겠는가? 쿼리를 만족시키기 위해 필요한 데이터가 모두 포함된 인덱스를 커버링 인덱스라고 한다. 데이터가 아닌 인덱스만 읽을 때의 장점은 아래와 같다</p><ul><li>인덱스 엔트리는 보통 행의 전체 크기보다 훨씬 작다</li><li>인덱스는 인덱스 값이 따라 정렬되기 때문에, I/O 바운드 범위 질의는 디스크상의 무작위 위치에서 행을 하나씩 가져오는 것에 비해 I/O 가 적게 들 것이다. </li><li>대부분의 스토리지 엔진은 데이터보다 인덱스를 캐싱하는 데 능하다. </li><li>커버링 인덱스는 특히 <code>InnoDB</code> 테이블에 도움이 되는데 <code>InnoDB</code> 의 클러스터 인덱스 때문이다. <code>InnoDB</code> 의 보조 인덱스는 행의 기본 키 값을 리프 노드에 담는다. 그래서 쿼리에 필요한 컬럼을 모두 갖는 보조 인덱스는 기본 키까지 들여보지 않는다. 보통 <code>EXPLAIN</code> 으로 쿼리를 확인했을 때 Extra: Using Index 를 보게 된다면 커버링 인덱스를 활용하고 있는 것이다.</li></ul><p>대부분의 스토리지 엔진에서 인덱스는 인덱스에 포함된 컬럼에 접근하는 쿼리만 커버할 수 있다. 하지만 <code>InnoDB</code> 는 조금 더 최적화를 한다. <code>InnoDB</code> 의 보조 인덱스는 기본 키 값을 자신의 리프 노드에 간직하고 있다. 이는 보조 인덱스가 <code>InnoDB</code> 가 쿼리를 커버하는 용도로 쓸 수 있는 ‘추가 컬럼’ 을 사실상 갖게 된다는 뜻이다. </p><p>예를 들어 sakila.actor 테이블은 <code>InnoDB</code> 를 쓰고 last_name 컬럼에 인덱스가 있다. 그러니 인덱스는 기본 키 칼럼인 actor_id 를 인출하는 쿼리를 커버할 수 있다. 그 기본 키 컬럼이 인덱스의 일부가 아니라도 말이다. </p><br/><h4 id="전략6-중첩-또는-중복된-인덱스"><a href="#전략6-중첩-또는-중복된-인덱스" class="headerlink" title="전략6. 중첩 또는 중복된 인덱스"></a>전략6. 중첩 또는 중복된 인덱스</h4><p>중복 인덱스는 똑같은 컬럼 집합을 똑같은 순서로 배열해 생성한 같은 유형의 인덱스를 말한다. 이런 인덱스는 만들지 않도록 조심하고, 이런 인덱스를 발견한 경우에는 제거해야 한다. </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test (</span><br><span class="line">ID <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line"><span class="keyword">UNIQUE</span>(ID),</span><br><span class="line">INDEX(ID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>MySQL 은 인덱스를 이용해 고유 제약조건과 기본 키 제약조건을 구현하기 떄문에 위의 코드는 같은 컬럼에 세 개의 인덱스를 생성하고 만다!</p><p>중첩된 인덱스는 중복 인덱스와 약간 다르다. (A,B) 에 대한 인덱스가 있다면 이 인덱스의 프리픽스는 (A) 이므로 (A) 에 대한 인덱스는 중첩된 것이다. 이 때는 (A,B) 인덱스를 (A) 하나 짜리 인덱스 대신 쓰면 된다. 대부분의 경우 중첩 인덱스는 만들지 않는 것이 좋으며, 중첩 인덱스를 만들지 않으려면 새 인덱스를 추가하기보다는 기존 인덱스를 확장하는 것이 좋다. </p><p>하지만 기존 인덱스를 확장할 경우 인덱스가 커지게 되고 그러다 보면 어떤 쿼리에선 성능이 저하될 수 있으므로 성능을 이유로 중첩된 인덱스를 사용해야 할 때도 있다.</p><h3 id="인덱싱-사례-연구"><a href="#인덱싱-사례-연구" class="headerlink" title="인덱싱 사례 연구"></a>인덱싱 사례 연구</h3><p>인덱스를 설계하기 위해선 희한하게도 인덱스 기반의 정렬을 써야 하는지, 파일 정렬을 써도 될지부터 결정해야 한다. 인덱스 기반의 정렬은 인덱스와 쿼리를 어떻게 형성해야 할지를 제한한다. 예를 들어, 어떤 쿼리가 인덱스를 이용해 다른 사용자가 준 점수에 따라 사용자들을 정렬하는 경우, WHERE age BETWEEN 18 ANd 25 와 같은 WHERE 절에 인덱스를 쓰지 못한다. MySQL 에서는 쿼리가 범위 제한을 위해 인덱스를 이용하는 경우, 정렬용으로 다른 인덱스를 쓰지 못하기 때문이다. 이런 WHERE 절이 가장 흔히 쓰이는 WHERE 절이라면, 파일 정렬이 필요한 쿼리가 많으리라는 것은 당연한 사실이다. </p><br/><h4 id="여러-종류의-필터링-지원하기"><a href="#여러-종류의-필터링-지원하기" class="headerlink" title="여러 종류의 필터링 지원하기"></a>여러 종류의 필터링 지원하기</h4><p>country 컬럼은 선택도가 높을 수도 있고 낮을 수도 있다. 어쨌거나 이 컬럼은 대부분의 쿼리에 쓰일 것이다. sex 컬럼은 선택도가 낮은 게 분명하지만 그럼에도 거의 모든 쿼리에서 사용될 것이다. 이를 염두해서 (sex, country) 가 앞에 오는 컬럼 조합들에 쓸 인덱스를 생성하자. 상식적으로는 선택도가 매우 낮은 컬럼을 인덱싱해봐야 소용없는데 선택도가 낮은 컬럼을 인덱스의 시작으로 하는 이유가 있을까?</p><p>이렇게 하는 이유는 두 가지다. 하나는 거의 모든 쿼리가 sex 컬럼을 사용하고 있기 때문이고, 두 번째는 나름의 트릭이 있기 때문에 컬럼을 추가하더라도 그리 불리할 게 없기 떄문이다.</p><p>트릭이지만, 성별로 결과를 제한하지 않는 쿼리를 던졌더라도 AND sex IN (‘m’, ‘f’) 를 WHERE 절에 넣으면 인덱스를 사용하게 만들 수 있다. 이렇게 하면 어떤 행도 가려내지 않으므로 WHERE 절에 sex 컬럼을 포함시키지 않는 것과 기능적으로 동일하게 동작한다. 하지만 이렇게 하면 MySQL 이 인덱스에서 이 컬럼을 포함하는 더 긴 프리픽스를 사용하게 만든다.</p><p>다음으로 WHERE 조건에 어떤 조합이 쓰이게 될지, 그리고 어떤 조합이 적절한 인덱스 없이는 느리게 동작할지를 생각해보자. (sex, country, age), (sex, country, region, age), (sex, country, region, city, age) 등등의 인덱스가 필요할 것 같다. 여기서 IN 트릭을 활용하면 (sex, country, age), (sex, country, region, age) 인덱스는 폐기가 가능하다. 마지막 인덱스로 자주 사용될 쿼리의 커버가 가능하다는 뜻… </p><p>하지만 덜 흔한 컬럼에도 맞도록 인덱스를 설계하려면 어떻게 할까? 이런 컬럼들은 선택도가 극히 낮고, 자주 사용되지 않는다면, 인덱스를 만들지 말고 MySQL 에서 행을 몇 개 더 스캔하도록 놔두면 된다.</p><p>그런데 age 컬럼은 계속해서 인덱스의 끝에 두고 있음을 알 수 있다. MySQL 은 처음으로 범위 조건을 지정한 컬럼 및 그보다 왼쪽에 있는 컬럼만 인덱스에서 쓸 수 있으므로 MySQL 이 인덱스의 컬럼을 최대한 많이 이용할 수 있도록 만들려고 하는 것이다. 여태까지 언급한 다른 컬럼들은 모두 WHERE 절에 동일성 조건을 이용할 수 있다. 하지만 age는 범위 조건으로 쓰일게 분명하다. 인덱스의 일반 원칙은 인덱스 끝에 범위 조건을 주라는 것이다. 그러면 옵티마이저에서 최대한 많은 부분의 인덱스를 활용할 수 있다. </p><br/><h4 id="다수의-범위-조건-피하기"><a href="#다수의-범위-조건-피하기" class="headerlink" title="다수의 범위 조건 피하기"></a>다수의 범위 조건 피하기</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test </span><br><span class="line"><span class="keyword">WHERE</span> eye_color <span class="keyword">IN</span> (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">  <span class="keyword">AND</span> hair_color <span class="keyword">IN</span> (<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">  <span class="keyword">AND</span> last_online <span class="operator">&gt;</span> DATE_SUB(<span class="string">&#x27;2018-01-07&#x27;</span>, <span class="type">INTERVAL</span> <span class="number">7</span> <span class="keyword">DAY</span>)</span><br><span class="line">  <span class="keyword">AND</span> age <span class="keyword">BETWEEN</span> <span class="number">18</span> <span class="keyword">AND</span> <span class="number">25</span></span><br></pre></td></tr></table></figure><p>MySQL 에서는 last_online 기준의 인덱스와 age 기준의 인덱스 중 하나를 쓸 수 있지만 두 인덱스를 함께 사용할 순 없다. age 제한 없이 last_online 제한만 있거나 last_online 이 age 보다 선택도가 높으면, last_online 을 끝에 두는 인덱스 집합을 하나 더 추가하면 된다. </p><br/><h4 id="정렬-최적화하기"><a href="#정렬-최적화하기" class="headerlink" title="정렬 최적화하기"></a>정렬 최적화하기</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> columns <span class="keyword">FROM</span> profiles <span class="keyword">WHERE</span> sex <span class="operator">=</span> <span class="string">&#x27;M&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> rating LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>이 쿼리엔 WHERE 와 ORDER BY 가 모두 있는데 (sex, rating) 인덱스가 없다면 매우 느릴 것이다. </p><br/><h4 id="캐시-및-집계-테이블"><a href="#캐시-및-집계-테이블" class="headerlink" title="캐시 및 집계 테이블"></a>캐시 및 집계 테이블</h4><p>떄로는 추출 값 (연산을 통해 계산된 값)을 테이블에 중복 저장해두는 것이 성능을 향상시키는 최선의 방법일 때가 있다. 하지만 캐시 테이블이나 집계 테이블 등을 따로 구축해야 할 때도 있다. 이런 방식은 다소간의 정확하지 않은 데이터를 묵인할 수 있는 경우 최선의 방법이며, 가끔 이 방법 외에는 선택권이 없는 경우도 있다. (여기서 캐시 테이블은 논리적으로 중복이지만 인출해내기 쉬운 데이터를 담은 테이블을 말하고, 집계 테이블은 GROUP BY 쿼리에서 얻은 집합적인 데이터를 담은 테이블을 뜻한다)</p><p>웹 사이트에서 지난 24시간 동안 새 글이 얼마나 올라왔는지 세어야 한다고 해보자. 사람 많은 사이트에서는 실시간 카운터를 정확히 유지하기란 불가능하다. 그 대신 매 시간마다 집계 테이블을 생성하는 방법을 사용할 수 있다.</p><p>이제 캐시 테이블을 살펴보자. 캐시 테이블은 값을 가져오는 쿼리나 검색 쿼리를 최적화할 때 유용하다. 다양한 형식의 쿼리들을 빠르게 만들기 위해 여러 개의 인덱스 조합이 필요하게 될 수도 있는데, 각 요구사항마다의 충돌이 발생할 수 있어서 주 테이블의 몇몇 컬럼을 캐시해둔 캐시 테이블을 생성해야 할 때도 있다. 이 때 사용할 수 있는 유용한 기법 중 하나는 캐시 테이블에는 주 테이블과 다른 스토리지 엔진을 쓰는 것이다. 예를 들어, 주 테이블로 InnoDB 를 쓸 경우 캐시 테이블엔 MyISAM 을 쓰게 되면 인덱스 크기를 줄일 수 있는데다 쿼리에 전문 검색까지 사용할 수 있게 되는 장점이 있다. 때로는 검색을 더 효율적으로 할 수 있는 특화된 시스템(Lucene 이나 Sphinx 검색 엔진)으로 넣을 수도 있다. </p><br/><h4 id="카운터-테이블"><a href="#카운터-테이블" class="headerlink" title="카운터 테이블"></a>카운터 테이블</h4><p>테이블에 카운트 값을 유지하는 응용프로그램은 카운터를 동시에 갱신할 떄 동시성 문제를 겪을 수 있다. </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> hit_counter (</span><br><span class="line">cnt <span class="type">int</span> unsigned <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">) ENGING <span class="operator">=</span> InnoDB;</span><br></pre></td></tr></table></figure><p>웹 사이트 방문마다 카운터를 갱신한다</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE hit_counter <span class="keyword">SET</span> cnt <span class="operator">=</span> cnt <span class="operator">+</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>문제는 사실상 이 행 하나가 카운터를 갱신하는 트랜잭션들이 모두 공유하는 전역 ‘뮤텍스’라는 사실이다. 이 때문에 트랜잭션들은 일렬로 줄 세워진다. 행을 여러 개 두고 무작위로 갱신하면 좀 더 동시성을 높일 수 있으나, 이렇게 하려면 테이블을 다음과 같이 변경해야 한다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> hit_counter (</span><br><span class="line">slot tinyint unsigned <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key,</span><br><span class="line">cnt <span class="type">int</span> unsigned <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure><p>테이블에 행 100개를 채워넣자. 이제부터는 쿼리에서 무작위로 슬롯(slot)을 고른 뒤 값을 업데이트 할 수 있게 된다. </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE hit_counter <span class="keyword">SET</span> cnt <span class="operator">=</span> cnt <span class="operator">+</span> <span class="number">1</span> <span class="keyword">WHERE</span> slot <span class="operator">=</span> RAND() <span class="operator">*</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>이제 통계를 얻어오려면 단순히 집합 쿼리를 사용하기만 하면 된다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(cnt) <span class="keyword">FROM</span> hit_counter;</span><br></pre></td></tr></table></figure><p>일반적으로 필요한 기능으로 가끔식(예를 들어 하루애 한번) 카운터를 새로 시작하는 기능이 있다. 이런 기능이 필요한 경우라면 다음과 같이 스키마를 조금만 변경하면 된다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> hit_counter (</span><br><span class="line"><span class="keyword">day</span> <span class="type">date</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">slot tinyint unsigned <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">cnt <span class="type">int</span> unsigned <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line"><span class="keyword">primary</span> key(<span class="keyword">day</span>, slot)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure><p>이런 시나리오에선 행을 미리 생성해두는 대신 <code>ON DUPLICATE KEY UPDATE</code> 명령을 이용할 수 있다. </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> daily_hit_counter(<span class="keyword">day</span>, slot, cnt)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="built_in">CURRENT_DATE</span>, RAND() <span class="operator">*</span> <span class="number">100</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">ON</span> DUPLICATE KEY UPDATE cnt <span class="operator">=</span> cnt <span class="operator">+</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>행의 개수를 줄여서 테이블을 작게 유지하고 싶다면 모든 결과 값을 병합하여 슬롯 0에 넣은 뒤 나머지 슬롯은 지워주는 작업을 주기적으로 실행하면 된다. </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">UPDATE daily_hit_counter <span class="keyword">as</span> c</span><br><span class="line">  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> (</span><br><span class="line"> <span class="keyword">SELECT</span> <span class="keyword">day</span>, <span class="built_in">SUM</span>(cnt) <span class="keyword">AS</span> cnt, <span class="built_in">MIN</span>(slot) <span class="keyword">AS</span> mslot</span><br><span class="line">   <span class="keyword">FROM</span> daily_hit_counter</span><br><span class="line">   <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">day</span></span><br><span class="line">  ) <span class="keyword">AS</span> x <span class="keyword">USING</span>(<span class="keyword">day</span>)</span><br><span class="line"><span class="keyword">SET</span> c.cnt <span class="operator">=</span> IF(c.slot <span class="operator">=</span> x.mslot, x.cnt, <span class="number">0</span>)</span><br><span class="line">    c.slot <span class="operator">=</span> IF(c.slot <span class="operator">=</span> x.mslot, <span class="number">0</span>, c.slot);</span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> daily_hit_counter <span class="keyword">WHERE</span> slot <span class="operator">&lt;&gt;</span> <span class="number">0</span> <span class="keyword">AND</span> cnt <span class="operator">=</span> <span class="number">0</span>;    </span><br></pre></td></tr></table></figure><br/><h2 id="스토리지-엔진에-대해"><a href="#스토리지-엔진에-대해" class="headerlink" title="스토리지 엔진에 대해"></a>스토리지 엔진에 대해</h2><h3 id="InnoDB-스토리지-엔진의-특징"><a href="#InnoDB-스토리지-엔진의-특징" class="headerlink" title="InnoDB 스토리지 엔진의 특징"></a>InnoDB 스토리지 엔진의 특징</h3><h4 id="1-트랜잭션"><a href="#1-트랜잭션" class="headerlink" title="1. 트랜잭션"></a>1. 트랜잭션</h4><p>InnoDB 는 트랜잭션 및 네 단계의 트랜잭션 고립 수준들을 지원한다</p><h4 id="2-외래-키"><a href="#2-외래-키" class="headerlink" title="2. 외래 키"></a>2. 외래 키</h4><p>MySQL 5.0 에서 InnoDB 는 유일하게 외래 키를 지원하는 표준적인 스토리지 엔진이다. 다른 스토리지 엔진은 CREATE TABLE 문에서 외래 키 옵션을 명시할 수 있지만, 실질적으로 외래 키를 생성하진 않는다.</p><h4 id="3-행-수준-잠금"><a href="#3-행-수준-잠금" class="headerlink" title="3. 행 수준 잠금"></a>3. 행 수준 잠금</h4><p>잠금은 잠금 확장(Lock escalation) 없이, SELECT 를 블록하지 않으면서 행 수준에서 설정되는데, 표준인 논블로킹 SELECT 는 전혀 잠금을 하지 않으므로 동시성이 아주 좋아진다. </p><h4 id="4-다중-버전"><a href="#4-다중-버전" class="headerlink" title="4. 다중 버전"></a>4. 다중 버전</h4><p>InnoDB 는 다중 버전 동시성 제어(multiversion concurrency control)를 이용하므로 기본적으로 SELECT 시에는 예전 데이터를 읽게 된다. MVCC 아키텍처를 이용하면 굉장히 복잡도가 증가하기 떄문에 해당 내용을 명확히 알고 있어야 한다.</p><h4 id="5-기본-키에-따라-클러스터링-함"><a href="#5-기본-키에-따라-클러스터링-함" class="headerlink" title="5. 기본 키에 따라 클러스터링 함"></a>5. 기본 키에 따라 클러스터링 함</h4><p>InnoDB 테이블은 모두 기본 키에 따라 클러스터링되는데, 이를 잘 이용하면 스키마를 설계할 때 이득을 볼 수 있다. </p><h4 id="6-모든-인덱스에-기본-키-컬럼에-포함됨"><a href="#6-모든-인덱스에-기본-키-컬럼에-포함됨" class="headerlink" title="6. 모든 인덱스에 기본 키 컬럼에 포함됨"></a>6. 모든 인덱스에 기본 키 컬럼에 포함됨</h4><p>인덱스는 기본 키에 따라 행을 참조하므로 기본 키를 짧게 해두지 않으면 인덱스의 크기가 엄청나게 증가하게 된다.</p><h4 id="7-캐시가-최적화되어-있음"><a href="#7-캐시가-최적화되어-있음" class="headerlink" title="7. 캐시가 최적화되어 있음"></a>7. 캐시가 최적화되어 있음</h4><p>InnoDB 에서는 데이터와 메모리 모두를 버퍼 풀에 캐싱한다. 또한 해시 인덱스를 자동으로 구축해서 행을 빠르게 가져올 수 있도록 한다.</p><h4 id="8-인덱스를-압축하지-않음"><a href="#8-인덱스를-압축하지-않음" class="headerlink" title="8. 인덱스를 압축하지 않음"></a>8. 인덱스를 압축하지 않음</h4><p>프리픽스 압축을 이용해서 인덱스를 압축하지 않으므로 MyISAM 테이블용 인덱스보다 크기가 더 클 수 있다.</p><h4 id="9-데이터-적재가-느림"><a href="#9-데이터-적재가-느림" class="headerlink" title="9. 데이터 적재가 느림"></a>9. 데이터 적재가 느림</h4><p>MySQL 5.0 까지의 InnoDB 는 데이터 적재 연산을 특별히 최적화하지 않고 있다. 인덱스를 정렬 순서에 따라 구축하지 않고 한번에 한 행씩 구축한다. 그렇기 때문에 데이터 적재가 심각하게 느릴 수 있다. </p><h4 id="10-AUTO-INCREMENT-가-블로킹-연산임"><a href="#10-AUTO-INCREMENT-가-블로킹-연산임" class="headerlink" title="10. AUTO_INCREMENT 가 블로킹 연산임"></a>10. AUTO_INCREMENT 가 블로킹 연산임</h4><p>5.1 이전의 MySQL 에선 InnoDB 가 AUTO_INCREMENT 값을 새로 만들어낼 때마다 테이블 수준의 잠금을 사용한다</p><h4 id="11-COUNT-x-값이-캐시되지-않음"><a href="#11-COUNT-x-값이-캐시되지-않음" class="headerlink" title="11. COUNT(x) 값이 캐시되지 않음"></a>11. COUNT(x) 값이 캐시되지 않음</h4>]]></content:encoded>
      
      <comments>https://daniel-hebn.github.io/2018/04/14/2018-04-14-MySQL-%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%81%ED%99%94-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>MySQL 성능최적화 (2)</title>
      <link>https://daniel-hebn.github.io/2018/04/14/2018-04-14-MySQL-%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%81%ED%99%94-2/</link>
      <guid>https://daniel-hebn.github.io/2018/04/14/2018-04-14-MySQL-%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%81%ED%99%94-2/</guid>
      <pubDate>Sat, 14 Apr 2018 14:40:00 GMT</pubDate>
      <description>
      
        
        
          &lt;img src=&quot;/images/logo/MySQL_performance_tuning.png&quot;/&gt;&lt;h1 id=&quot;2장-병목-지점-찾기&quot;&gt;&lt;a href=&quot;#2장-병목-지점-찾기&quot; class=&quot;headerlink&quot; title=&quot;2장 병목 지점 찾기&quot;&gt;&lt;/a
        
      
      </description>
      
      
      <content:encoded><![CDATA[<img src="/images/logo/MySQL_performance_tuning.png"/><h1 id="2장-병목-지점-찾기"><a href="#2장-병목-지점-찾기" class="headerlink" title="2장 병목 지점 찾기"></a>2장 병목 지점 찾기</h1><h2 id="무엇을-측정할-것인가"><a href="#무엇을-측정할-것인가" class="headerlink" title="무엇을 측정할 것인가"></a>무엇을 측정할 것인가</h2><ul><li>단위 시간당 트랜잭션</li><li>반응 시간 또는 대기시간 </li><li>성능 확장성</li><li>동시성: 중요한 것은 주어진 시간 동안 쿼리를 실행하는 연결이 몇 개냐 되느냐다. 즉, 동시에 작업 중인 스레드나 연결의 개수를 뜻하는 유효 동시성이 중요하다. 동시성이 증가할 때 성능이 크게 떨어지지 않는지 측정해보자. <br/></li></ul><h2 id="MySQL-프로파일링"><a href="#MySQL-프로파일링" class="headerlink" title="MySQL 프로파일링"></a>MySQL 프로파일링</h2><h3 id="쿼리를-로그로-남기기"><a href="#쿼리를-로그로-남기기" class="headerlink" title="쿼리를 로그로 남기기"></a>쿼리를 로그로 남기기</h3><p>MySQL 에는 제네럴 로그와 슬로우 로그가 있다. 제네럴 로그는 서버가 쿼리를 받는 대로 모든 쿼리를 기록하므로 오류 때문에 실행되지 않은 쿼리도 기록된다. 그리고 연결이나 연결 끊기 같은 비 쿼리 이벤트까지 포함해 모든 쿼리를 기록한다. 구성 지시문 한 줄이면 이 기능을 활성화할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">log</span> = &lt;file_name&gt;</span><br></pre></td></tr></table></figure><p>반면에 슬로우 쿼리는 실행된 쿼리만 포함된다. 특히 지정된 시간보다 오래 걸린 쿼리를 로그로 남긴다. 아래의 구성 예제는 슬로우 쿼리를 활성화하여 2초 이상 걸린 쿼리를 모두 잡아내며 인덱스를 전혀 사용하지 않은 쿼리를 로그로 남긴다. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log-slow-queries = &lt;file_name&gt;</span><br><span class="line">long_query_time = 2</span><br><span class="line">log-queries-not-using-indexes</span><br><span class="line">log-slow-admin-statements</span><br></pre></td></tr></table></figure><p>인덱스를 쓰지 않더라도 쿼리 속도가 아주 빠르고 자주 실행되는 쿼리도 얼마든지 있을 수 있지만 <code>log-queries-not-using-indexes</code> 설정이 있으면 그런 쿼리를 모두 로그로 남기게 되고, 이는 성능 문제와 디스크 공간을 과하게 차지하는 문제가 발생하게 된다. 슬로우 로그를 사용해 느린 쿼리 문제를 해결하는 일이 항상 명확하진 않기 때문에 슬로우 쿼리를 너무 맹신하지는 말자. </p><ul><li>테이블이 잠겨서 쿼리가 대기해야 했을 수 있다. Lock_time 은 쿼리가 잠금이 풀리기를 얼마나 기다렸는지 알려준다.</li><li>데이터나 인덱스가 메모리에 캐싱되기 전일지 모른다. 이는 MySQL 이 처음 시작되었거나 아직 튜닝되지 않았을 때 흔하다.</li><li>야간 백업 과정이 진행 중으라 모든 디스크의 I/O 가 느려졌을지 모른다.</li><li>서버가 다른 쿼리를 동시에 실행해 이 쿼리가 느려진 것일지 모른다.</li></ul><h3 id="MySQL-서버-프로파일링"><a href="#MySQL-서버-프로파일링" class="headerlink" title="MySQL 서버 프로파일링"></a>MySQL 서버 프로파일링</h3><p>서버가 시간을 가장 많이 소모하는 작업이 무엇인지 알아내는 최고의 서버 프로파일링 방법 중 하나는 SHOW STATUS 를 사용하는 것이다. 이 때의 유용한 변수는 아래와 같다.</p><ul><li>Bytes_received 와 Bytes_sent: 서버와 주고 받은 트래픽</li><li>Com_* : 서버가 실행한 명령어</li><li>Created_* : 쿼리 실행 과정에서 만든 임시 테이블과 파일</li><li>Hanlder_* : 스토리지 엔진 연산</li><li>Select_* : 다양한 유형의 조인 실행 계획</li><li>Sort_* : 몇 가지 유형의 정렬 정보</li></ul><p>SHOW PROCESSLIST 를 사용하거나 SHOW STATUS 를 사용하면 프로파일링에 도움이 된다. (innotop 과 같은 도구를 쓰는 것도 편하다)</p><h3 id="운영체제-프로파일링"><a href="#운영체제-프로파일링" class="headerlink" title="운영체제 프로파일링"></a>운영체제 프로파일링</h3><p>네트워크 활동을 발견하고 기본적인 문제 해결을 찾는 예시를 살펴보자.<br>MySQL 의 SHOW PROCESSLIST 를 실행했을 때 아래와 같은 내용이 출력이 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Id: 91296</span><br><span class="line">User: Web</span><br><span class="line">Host: sargon.cluster3:37636</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>이제 netstat 을 통해 어느 프로세스가 포트 번호 37636 을 이용해 연결을 열었는지 알아낸다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@saragon<span class="comment"># netstat -ntp | grep :37676</span></span><br><span class="line"></span><br><span class="line">tcp 0 0 192,168,0,12:37636 192.168.0.21:3306 ESTABLISHED 16072/apache2</span><br></pre></td></tr></table></figure><p>프로세스 번호와 이름은 출력 결과의 마지막 부분에 나온다. 프로세스 16072 가 이 연결을 시작했고 이 연결은 Apache 웹 서버에서 왔다. 프로세스 ID 를 알았으면 더 나아가 프로세스가 가진 다른 네트워크 연결은 무엇인지 등 프로세스에 관한 그 밖의 정보를 많이 알아낼 수 있다. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@saragon<span class="comment"># netstat -ntp | grep 16072/apache2</span></span><br><span class="line"></span><br><span class="line">tcp 0 0 192,168,0,12:37636 192.168.0.21:3306 ESTABLISHED 16072/apache2</span><br><span class="line">tcp 0 0 192,168,0,12:37636 192.168.0.21:3306 ESTABLISHED 16072/apache2</span><br><span class="line">tcp 0 0 192,168,0,12:57917 192.168.0.3:389 ESTABLISHED 16072/apache2</span><br></pre></td></tr></table></figure><p>Apache 의 작업 스레드가 MySQL 두 개(포트 3306)와 다른 컴퓨터에 대한 연결(포트 389)을 연 것 같다. 389번 포트 정보를 알기 위해 아래를 실행한다. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@saragon<span class="comment"># grep 389 /etc/services</span></span><br><span class="line"></span><br><span class="line">ldap   389/tcp <span class="comment"># Lightweight Directory Access Protocol</span></span><br><span class="line">ldap   389/udp</span><br></pre></td></tr></table></figure><p>이제 이 서버가 LDAP 인증을 이용한다는 사실을 알게 됐다. 그럼 프로세스 16702 에 대해 더 알아보자. ps 를 이용하면 프로세스가 무슨 일을 하는지 아주 쉽게 알 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@saragon<span class="comment"># ps -eaf | grep &#x27;UID\|16702&#x27;</span></span><br></pre></td></tr></table></figure><p>프로세스가 연 파일을 lsof 명령어를 이용해 나열할 수도 있다. 이 기능은 유형에 상관없이 정보를 찾아낼 때 아주 좋은데 유닉스에선 모든 게 파일이기 때문이다. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@saragon<span class="comment"># lsof -i -P | grep 16702</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://daniel-hebn.github.io/2018/04/14/2018-04-14-MySQL-%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%81%ED%99%94-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>MySQL 성능최적화 (1)</title>
      <link>https://daniel-hebn.github.io/2018/04/14/2018-04-14-MySQL-%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%81%ED%99%94-1/</link>
      <guid>https://daniel-hebn.github.io/2018/04/14/2018-04-14-MySQL-%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%81%ED%99%94-1/</guid>
      <pubDate>Sat, 14 Apr 2018 14:30:00 GMT</pubDate>
      <description>
      
        
        
          &lt;img src=&quot;/images/logo/MySQL_performance_tuning.png&quot;/&gt;&lt;h1 id=&quot;1장-MySQL-아키텍처&quot;&gt;&lt;a href=&quot;#1장-MySQL-아키텍처&quot; class=&quot;headerlink&quot; title=&quot;1장 MySQL 아키텍
        
      
      </description>
      
      
      <content:encoded><![CDATA[<img src="/images/logo/MySQL_performance_tuning.png"/><h1 id="1장-MySQL-아키텍처"><a href="#1장-MySQL-아키텍처" class="headerlink" title="1장 MySQL 아키텍처"></a>1장 MySQL 아키텍처</h1><p>MySQL 을 최상으로 활용하기 위해선 먼저 그 구조를 이해해야 한다. <br/></p><img src="/2018/04/14/2018-04-14-MySQL-%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%81%ED%99%94-1/mysql_architecture.png" class="" title="MySQL Architecture"><br/><blockquote><p>참고: <a href="https://www.oreilly.com/library/view/high-performance-mysql/9781449332471/ch01.html">high-performance-mysql</a></p></blockquote><ol><li>최상층의 서비스는 MySQL 에 고유한 것은 아니며 대부분의 네트워크 기반 클라이언트 서버 또는 서버 도구에 필요한 서비스들로 연결 처리, 인증, 보안 등이 포함된다.</li><li>두 번째 층은 MySQL 의 두뇌라 할 수 있는 대부분의 기능이 있는데, 쿼리 파싱, 분석 또는 검토, 최적화, 캐싱, 내장 함수 등의 코드가 있다. 스토어드 프로시저, 트리거, 뷰 등의 스토리지 엔진에 관련된 모든 기능이 있다.</li><li>세 번째 층은 스토리지 엔진이 있는데, 이 엔진들이 MySQL 안에 저장된 데이터를 검색하고 저장하는 역할을 한다. 스토리지 엔진은 SQL 을 파싱하거나 서로 통신하지 않고 단순히 서버의 요구에 반응하는 역할만 한다. 서버는 스토리지 엔진 API 를 통해 통신하는데, 이러한 인터페이스는 서로 다른 스토리지 엔진 사이의 차이점을 감춰주어 쿼리 층 수준에서는 스토리지 엔진 간의 차이가 거의 나지 않게 만들어 준다.</li></ol><h2 id="InnoDB-엔진"><a href="#InnoDB-엔진" class="headerlink" title="InnoDB 엔진"></a>InnoDB 엔진</h2><ul><li><code>InnoDB</code> 는 트랜잭션을 처리하기 위해 고안됐는데 대부분의 경우 롤백되지 않고 완료되는 짧은 트랜잭션이 많은 경우를 처리하기 좋게 되어 있다. <code>InnoDB</code> 는 트랜잭션을 지원하는 스토리지 엔진 중 가장 유명하며 뛰어난 성능과 자동 장애 복구 기능으로 인해 트랜잭션이 팔요없는 상황에서도 널리 쓰인다.</li><li><code>InnoDB</code> 는 데이터를 테이블스페이스라고 하는 한 개 이상의 일련의 데이터 파일에 저장한다. 테이블스페이스는 <code>InnoDB</code> 에서 자체적으로 관리하는 블랙박스라고 볼 수 있다. <code>InnoDB</code> 는 동시성을 높이기 위해 MVCC 를 이용하며 SQL 표준인 4가지 격리 수준을 모두 구현한다. REPEATABLE READ 격리 수준을 기본으로 하며 팬텀 리드(Phantom Read)를 막는 넥스트-키 잠금 전략을 갖고 있다. <code>InnoDB</code> 는 쿼리가 변경되는 행만 잠그는 것이 아니라 인덱스 구조 안의 레코드 사이의 갭(Gap)도 잠궈 팬텀 레코드가 삽입되지 않게 한다.</li><li><code>InnoDB</code> 는 클러스터 인덱스(clustered index)위에 구성되는데, 매우 신속한 기본 키(Primary Key)조회가 가능하다. 그러나 보조 인덱스는 기본 키 행을 포함하므로 만약 기본 키가 크다면 다른 인덱스 또한 클 것이다. </li></ul><h2 id="적합한-엔진-선택하기"><a href="#적합한-엔진-선택하기" class="headerlink" title="적합한 엔진 선택하기"></a>적합한 엔진 선택하기</h2><h3 id="트랜잭션"><a href="#트랜잭션" class="headerlink" title="트랜잭션"></a>트랜잭션</h3><ul><li><code>InnoDB</code> 는 트랜잭션을 지원한다. </li><li><code>MyISAM</code> 은 트랜잭션이 필요 없거나 SELECT, INSERT 쿼리를 많이 사용하는 경우에 적합한 엔진인데 로깅과 같은 응용프로그램의 특수 구성 요소가 이 경우에 속한다.</li></ul><h3 id="동시성"><a href="#동시성" class="headerlink" title="동시성"></a>동시성</h3><ul><li>동시에 삽입과 읽기만 하면 된다면 <code>MyISAM</code> 으로도 충분하지만, 여러 작업이 서로 인터럽트 없이 동시에 실행되려면 행 수준 잠금 기능이 있는 엔진을 선택해야 한다.</li></ul><h3 id="특수기능"><a href="#특수기능" class="headerlink" title="특수기능"></a>특수기능</h3><ul><li>많은 응용프로그램은 클러스터 인덱스 최적화에 의존한다 (<code>InnoDB</code>, <code>SolidDB</code>) </li><li>전문 검색의 경우 지원하는 엔진은 <code>MyISAM</code> 밖에 없다.</li></ul><h2 id="실용-예제"><a href="#실용-예제" class="headerlink" title="실용 예제"></a>실용 예제</h2><h3 id="1-로깅하기"><a href="#1-로깅하기" class="headerlink" title="1. 로깅하기"></a>1. 로깅하기</h3><p><code>MyISAM</code> 과 <code>Archive</code> 스토리지 엔진은 오버헤드가 매우 낮으며 초당 수천개의 레코드를 삽입할 수 있으므로 이 경우에 적합하다. </p><p>로깅된 데이터의 요약 보고서를 만들어야 할 경우, MySQL 의 내장 복제 기능을 사용하여 데이터를 슬레이브 서버에 복제한다. 그 후, 슬레이브에 있는 데이터에 시간과 CPU 를 많이 소모하는 쿼리를 실행시키면 된다. </p><p>또 다른 옵션은 머지 테이블을 사용하는 것이다. 같은 테이블에 매번 로깅하는 대신, web_log_2018_01_01 과 같이 연도와 이름을 포함한 테이블에 로깅하도록 하는 것이다. 그 후 최신 테이블에서 insert 를 진행하는 동안 응용프로그램은 인터럽트 받지 않고 과거 테이블의 데이터를 분석할 수 있다.</p><h3 id="2-주문처리"><a href="#2-주문처리" class="headerlink" title="2. 주문처리"></a>2. 주문처리</h3><p>트랜잭션이 필수 상황이다. <code>InnoDB</code> 가 가장 적합하다.</p><h3 id="3-주식-시세"><a href="#3-주식-시세" class="headerlink" title="3. 주식 시세"></a>3. 주식 시세</h3><p><code>MyISAM</code> 은 주식 시세를 개인 관심용으로 분석하는 것 같은 일상적인 용도로 쓰기에 적합하다. 그러나 웹 서비스가 실시간 시세를 제공하며 사용자가 수천 명이고 트래픽이 많다면, 쿼리가 절대 대기 상태에 있어서는 안 된다. 여러 클라이언트가 읽기와 쓰기 권한을 동시에 테이블에 요청할 수 있으므로 행 수준 잠금을 쓰거나 데이터 갱신을 최소화하도록 설계해야 한다.</p>]]></content:encoded>
      
      <comments>https://daniel-hebn.github.io/2018/04/14/2018-04-14-MySQL-%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%81%ED%99%94-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring Transaction</title>
      <link>https://daniel-hebn.github.io/2018/02/26/2018-02-26-Spring-Transaction/</link>
      <guid>https://daniel-hebn.github.io/2018/02/26/2018-02-26-Spring-Transaction/</guid>
      <pubDate>Mon, 26 Feb 2018 08:53:45 GMT</pubDate>
      <description>
      
        
        
          &lt;img src=&quot;/images/logo/spring_framework.png&quot;/&gt;&lt;h2 id=&quot;transaction&quot;&gt;&lt;a href=&quot;#transaction&quot; class=&quot;headerlink&quot; title=&quot;transaction&quot;&gt;&lt;/a&gt;transac
        
      
      </description>
      
      
      <content:encoded><![CDATA[<img src="/images/logo/spring_framework.png"/><h2 id="transaction"><a href="#transaction" class="headerlink" title="transaction"></a>transaction</h2><p>DB 와 서버가 데이터를 처리하는 과정에서 원자성을 부여하는 기술. 즉, 서버가 DB 에 쿼리를 여러 개 던져서 작업을 처리해야 할 때 관련된 쿼리가 모두 수행되거나 모두 수행 안되게 하는 것을 보장해주는 기술</p><p>단일 쿼리로 해결할 수 없는 로직을 처리할 때 필요한 기술이 트랜잭션임. 이것이 가능하려면 하나 이상의 쿼리가 동일한 Connection 객체를 공유해야 가능함.</p><p>java.sql.Connection 객체에서 setAutoCommit 을 false 로 하여 사용자가 직접 커넥션에 대해 커밋과 롤백을 해준다는 것을 뜻한다.</p><h2 id="spring-transaction"><a href="#spring-transaction" class="headerlink" title="spring transaction"></a>spring transaction</h2><p>스프링의 트랜잭션은 기본적으로 프록시 방식의 구현이다.</p><table><thead><tr><th>구현 방식</th><th>설명</th><th>제약사항</th><th>weaving time</th></tr></thead><tbody><tr><td>JDK Dynamic Proxy</td><td>Target Class 의 Interface 가 proxy 역할을 한다.</td><td>interface 구현체에서만 사용 가능</td><td>LTW</td></tr><tr><td>CGLib</td><td>Target Class 의 Subclass 가 proxy 역할을 한다</td><td>public method 에서만 사용 가능</td><td>LTW</td></tr><tr><td>AspectJ</td><td>Compile Time 에  트랜잭션 기능 구현</td><td>private method 에서도 사용 가능</td><td>CTW</td></tr></tbody></table><h2 id="propagation"><a href="#propagation" class="headerlink" title="propagation"></a>propagation</h2><ul><li>REQUIRED : 부모 트랜잭션 내에서 실행하며 부모 트랜잭션이 없을 경우 새로운 트랜잭션을 생성</li><li>REQUIRES_NEW : 부모 트랜잭션을 무시하고 무조건 새로운 트랜잭션이 생성</li><li>SUPPORT : 부모 트랜잭션 내에서 실행하며 부모 트랜잭션이 없을 경우 nontransactionally로 실행</li><li>NOT_SUPPORTED : nontransactionally 로 실행하며 부모 트랜잭션 내에서 실행될 경우 일시 정지</li><li>NEVER : nontransactionally 로 실행되며 부모 트랜잭션이 존재한다면 예외가 발생</li><li>NESTED : 해당 메서드가 부모 트랜잭션에서 진행될 경우 별개로 커밋되거나 롤백될 수 있음. 둘러싼 트랜잭션이 없을 경우 REQUIRED와 동일하게 작동</li><li>MANDATORY : 부모 트랜잭션 내에서 실행되며 부모 트랜잭션이 없을 경우 예외가 발생됩</li></ul><h2 id="isolation"><a href="#isolation" class="headerlink" title="isolation"></a>isolation</h2><ul><li>DEFAULT : DB에서 설정된 기본 격리 수준을 따름</li><li>SERIALIZABLE : 가장 높은 격리수준을 가지며 사용 시 성능 저하가 있을 수 있음</li><li>READ_UNCOMMITTED : 커밋되지 않은 데이터에 대한 읽기를 허용</li><li>READ_COMMITTED : 커밋된 트랜잭션에 대해 읽기를 허용</li><li>REPEATABLE_READ : 동일한 필드에 대한 다중 접근 시 동일한 결과를 얻을 수 잇는 것을 보장</li></ul><h3 id="READ-UNCOMMITED-예시"><a href="#READ-UNCOMMITED-예시" class="headerlink" title="READ_UNCOMMITED 예시"></a>READ_UNCOMMITED 예시</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@GLOBAL</span>.tx_isolation, @<span class="variable">@tx</span>_isolation;</span><br><span class="line"></span><br><span class="line">TX A: <span class="keyword">start</span> transaction;</span><br><span class="line">TX B: <span class="keyword">set</span> session transaction isolation level read uncommitted;</span><br><span class="line">TX B: <span class="keyword">start</span> transaction;</span><br><span class="line">TX A: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test;                   <span class="comment">-- val = 8</span></span><br><span class="line">TX B: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test;                   <span class="comment">-- val = 8</span></span><br><span class="line">TX A: update test <span class="keyword">set</span> val <span class="operator">=</span> val <span class="operator">+</span> <span class="number">1</span>;        <span class="comment">-- val = 9</span></span><br><span class="line">TX B: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test;                   <span class="comment">-- val = 9, dirty read</span></span><br><span class="line">TX A: <span class="keyword">rollback</span>;</span><br><span class="line">TX B: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test;                   <span class="comment">-- val = 8</span></span><br><span class="line">TX B: <span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><h3 id="READ-COMMITED-예시"><a href="#READ-COMMITED-예시" class="headerlink" title="READ_COMMITED 예시"></a>READ_COMMITED 예시</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@GLOBAL</span>.tx_isolation, @<span class="variable">@tx</span>_isolation;</span><br><span class="line"></span><br><span class="line">TX A: <span class="keyword">start</span> transaction;</span><br><span class="line">TX B: <span class="keyword">set</span> session transaction isolation level read committed;</span><br><span class="line">TX B: <span class="keyword">start</span> transaction;</span><br><span class="line">TX A: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test;                   <span class="comment">-- val = 8</span></span><br><span class="line">TX B: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test;                   <span class="comment">-- val = 8</span></span><br><span class="line">TX A: update test <span class="keyword">set</span> val <span class="operator">=</span> val <span class="operator">+</span> <span class="number">1</span>;        <span class="comment">-- val = 9</span></span><br><span class="line">TX B: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test;                   <span class="comment">-- val = 8, No dirty read!</span></span><br><span class="line">TX A: <span class="keyword">commit</span></span><br><span class="line">TX B: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test;                   <span class="comment">-- val = 9, commited read</span></span><br></pre></td></tr></table></figure><h3 id="REPEATABLE-READ-예시"><a href="#REPEATABLE-READ-예시" class="headerlink" title="REPEATABLE_READ 예시"></a>REPEATABLE_READ 예시</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@GLOBAL</span>.tx_isolation, @<span class="variable">@tx</span>_isolation;</span><br><span class="line"></span><br><span class="line">TX A: <span class="keyword">start</span> transaction;</span><br><span class="line">TX B: <span class="keyword">set</span> session transaction isolation level repeatable read;</span><br><span class="line">TX B: <span class="keyword">start</span> transaction;</span><br><span class="line">TX A: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test;                   <span class="comment">-- val = 8</span></span><br><span class="line">TX B: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test;                   <span class="comment">-- val = 8</span></span><br><span class="line">TX A: update test <span class="keyword">set</span> val <span class="operator">=</span> val <span class="operator">+</span> <span class="number">1</span>;        <span class="comment">-- val = 9</span></span><br><span class="line">TX B: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test;                   <span class="comment">-- val = 8</span></span><br><span class="line">TX A: <span class="keyword">commit</span></span><br><span class="line">TX B: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test;                   <span class="comment">-- val = 8, repeatable read!</span></span><br><span class="line">TX B: <span class="keyword">commit</span>;</span><br><span class="line">TX B: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test;                   <span class="comment">-- val = 9 (from tx A)</span></span><br></pre></td></tr></table></figure><h3 id="SERIALIZABLE-예시"><a href="#SERIALIZABLE-예시" class="headerlink" title="SERIALIZABLE 예시"></a>SERIALIZABLE 예시</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@GLOBAL</span>.tx_isolation, @<span class="variable">@tx</span>_isolation;</span><br><span class="line"></span><br><span class="line">TX A: <span class="keyword">start</span> transaction;</span><br><span class="line">TX B: <span class="keyword">set</span> session transaction isolation level serializable;</span><br><span class="line">TX B: <span class="keyword">start</span> transaction;</span><br><span class="line">TX A: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test;               <span class="comment">-- val = 8</span></span><br><span class="line">TX A: update test <span class="keyword">set</span> val <span class="operator">=</span> val <span class="operator">+</span> <span class="number">1</span>;    <span class="comment">-- val = 9</span></span><br><span class="line">TX B: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test;               <span class="comment">-- LOCKED, NO OUTPUT</span></span><br><span class="line">TX A: <span class="keyword">commit</span>;                           <span class="comment">-- Unlocked TX B</span></span><br><span class="line">TX B: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test;               <span class="comment">-- val = 8 (repeatable read!)</span></span><br><span class="line">TX B: <span class="keyword">commit</span>;</span><br><span class="line">TX B: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test;               <span class="comment">-- val = 9 (now we see TX A)</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://daniel-hebn.github.io/2018/02/26/2018-02-26-Spring-Transaction/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Holub on Patterns(2)</title>
      <link>https://daniel-hebn.github.io/2018/01/29/2018-01-29-Holub-on-Patterns-2/</link>
      <guid>https://daniel-hebn.github.io/2018/01/29/2018-01-29-Holub-on-Patterns-2/</guid>
      <pubDate>Mon, 29 Jan 2018 14:30:00 GMT</pubDate>
      <description>
      
        
        
          &lt;img src=&quot;/images/logo/holub-on-patterns.png&quot;/&gt;&lt;h1 id=&quot;3장-라이프-게임&quot;&gt;&lt;a href=&quot;#3장-라이프-게임&quot; class=&quot;headerlink&quot; title=&quot;3장 라이프 게임&quot;&gt;&lt;/a&gt;3장 라이프 게임&lt;/h
        
      
      </description>
      
      
      <content:encoded><![CDATA[<img src="/images/logo/holub-on-patterns.png"/><h1 id="3장-라이프-게임"><a href="#3장-라이프-게임" class="headerlink" title="3장 라이프 게임"></a>3장 라이프 게임</h1><h2 id="Clock-서브-시스템-Observer-디자인-패턴"><a href="#Clock-서브-시스템-Observer-디자인-패턴" class="headerlink" title="Clock 서브 시스템: Observer 디자인 패턴"></a>Clock 서브 시스템: Observer 디자인 패턴</h2><p>Clock은 이벤트를 처리하는 객체들(Observer)에 주기적으로 클록 틱(clock tick) 이벤트를 통지한다.</p><p>Observer 의 주요 목적은 이벤트를 발생시키는 객체와 이벤트를 처리하는 객체 간의 결합도를 줄이는 것이다.</p><table><thead><tr><th>이벤트를 발생시키는 객체</th><th>이벤트를 처리하는 객체</th></tr></thead><tbody><tr><td>Observable</td><td>Observer</td></tr><tr><td>Subject</td><td>Observer</td></tr><tr><td>Publish</td><td>Subscribe</td></tr></tbody></table><p>Observable 은 이벤트 메시지를 Observer 에 보내고, 이 메시지는 Observer 인터페이스의 메서드 인자를 통해 구체 Observer 에 통지된다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subscriber</span> <span class="keyword">implements</span> <span class="title">ActionListener</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">... <span class="comment">// 이벤트 발생 시 취할 행동</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 사용자가 이벤트를 발생시키면 Observable 은 Observer 인터페이스의 하나 혹은 그 이상의 메서드를 호출함으로써 구체 Observer 에 통지한다. 이 때 실제로 Observer 에게 통지하는 코드는 Commend 객체에 캡슐화 되어 있다.</p><p>아래 예제와 같이 익명 내부 클래스를 사용하여 Observer 패턴을 실체화할 수도 있다. 이와 같은 구현으로 Observer 패턴의 세 부분 모두를 한 곳에 모을 수 있다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="keyword">volatile</span> Boolean menuItemSelected = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Client</span><span class="params">(JMenu topMenu)</span> </span>&#123;</span><br><span class="line">JMenuItem myItem = <span class="keyword">new</span> JMenuItem(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">myItem.addActionListener(</span><br><span class="line"><span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">menuItemSelected = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line">topMenu.add(myItem);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Concrete Observer/Subscriber 역할은 Listener(Observer) 인터페이스를 구현하는 클래스가 맡게 된다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Clock.instance().addClockListener(</span><br><span class="line"><span class="keyword">new</span> Clock.Listener() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tick</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 클록 틱 이벤트를 처리하는 코드 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>구체 Observer/Subscriber 는 addClockListener() 를 호출해 자신을 Publish 에 등록하며, addClockListener 메서드는 Publish 객체에 Universe 인스턴스를 위임한다. Universe 객체는 Clock.instance().startTicking() 을 호출하여 클록을 시작시키고, 이후부터 리스너가 주기적으로 이벤트 통지를 받는다 (등록된 리스너의 tick() 메서드가 호출된다)</p><p>여기서 내가 자체적으로 정리한 것을 기록하면 아래와 같다.</p><blockquote><p>Pub/Sub</p><ol><li><p>Pub 은<br>a. Sub 를 등록<br>b. Sub 에게 이벤트 통지<br>c. Sub 를 해제 </p></li><li><p>Sub 은<br>a. 이벤트를 받는 Listener 를 구현<br>b. Pub 에게 자신을 등록 </p></li><li><p>Event (Interface)<br>a. pub/sub 간의 연결. 이벤트</p></li></ol><p>1.b. 와 2.a. 가 동일하다<br>1.b. 가 호출되면 2.a. 가 실행된다. </p><p>2 는 3 의 interface 를 구현하고 1 은 1.b. 를 호출할 때<br>2 의 3 interface 를 호출한다. </p></blockquote><h2 id="Observer-구현하기-Publish-클래스"><a href="#Observer-구현하기-Publish-클래스" class="headerlink" title="Observer 구현하기: Publish 클래스"></a>Observer 구현하기: Publish 클래스</h2><p>지금까지 많은 개발자들의 경험을 통해 Observer 는 구현하기 매우 어렵다고 밝혀졌고 특히 스윙과 같이 여러 스레드가 상호 작용하는 환경에서는 더욱 그러하다. 스윙의 통지는 스윙 서브시스템에 의해 생성된 ‘이벤트’ 스레드에서 처리된다. 모든 실제 처리는 스윙 이벤트 스레드에서 일어나며 이 이벤트 스레드가 사용자 입력 액션에 반응한다. 이 때 이벤트 핸들러 상의 스윙 코드와 메인 스레드상의 코드가 동시에 같은 객체에 접근할 수 있기 때문에 동기화를 적절히 하지 않는다면 충돌은 피할 수 없다.</p><p>불행히도 아래와 같은 구현으로는 이러한 환경에 올바르게 대처할 수 없다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Publisher1</span> </span>&#123;</span><br><span class="line">ArrayList subscribers = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Runnable subscriber)</span> </span>&#123;</span><br><span class="line">subscribers.add(subscriber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">cancelSubscription</span><span class="params">(Runnable subscriber)</span> </span>&#123;</span><br><span class="line">subscribers.remove(subscriber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">fireEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; subscribers.size() ; i++)</span><br><span class="line">((Runnable) subscribers.get(i)).run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이벤트를 통지하는 도중에 객체 리스트를 수정하는 작업은 있을 수 있는 일이고, 이벤트 통지 사이클은 어느 정도의 시간을 소요할 수 있다. 이 때 run() 메서드의 구현은 클라이언트 클래스가 제공하는 것이기 때문에 얼마나 오랜 시간 동안 수행될지 알 수 없다. 이벤트 통지를 하는 동안 subscribe() 메서드를 잠구어 놓는 것은 이벤트 구독을 요청하는 스레드를 ‘굶겨 죽일 수도’ 있게 된다. 만약 이와 같은 ‘기아’ 를 없애기 위해 fireEvent() 에 synchronized 를 제거하면, 어떤 스레드에서 subscribe() 혹은 cancel() 메서드를 수행하는 동안, 다른 스레드에서 fireEvent() 를 수행시킬 수 있기 때문이다.</p><p>이번에는 관점을 달리하여 동기화된 방법의 장점을 살펴보자. fireEvent() 메서드가 비동기적인 상황에서는 통지 중에 추가한 구독자가 리스트의 마지막에 추가되어 구독하기 전에 발생한 통지를 받을 수도 있다. fireEvent() 메서드의 동기화 버전에서는 이러한 문제가 없다.</p><p>그렇다면 어떻게 해야 하는가? 몇 가지 방법이 있다. 첫 번째 방법은 구체적인 클래스 이름 대신에 Collection 인터페이스를 이용하고 리스트 탐색을 위해 Iterator 를 사용하는 것이다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList subscribers = <span class="keyword">new</span> ArrayList(); 를</span><br><span class="line">Collection subscribers = <span class="keyword">new</span> LinkedList() 로 변경</span><br></pre></td></tr></table></figure><p>이렇게 하면 이터레이션 연산이 진행 중인 동안 add(..) 혹은 remove(..) 가 호출되면 예외가 발생하게 된다. 그러므로 이벤트 통지를 하고 있는 동안 리스너를 등록하려 시도하면 예외를 받게 되고, 리스너 등록을 다시 시도해야 한다. 하지만 이 방법은 Observer 에 너무 많은 짐을 떠넘기는 방법이다.</p><p>다른 접근 방법은 복사를 이용하는 것이다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fireEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Collection localCopy;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">localCopy = subscribers.clone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Iterator i = subscribers.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">((Runnable) i.next()).run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clone() 을 이용하여 구독 객체 리스트의 복사본을 만들었다. 그리고 복사본을 이용하여 구독 객체들에 통지를 한다. 통지를 하는 동안 원본 리스트는 사용되지 않기 때문에 통지 프로세스에 영향을 끼치지 않으면서도 리스트를 수정할 수 있게 된다. 이 접근 방법은 앞에서 논의했던 문제점은 해결하지만 새로운 문제를 야기한다.</p><p>첫째, 이벤트 통지가 복사본으로부터 이루어지므로 구독 객체가 구독을 취소한 후에도 이벤트 통지를 할 가능성이 있다. 물론 되게 드문 일이나 우리가 구현하는 애플리케이션에서 이 문제가 중요한 것이라면 이 점을 명심하고 방어적으로 작성하기 바란다.</p><p>둘째, 이벤트 통지는 자주 일어날 수 있는데 이때마다 복사본을 만드는 것은 효율적이지 못하다. 대신 드물게 일어나는 구독 취소가 일어났을 때에만 복사본을 만드는 것이 현명할 것이다. (어떻게 한다는 것인지는… 기술되지 않음. 스스로 고민해보자) 해당 이슈를 해결한 멋진 코드는 뒤에 기술할 예정이다.</p><p>아래의 코드는 Clock 클래스로부터 Publisher 가 Observer 를 어떻게 처리하는지를 보여주는 부분을 발췌한 것이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Publisher publisher = <span class="keyword">new</span> Publisher();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Listener</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tick</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addClockListener</span><span class="params">(Listener l)</span> </span>&#123;</span><br><span class="line">publisher.subscribe(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">publisher.publish(</span><br><span class="line"><span class="keyword">new</span> Publisher.Distributor() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deliverTo</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">((Listener) subscriber).tick();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addClockListener(…) 는 단순히 Publisher 객체로 메시지 처리를 위임한다 (Observable 에 Observer 를 등록하는 것) 클록이 ‘똑딱’ 할 때마다 호출되는 tick() 메서드는 모든 구독 객체에 이벤트가 발생했음을 통지한다. Clock 은 이를 Publisher 에 실제 통지를 수행하는 Command 객체(Publisher.Distributor()) 를 넘김으로써 수행한다. 그러면 Publisher 는 Distributor 객체의 deliverTo() 메서드를 여러 번 호출하게 되며, 호출 시마다 이 메서드에 다른 구독 객체를 넘겨준다. (어떻게 여러 번 호출하지?)</p><p>Command 객체가 Observer 에 어떻게 통지할 것인가에 대한 정보를 캡슐화하기 때문에, Publisher는 통지 메커니즘을 Command 객체에 위임할 수 있다. 즉, Publisher 는 실제로 구독 객체에 어떻게 통지 (어떻게 처리) 하는지에 대한 정보를 가지고 있지 않다. 구독과 관련된 정보는 Publisher 가 아닌 Command 객체가 갖고 있다. Publisher 는 구독 객체의 리스트를 관리하고 Distributer 의 구현체가 구독 객체들에 통지를 어떻게 할지 결정한다는 것을 알고 있다.</p><p>이제 본격적으로 위에서 이야기한 이슈를 해결하는 코드를 살펴본다. Publisher 객체는 구독 객체들을 연결 리스트를 이용하여 관리한다. 이 때 단일 연결 리스트를 직접 구현하였다. 리스트의 각 노드는 구독 객체와 다음 Node 에 대한 레퍼런스를 지니고 있다. 생성자는 새로운 노드를 생성하고, 이 노드를 리스트에 연결시킨다. 이 때 새로 생성된 노드가 리스트의 헤드가 된다. 생성자에 새로운 구독 객체와 리스트 헤드의 레퍼런스를 넘겨주면, 노드는 next 레퍼런스를 이전의 헤드 레퍼런스를 가리키면서 스스로 리스트의 헤드가 된다. subscribe() 메서드는 리스트의 헤드에 대한 레퍼런스를 새로 생성된 노드 객체에 대한 레퍼런스로 교체한다. Node 의 모든 필드는 final 이므로 Node 는 불변(immutable) 객체이며 한 번 생성하면 수정할 수 없다. 결과적으로 여러 스레드가 Node 객체에 접근하더라도 안전하며 동기화를 하지 않아도 된다.</p><p>이벤트가 발생하면 클라이언트 클래스는 publish() 메서드를 호출하고, publish() 메서드는 리스트의 머리에서 꼬리까지 순회하면서 각 구독 객체가 publish(…) 의 인자로 넘어온 deliveryAgent Command 객체를 받아들이도록(accept) 요청한다. Node 의 accept 메서드를 보면 하는 일은 단지 deliverTo(…) 메서드를 호출하여 deliveryAgent 가 이벤트 통지 작업을 하도록 요청하는 것 밖에 없다. 그러므로 실제로는 deliveryAgent 가 구독 객체에 이벤트가 발생했음을 알리게 된다. (자세한 건 Visitor 패턴에서 논의)</p><p>이런 구조를 가질 경우 어떤 스레드가 publish 호출 직후 다른 스레드가 subscribe(b) 를 호출한다고 하면, 새로운 노드는 통지가 시작될 때는 리스트에 없었고 통지를 받는 첫 번째 구독 객체부터 연결 리스트를 타고 꼬리 객체까지 통지가 전달된다. 또한 구독 해지를 한다면 재귀를 이용해 삭제할 노드를 찾은 후에 다시 원 호출로 돌아오게 되고, 이 과정에서 실제 노드 삭제가 일어나지는 않지만 삭제할 노드 왼쪽에 있는 모든 노드를 새로 생성하게 된다. 물론 새로 생성된 노드는 기존의 구독 객체들에 대한 레퍼런스를 갖도록 초기화된다. </p><p>이제 해당 코드 전체를 작성한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*&lt;PRE&gt;</span></span><br><span class="line"><span class="comment">*class EventGenerator &#123;</span></span><br><span class="line"><span class="comment">*interface Listener &#123;</span></span><br><span class="line"><span class="comment">*notify(String why);</span></span><br><span class="line"><span class="comment">*&#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*private Publisher publisher = new Publisher();</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*public void addEventListener(Listener l) &#123;</span></span><br><span class="line"><span class="comment">*publisher.subscribe(l);</span></span><br><span class="line"><span class="comment">*&#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*public void removeEventListener(Listener l) &#123;</span></span><br><span class="line"><span class="comment">*publisher.cancelSubscription(l);</span></span><br><span class="line"><span class="comment">*&#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*public void someEventHasHappend(final String reason) &#123;</span></span><br><span class="line"><span class="comment">*publisher.publish(</span></span><br><span class="line"><span class="comment">*new Publisher.Distributor() &#123;</span></span><br><span class="line"><span class="comment">*public void deliverTo(Object subscriber) &#123;</span></span><br><span class="line"><span class="comment">*((Listener)subscriber).notify(reason);</span></span><br><span class="line"><span class="comment">*&#125;</span></span><br><span class="line"><span class="comment">*&#125;</span></span><br><span class="line"><span class="comment">*);</span></span><br><span class="line"><span class="comment">*&#125;</span></span><br><span class="line"><span class="comment">*&#125;</span></span><br><span class="line"><span class="comment">*&lt;/PRE&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Publisher</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Distributor</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deliverTo</span><span class="params">(Object subscriber)</span></span>; <span class="comment">// Visitor 패턴의 visit 메서드</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object subscriber;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Node next;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Node</span><span class="params">(Object subscriber, Node next)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.subscriber = subscriber;</span><br><span class="line"><span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">remove</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (target == subscriber)</span><br><span class="line"><span class="keyword">return</span> next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (next == <span class="keyword">null</span>) </span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> java.util.NoSuchElementException(target.toString());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Node(subscriber, next.remove(target));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Distributor deliveryAgent)</span> </span>&#123;</span><br><span class="line">deliveryAgent.deliverTo(subscriber); <span class="comment">// deliveryAgent 는 visitor 이다.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Node subscribers = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">(Distributor deliveryAgent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Node cursor = subscribers; cursor != <span class="keyword">null</span> ; cursor = cursor.next)</span><br><span class="line">cursor.accept(deliveryAgent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">subscribers = <span class="keyword">new</span> Node(subscriber, subscribers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelSubscription</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">subscriber = subscribers.remove(subscriber);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://daniel-hebn.github.io/2018/01/29/2018-01-29-Holub-on-Patterns-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Holub on Patterns(1)</title>
      <link>https://daniel-hebn.github.io/2018/01/28/2018-01-28-Holub-on-Patterns-1/</link>
      <guid>https://daniel-hebn.github.io/2018/01/28/2018-01-28-Holub-on-Patterns-1/</guid>
      <pubDate>Sun, 28 Jan 2018 14:30:00 GMT</pubDate>
      <description>
      
        
        
          &lt;img src=&quot;/images/logo/holub-on-patterns.png&quot;/&gt;&lt;h1 id=&quot;2장-인터페이스로-프로그래밍하기-그리고-몇-개의-생성패턴&quot;&gt;&lt;a href=&quot;#2장-인터페이스로-프로그래밍하기-그리고-몇-개의-생성패턴&quot; class=&quot;he
        
      
      </description>
      
      
      <content:encoded><![CDATA[<img src="/images/logo/holub-on-patterns.png"/><h1 id="2장-인터페이스로-프로그래밍하기-그리고-몇-개의-생성패턴"><a href="#2장-인터페이스로-프로그래밍하기-그리고-몇-개의-생성패턴" class="headerlink" title="2장 인터페이스로 프로그래밍하기 그리고 몇 개의 생성패턴"></a>2장 인터페이스로 프로그래밍하기 그리고 몇 개의 생성패턴</h1><p>간략히 인상적인 문구들만 정리한다.</p><ul><li>디자인 패턴은 크게 보면 구현 상속(extends)을 인터페이스 상속(implements)으로 바꾸는 방법을 설명하고 있다.</li><li>구현 상속보다는 인터페이스 상속이 훨씬 바람직하다.</li><li>OO 원리를 충실히 지키면 결합도를 상당히 낮출 수 있다. 데이터와 구현을 은닉하고, 가능하면 인터페이스를 사용하여 프로그래밍하라</li><li>extends 는 깨지기 쉬운 기반 클래스 문제를 야기한다. 이는 부모 클래스와 자식 클래스 간의 강한 결합 관계 때문이다.</li><li>파생 클래스가 상속을 원치 않는 기반 클래스의 메서드에서 예외를 던지는 방법은 나쁜 방법이다. 이는 LSP 를 어기는 것이며 결과적으로 OCP 까지 지킬 수 없게 된다.</li><li>상속 대신 합성을 사용하라</li><li>인터페이스 상속을 이용하면 상속된 기능이 없기 때문에 잘못될 일도 없다. </li><li>인터페이스 관점에서 프로그래밍하라. 의존 관계 역전의 원칙(DIP)을 준수하라</li><li>추상화를 잘하면 유연해진다. 하지만 복잡성도 증가한다. 유연성과 복잡성 사이에서 적절한 트레이드 오프를 하라</li></ul><h2 id="올바른-OO-디자인-과정"><a href="#올바른-OO-디자인-과정" class="headerlink" title="올바른 OO 디자인 과정"></a>올바른 OO 디자인 과정</h2><ol><li>‘도메인 모델’ 에 대해 학습한다.</li><li>고객이 해결하려는 것이 무엇인지를, 즉 요구 사항을 유도한다</li><li>모든 문제에 대한 유스케이스를 규명한다. 이 때, 유스케이스란 사용자가 수행하여 유의미한 결과를 내놓는 단일 작업을 의미한다</li><li>유스케이스에 기술된 목적을 성취하기 위해 어떤 액티비티가 필요한지를 생각한다</li><li>전 단계에서 규명된 액티비티를 수행하기 위해 런타임에 객체들이 서로 어떻게 메시지를 보내는지를 보여주는 ‘동적 모델’을 생성한다.</li></ol><p>동적 모델링을 하는 동안 객체들이 어떻게 상호 작용을 하는지를 보여주는 클래스 다이어그램을 생성한다. </p><p>동적 모델링으로부터 클래스 다이어그램을 도출하라. 이렇게 하면 실제 필요한 연산과 관계만이 포함되기 때문에 정적 모델이 현실적이 되고 가벼워진다.</p><p>동적 모델링을 충분히 수행한 후 특정 객체들이 모두 사용하고 있는 공통 연산 집합이 식별되었다면, 공통 연산 집합을 기반 클래스에 구현한 후 구현 상속(extends)을 통해 재사용할 수 있다.</p><p>만약 두 클래스가 동일한 연산을 다른 방식으로 수행한다면 각 클래스가 공통의 인터페이스를 구현해야 한다. 예를 들어 Employee 인터페이스를 Manager 와 Engineer 클래스가 다른 방식으로 구현할 수 있다. 그리고 두 클래스에 공통적인 연산이 없다면 별도의 클래스를 통해 구현하며 extends 나 implements 관계는 필요 없다. 마지막으로 한 클래스가 다른 클래스에 약간의 연산을 추가한다면 extends 관계가 적절하다. (Manager 는 Employee 가 하는 모든 일을 하고, 여기에 추가적인 일도 한다)</p><p>정리하면</p><blockquote><dl><dt>Employee 와 Manager 가 동일한 연산을 동일한 방식으로 수행한다.</dt><dd>-&gt; <em>같은 클래스로 구현한다.</em></dd></dl><dl><dt>Employee 와 Manager 가 동일한 연산을 다른 방식으로 수행한다.</dt><dd>-&gt; <em>두 클래스가 공통의 인터페이스를 구현한다</em></dd></dl><dl><dt>Employee 와 Manager 가 공통의 연산이 없다.</dt><dd>-&gt; <em>별도의 클래스로 구현한다.</em></dd></dl><dl><dt>Manager 가 Employee 에 약간의 연산을 추가한다.</dt><dd>-&gt; <em>Manager 가 Employee 를 extends 하도록 한다.</em></dd></dl></blockquote><h2 id="extends-제거하기"><a href="#extends-제거하기" class="headerlink" title="extends 제거하기"></a>extends 제거하기</h2><ol><li>현재 클래스와 동일한 이름을 갖는 인터페이스를 생성한다.</li><li>현재 클래스의 이름을 변경하고 인터페이스를 구현하도록 한다.</li><li>new 를 사용하여 Employee 를 생성했던 모든 부분을 바꾸어 준다.</li></ol><p>허나 new 연산은 객체를 생성하는 클라이언트와 생성되는 객체를 결합시키기 때문에 애써 인터페이스를 도입한 효과가 없다. new 를 제거하거나 최소한 감추어야 한다.</p><p>모든 new 호출을 고쳐야만 하는 문제를 해결할 수 있는 좋은 전략 중 하나는 <strong>Abstract Factory 패턴</strong>을 사용하는 것이다. 많은 패턴들이 구현 시 Abstract Factory 패턴을 사용하는 경우가 많기 때문에 Abstract Factory 는 일종의 빌딩 블록이 되는 패턴이라 할 수 있다.</p><p>Abstract Factory 의 모든 실체화에서 공통되는 주제는 팩토리를 사용하여 정확한 타입을 모르는 객체를 생성한다는 것이다. 사용자(클라이언트)는 생성하려는 객체가 구현하고 있는 인터페이스만을 알 뿐, 생성 객체의 실제 타입은 알지 못한다. 예를 들어 EmployeeFactory 를 사용하여 new Employee() 를 EmployeeFactory.create() 로 대체할 수 있다. 이 때 create() 메서드는 Employee 인터페이스를 구현하는 어떤 클래스든 반환할 수 있기 때문에 클라이언트 코드는 구현 클래스와 격리된다. 그러므로 클라이언트 코드에 영향을 끼치지 않으면서 Employee 를 구현한 클래스를 마음대로 바꿀 수 있다.</p><p>또한 Singleton 을 사용하여 Abstract Factory 를 얻어 오고, Abstract Factory 를 사용하여 실제 클래스가 알려지지 않은 객체를 얻어 오는 것은 많이 사용되는 패턴이다.</p><p>‘하나의 객체’ 와 ‘전역 접근’ 이라는 Singleton 의 요구 사항을 만족시키는 가장 쉬운 방법은 모든 것을 static 으로 선언하는 것이다. 하지만 컴파일시에 모든 정보를 알 수 없거나 상속을 통한 커스터마이징이 필요한 경우에는 static 을 사용할 수 없다. 이런 경우에는 전형적인 GoF 식 Singleton 실체화가 필요하다. </p><h2 id="Abstract-Factory-패턴"><a href="#Abstract-Factory-패턴" class="headerlink" title="Abstract Factory 패턴"></a>Abstract Factory 패턴</h2><p>Abstract Factory 패턴은 인터페이스(Employee)를 통해 생성하려는 객체의 실체 타입을 은닉시켜 준다. 생성된 객체를 사용하는 클라이언트는 인터페이스만을 알고 있으므로 인터페이스를 구현하고 있는 구체 클래스의 변화로부터 자유롭다. 구체 클래스는 인터페이스보다 변하기 쉽기 때문에 가능하면 인터페이스를 사용하라는 ‘의존 역전의 원칙’(DIP) 을 생각해보자.</p><p>Java Collection 을 예로 들면 - Collection 인터페이스는 ArrayList, LinkedList 등의 구현체를 은닉 혹은 격리시켜 주며, Iterator 인터페이스는 각 Collection 구현체가 생성한 Iterator 구현체를 은닉시켜 준다. Collection 인터페이스를 사용하는 클라이언트는 자신이 어떤 Collection 구현체를 사용하고 있는지 알 필요가 없으며, Collection 구현체를 통해 생성한 Iterator 구현체의 경우도 마찬가지다. Collection 인터페이스와 Iterator 인터페이스만 알면 된다. 이와 같은 구조는 인터페이스를 통한 프로그래밍을 가능케 해주며 뛰어난 유연성을 보장해준다. </p><h2 id="Command-패턴과-Strategy-패턴"><a href="#Command-패턴과-Strategy-패턴" class="headerlink" title="Command 패턴과 Strategy 패턴"></a>Command 패턴과 Strategy 패턴</h2><p>Command 패턴은 빌딩 블록 패턴이며, Strategy 패턴은 Command 패턴의 특별한 경우이다. Command 패턴의 기본 아이디어는 무엇을 어떻게 해야 한다는 지식을 객체에 캡슐화하여 전달한다는 것이다. 자바 스레드는 전형적인 Command 패턴의 구현체이다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommandObj</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 스레드가 실행될 때 수행할 작업</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Thread controller = <span class="keyword">new</span> Thread( <span class="keyword">new</span> CommandObj() );</span><br><span class="line">controller.start();   <span class="comment">// 스레드를 시작한다.</span></span><br></pre></td></tr></table></figure><p>Command 패턴의 주요 특징 중 하나는 Command 객체를 사용하는 클라이언트 클래스가 Command 객체가 무엇을 할지에 대해 아무것도 모른다는 것이다. 또한 Command 패턴 자체를 좀 더 세련된 방식으로 사용하여 ‘되돌리기(undo)’ 시스템과 같은 복잡한 문제를 해결할 수도 있다.</p><p>Strategy 패턴은 특정 연산을 ‘어떻게’ 수행할 것인지에 대한 전략을 캡슐화한 Strategy 객체를 전달한다. 이 때 Strategy 객체는 무엇을 수행해야 하는가가 좀 더 명확한 Command 객체라 할 수 있다.</p><h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><ul><li>Singleton: 제한된 수의 객체를 생성한다.</li><li>Abstract Factory: 관련된 객체 군(family) 중 하나를 생성하도록 해주는 ‘팩토리’. 이 때 생성되는 객체의 구체 타입은 인터페이스를 통해 가려진다. 구체 타입이 아닌 인터페이스를 통해 프로그래밍하기 때문이다.</li><li>Template Method: 기반 클래스에서 일반 알고리즘을 정의하고, 파생 클래스에서 알고리즘이 사용하는 추상 메서드를 오버라이딩한다.</li><li>Factory Method: 구체 클래스가 알려지지 않은 객체를 생성하는 Template Method 이다. Factory Method 는 객체를 생성하는 Factory Method 일 뿐이다.</li><li>Command: 알려지지 않은 알고리즘을 캡슐화하는 객체이다.</li><li>Strategy: 알려진 문제를 해결하는 전략을 캡슐화하는 객체이다. 어떤 알고리즘을 다양한 전략을 통해 해결할 수 있도록 해준다. </li></ul><ol><li>캡슐화 </li></ol><ul><li>캡슐화는 데이터와 연산을 한데 묶는 것을 의미한다. 프로그램에서 흘러 다니는 데이터와 결합도는 보통 비례 관계에 있다. 캡슐화는 이와 같은 데이터 흐름으로 인한 결합도 증가를 막아주는 언어적 장치이다. </li><li>은닉이란 내부 데이터, 내부 연산을 외부에서 접근하지 못하도록 은닉(hiding) 혹은 격리(isolation)시키는 것을 의미한다. 객체는 서비스 제공자(Service Provider)이어야 한다. 그러므로 ‘어떻게’ 연산을 수행하는가는 철저히 은닉되어야 하며, 외부로 공개된 인터페이스 혹은 계약을 통해서만 프로그래밍해야 한다.</li><li>캡슐화와 은닉이 잘 되려면 객체에 책임을 적절히 분배해 주어야 한다. 단일 책임 원칙(SRP)은 좋은 기준이 된다.</li><li>getter/setter 는 가능한 사용을 자제해야 한다. 이는 ‘데이터를 요청하지 말고 도움을 요청하라’ 라는 OO 금언과 관련 있다. 구현이 잘 은닉되어 있고 책임이 제대로 분배되어 있다면 getter/setter 는 그리 필요치 않다.</li><li>구체 클래스는 인터페이스보다 변하기 쉽다. 그러므로 인터페이스를 이용하라는 의존 관계 역전의 원칙(DIP)을 생각하자. 인터페이스를 통해 구체 클래스를 은닉하도록 하자.</li><li>하나의 클래스가 전체적으로는 하나의 역할만을 맡고 있지만 관점에 따라서는 2개 이상의 인터페이스를 구현하고 있을 수 있다. 이런 경우에는 하나의 클래스가 여러 타입이 된다. </li></ul><ol start="2"><li>캡슐화</li></ol><ul><li>상속에는 구현 상속(extends)과 인터페이스 상속(implements)이 있다.</li><li>구현 상속에는 재사용과 다형성 획득이라는 두 가지 기능이 있다.</li><li>인터페이스 상속에는 다형성 획득과 인터페이스를 통한 은닉이라는 기능이 있다. </li><li>구현 상속에는 ‘깨지기 쉬운 기반 클래스 문제’가 있기 때문에 다형성 획득이라는 측면에서 보자면 인터페이스 상속이 안전하고 낫다</li><li>재사용 측면에서 보자면 보통 상속보다는 합성이 좋다. 상속은 불필요한 결합도를 증가시키기 때문이다. </li><li>그러므로 다형성을 위해서는 인터페이스 상속을 사용하고, 재사용을 위해서는 합성을 사용하자. 구현 상속은 언제? 여러 클래스가 공통의 연산 집합을 공유하고 있을 때 정규화를 위해 사용하면 된다.</li><li>상속을 할 때는 상속한 메서드에서 예외를 던지면 안 된다. 예외를 던지면 다형성을 이용하기 어렵기 때문이다. LSP 를 지키자</li></ul><ol start="3"><li>다형성</li></ol><ul><li>캡슐화와 은닉은 ‘무엇을’ 과 ‘어떻게’ 를 분리시켜 준다. 상속은 ‘어떻게’를 다양하게 정의하도록 해준다. 다형성은 이 둘을 조합하여 런타임에 ‘무엇을’ ‘어떻게’ 실행시킬 것인지를 동적으로 정하게 된다. 이는 OCP 를 지킬 수 있도록 해준다.</li><li>예를 들어 로그 메시지를 다양한 방식 (콘솔, 하나의 파일, 날짜별 파일, DB, Mail, TCP/IP) 으로 출력할 수 있을 것이다. 이곳이 바로 다형성이 등장할 곳이다. 로깅 라이브러리는 ‘무엇’(what) 에 해당하는 로그 찍기 메서드만 제공하면 된다. 그리고 설정 파일을 통해 ‘어떻게’(how)에 해당하는 로그 출력 방식을 다양하게 변경할 수 있도록 한다. </li></ul><ol start="4"><li>정리</li></ol><ul><li>변하는 부분과 변하지 않는 부분을 분리하여 변화하는 부분에 다형성을 통해 확장과 수정의 가능성을 열어두는 것이 중요하다</li><li>변화가 예상되는 장소에 인터페이스를 삽입해 놓는 것은 복잡함을 크게 증가시키지 않는다. 인터페이스를 적극 도입하여 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://daniel-hebn.github.io/2018/01/28/2018-01-28-Holub-on-Patterns-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>자바 병렬 프로그래밍(3장)</title>
      <link>https://daniel-hebn.github.io/2017/12/17/2017-12-17-%EC%9E%90%EB%B0%94-%EB%B3%91%EB%A0%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-3%EC%9E%A5/</link>
      <guid>https://daniel-hebn.github.io/2017/12/17/2017-12-17-%EC%9E%90%EB%B0%94-%EB%B3%91%EB%A0%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-3%EC%9E%A5/</guid>
      <pubDate>Sun, 17 Dec 2017 09:53:45 GMT</pubDate>
      <description>
      
        
        
          &lt;img src=&quot;/images/logo/java_concurrency_book.png&quot;/&gt;&lt;h1 id=&quot;3장-객체-공유&quot;&gt;&lt;a href=&quot;#3장-객체-공유&quot; class=&quot;headerlink&quot; title=&quot;3장 객체 공유&quot;&gt;&lt;/a&gt;3장 객체 공유&lt;/h
        
      
      </description>
      
      
      <content:encoded><![CDATA[<img src="/images/logo/java_concurrency_book.png"/><h1 id="3장-객체-공유"><a href="#3장-객체-공유" class="headerlink" title="3장 객체 공유"></a>3장 객체 공유</h1><p>이 장에서는 여러 개의 스레드에서 특정 객체를 동시에 사용하려 할 때, 섞이지 않게 안전하게 동작하도록 객체를 공유하고 공개하는 방법을 살펴본다.<br/><br>앞에서 synchronized 키워드를 사용해 동기화시킨 블록이 단일 연산인 것처럼 동작하게 할 수 있었다. 소스 코드의 특정 블록을 동기화시키고자 할 때는 항상 메모리 가시성(memory visibility) 문제가 발생하는데 이 때문에 특정 변수의 값을 사용하고 있을 때 다른 스레드가 해당 변수의 값을 사용하지 못하도록 막아야 할 뿐만 아니라, 값을 사용한 다음 동기화 블록을 빠져나가고 나면 다른 스레드가 변경된 값을 즉시 사용할 수 있게 해야 한다는 뜻이다. </p><h2 id="3-1-가시성"><a href="#3-1-가시성" class="headerlink" title="3.1 가시성"></a>3.1 가시성</h2><p>단일 스레드만 사용하는 환경이라면 특정 변수에 값을 지정하고 다음번에 해당 변수의 값을 다시 읽어보면, 이전에 저장해뒀던 바로 그 값을 가져올 수 있다. 하지만, 여러 스레드에서 앞서거니 뒤서거니 실행된다면 반드시 그렇지 않을 수도 있다. 특정 변수의 값을 가져갈 때 다른 스레드가 작성한 값을 가져갈 수 있다는 보장도 없고, 심지어는 값을 읽지 못할 수도 있다. 이 때문에 메모리상의 공유된 변수를 여러 스레드에서 서로 사용할 수 있게 하려면 반드시 동기화 기능을 구현해야 한다.<br/></p><p>아래의 코드는 두 개의 스레드에서 변수를 공유해 사용함에도 적절한 동기화 기법을 사용하지 않았기 때문에 문제가 발생할 수 있는 예제 코드이다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoVisibility</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> ready;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(!ready)</span><br><span class="line">Thread.yield();</span><br><span class="line">System.out.println(number);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> ReaderThread().start();</span><br><span class="line">number = <span class="number">42</span>;</span><br><span class="line">ready = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NoVisibility 클래스의 소스코드를 보면, ready 변수의 값을 읽기 스레드에서 영영 읽지 못할 수도 있기 때문에 무한 반복에 빠질 수 있다. 더 이상하게는 읽기 스레드가 메인 스레드에서 number 변수에 지정한 값보다 ready 변수의 값을 먼저 읽어가는 상황도 가능하다. 흔히 재배치(reordering) 라고 하는 현상이다. 재배치 현상은 특정 메서드의 소스 코드가 100% 코딩된 순서로 동작한다는 점을 보장할 수 없다는 점에 기인하는 문제이다. </p><blockquote><p>동기화 기능을 지정하지 않으면 컴파일러나 프로세서, JVM 등이 프로그램 코드가 실행되는 순서를 임의로 바꿔 실행하는 이상한 경우가 발생하기도 한다. 다시 말하면, 동기화 되지 않은 상황에서 메모리상의 변수를 대상으로 작성해둔 코드가 ‘반드시 이런 순서로 동작할 것이다’ 라고 단정지을 수 없다.</p></blockquote><p>이 때문에 <strong>여러 스레드에서 공동으로 사용하는 변수에는 항상 적절한 동기화 기법을 적용</strong>해야 한다.</p><h3 id="3-1-1-스테일-데이터"><a href="#3-1-1-스테일-데이터" class="headerlink" title="3.1.1 스테일 데이터"></a>3.1.1 스테일 데이터</h3><p>변수를 사용하는 모든 경우에 동기화를 시켜두지 않으면 해당 변수에 대한 최신 값이 아닌 다른 값을 사용핟게 되는 경우가 발생할 수 있다.(stale 데이터)<br>게다가 더 큰 문제는 항상 스테일 데이터를 사용하게 될 때도 있고, 정상적으로 동작하는 경우도 있다는 점이다. 이 때 해당 변수가 프로그램 로직의 안전에 심각한 문제를 유발할 수 있는 변수라면 문제가 커진다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutableInteger</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>예제 코드는 value 라는 변수의 값을 get과 set 메서드에서 동시에 사용함에도 불구하고 동기화가 되어 있지 않기 때문에 여러 스레드에서 동시에 사용하면 문제가 발생할 소지가 많다. 예를들어 특정 스레드가 set 메서드를 호출하고 다른 스레드에서 get 메서드를 호출했을 때 set 메서드에서 지정한 값을 get 메서드에서 제대로 읽어가지 못할 가능성이 있다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedInteger</span> </span>&#123;</span><br><span class="line"><span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>예제 코드는 get과 set 을 동기화 시켜서 그 전 코드의 문제를 제거했다. 만약 set 메서드만 동기화 시켰다면 어떨까? 그러면 get 메서드는 여전히 스테일 상황을 초래할 수 있기 때문에 별다른 효과가 없다.</p><h3 id="3-1-2-단일하지-않은-64비트-연산"><a href="#3-1-2-단일하지-않은-64비트-연산" class="headerlink" title="3.1.2 단일하지 않은 64비트 연산"></a>3.1.2 단일하지 않은 64비트 연산</h3><p>64비트를 사용하는 숫자형(double 이나 long) 에 volatile 를 사용하지 않은 경우에는 난데없는 값마저 생길 가능성이 있다. 자바 메모리 모델은 메모리에서 값을 가져오고 저장하는 연산이 단일해야 한다고 정의하고 있지만, volatile 로 지정되지 않은 long 이나 double 형의 64비트 값에 대해서는 메모리에 쓰거나 읽을 때 두 번의 32비트 연산을 사용할 수 있도록 허용하고 있다. 따라서 volatile 을 지정하지 않은 long 변수의 값을 쓰는 기능과 읽는 기능이 서로 다른 스레드에서 동작한다면 이전 값과 최신 값에서 각각 32비트를 읽어올 가능성이 생긴다. 따라서 volatile 을 지정하지도 않고 락을 사용해 동기화하지도 않은 상태로 long 이나 double 값을 동시에 여러 스레드에서 사용할 수 있다면 항상 이상한 문제를 만날 가능성이 있다.</p><h3 id="3-1-3-락과-가시성"><a href="#3-1-3-락과-가시성" class="headerlink" title="3.1.3 락과 가시성"></a>3.1.3 락과 가시성</h3><p>synchronized 로 둘러싸인 코드에서 스레드 A가 사용했던 모든 변수의 값은, 같은 락을 사용하는 synchronized 로 둘러싸인 코드를 스레드 B가 실행할 때 안전하게 사용할 수 있다.<br/><br>값을 변경할 수 있는 변수를 여러 개의 스레드에서 동시에 사용한다면, 바로 이전 스레드에서 사용했던 변수의 값을 오류 없이 정상적으로 다음 스레드가 사용할 수 있게 하기 위해 동일한 락을 사용하는 synchronized 블록으로 막아줄 필요가 있다. </p><h4 id="3-1-4-volatile-변수"><a href="#3-1-4-volatile-변수" class="headerlink" title="3.1.4 volatile 변수"></a>3.1.4 volatile 변수</h4><p>자바 언어에서는 volatile 변수로 약간 다른 형태의 좀 더 약한 동기화 기능을 제공하는데, volatile 로 선언된 변수의 값을 바꿨을 때 다른 스레드에서 항상 최신 값을 읽어갈 수 있도록 해준다. 특정 변수를 선언할 때 volatile 키워드를 지정하면, 컴파일러와 런타임 모두 ‘이 변수는 공유해 사용하고, 따라서 실행 순서를 재배치해서는 안 된다’ 고 이해한다. volatile 로 지정된 변수는 프로세서의 레지스터에 캐시 되지도 않고, 프로세서 외부의 캐시에도 들어가지 않기 때문에 volatile 변수의 값을 읽으면 항상 다른 스레드가 보관해둔 최신의 값을 읽어갈 수 있다. 다만, volatile 변수만 사용해 메모리 가시성을 확보하도록 작성된 코드는 synchronized 로 직접 동기화한 코드보다 훨씬 읽기가 어렵고 따라서 오류가 발생할 가능성도 높다. </p><blockquote><p>동기화하고자 하는 부분을 명확하게 볼 수 있고, 구현하기가 훨씬 간단한 경우에만 volatile 변수를 활용하자. volatile 변수를 사용하는 적절한 경우는, 변수에 보관된 클래스의 상태에 대한 가시성을 확보하거나 중요한 이벤트가 발생했다는 등의 정보를 정확하게 전달하고자 하는 경우 등에 해당한다.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> asleep;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">while</span> (!asleep)</span><br><span class="line">countSomeSheep();</span><br></pre></td></tr></table></figure><p>예제 코드의 asleep 과 같이 작업을 완료했다거나, 인터럽트가 걸리거나, 기타 상태를 보관하는 플래그 변수에 volatile 키워드를 지정한다.<br/><br>하지만 volatile 연산자의 기본적인 능력으로는 증가 연산자(count++)를 사용한 부분까지 동기화를 맞춰 주지는 않는다.<br>정리하면, volatile 변수는 다음과 같은 상황에서만 사용하는 것이 좋다.</p><ul><li>변수에 값을 저장하는 작업이 해당 변수의 현재 값과 관련이 없거나 해당 변수의 값을 변경하는 스레드 하나만 존재</li><li>해당 변수가 객체의 불변조건을 이루는 다른 변수와 달리 불변조건에 관련되어 있지 않을 때</li><li>해당 변수를 사용하는 동안에는 어떤 경우라도 락을 걸어 둘 필요가 없는 경우</li></ul><h2 id="3-2-공개와-유출"><a href="#3-2-공개와-유출" class="headerlink" title="3.2 공개와 유출"></a>3.2 공개와 유출</h2><p>특정 객체를 현재 코드의 스코프 범위 밖에서 사용할 수 있도록 만들면 공개(published)되었다고 한다. 만약 클래스 내부의 상태 변수를 외부에 공개해야 한다면 객체 캡슐화 작업이 물거품이 되거나 내부 데이터의 안정성을 해칠 수 있다. 따라서 객체가 안정적이지 않은 상태에서 공개하면 스레드 안정성에 문제가 생길 수 있다. 이처럼 의도적으로 공개시키지 않았지만 외부에서 사용할 수 있게 공개된 경우를 유출 상태(escaped)라고 한다. <br/><br>자바로 프로그램을 작성할 때 아래와 같이 public static 변수에 객체를 설정하면 가장 직접적인 방법으로 해당 객체를 모든 클래스와 모든 스레드에서 변수를 사용할 수 있도록 공개하는 셈이다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Secret&gt; knownSecrets;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">knownSecrets = <span class="keyword">new</span> HashSet&lt;Secret&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>public static 키워드와 비슷하게 private 이 아닌 메서드를 호출해 그 결과로 받아오는 과정으로도 객체가 공개된다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeStates</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String[] states = <span class="keyword">new</span> String[] &#123;</span><br><span class="line"><span class="string">&quot;AK&quot;</span>, <span class="string">&quot;AL&quot;</span>, ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String[] getStates() &#123;</span><br><span class="line"><span class="keyword">return</span> states;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>원래 private 으로 선언되어 있던 states 라는 변수가 private 이 아닌 getStates 메서드를 통해 외부에 공개될 수 있기 때문에, states 변수는 유출 상태에 놓여 있다고 볼 수 있다. <br/><br>정리해보면 객체를 공개했을 때 그 객체 내부의 private 아닌 변수나 메서드를 통해 불러올 수 있는 모든 객체는 함께 공개된다는 점을 알아두자. 어떤 객체건 일단 유출되고 나면 다른 스레드가 유출된 클래스를 의도적이던 의도적이디 않건 간에 반드시 잘못 사용할 수 있다고 가정해야 한다. 객체가 유출되는 상황에서 어려운 문제점을 겪을 수도 있기 때문에 객체 내부는 캡슐화 해야 한다는 것이다. <br/></p><p>객체나 객체 내부의 상태 값이 외부에 공개되는 또 다른 예는 아래 예제와 같이 내부 클래스의 인스턴스를 외부에 공개하는 경우다. 내부 클래스는 항상 부모 클래스에 대한 참조를 갖고 있기 때문에 ThisEscape 클래스가 EventListener 객체를 외부에 공개하면 EventListener 클래스를 포함하고 있는 ThisEscape 클래스도 외부에 함께 공개된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisEscape</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThisEscape</span><span class="params">(EventSource source)</span> </span>&#123;</span><br><span class="line">source.registerListener &#123;</span><br><span class="line"><span class="keyword">new</span> EventListener() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> vlod <span class="title">onEvent</span><span class="params">(Event e)</span> </span>&#123;</span><br><span class="line">doSomething(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-1-생성-메서드-안정성"><a href="#3-2-1-생성-메서드-안정성" class="headerlink" title="3.2.1 생성 메서드 안정성"></a>3.2.1 생성 메서드 안정성</h3><p> 일반적으로 생성 메서드가 완전히 종료하고 난 이후가 되어야 객체의 상태가 개발자가 예상한 상태로 초기화되기 때문에 생성 메서드가 실행되는 도중에 해당 객체를 외부에 공개한다면 정상적이지 않은 상태의 객체를 외부에서 불러 사용할 가능성이 있다. 생성 메서드가 실행 도중에 this 변수가 외부에 공개된다면, 이론적으로 해당 객체는 정상적으로 생성되지 않았다고 말할 수 있다.</p><blockquote><p>생성 메서드를 실행하는 도중에는 this 변수가 외부에 유출되지 않게 해야 한다.</p></blockquote><p>생성 메서드에서 this 변수를 유출시키는 가장 흔한 오류는 생성 메서드에서 스레드를 새로 만들어 시작시키는 경우다. 생성 메서드에서 또다른 스레드를 만들어 내면 대부분의 경우에는 생성 메서드에의 클래스와 새로운 스레드가 this 변수를 직접 공유하거나 자동으로 공유되기도 한다.<br/><br>예를 들어 생성 메서드에서 만든 스레드의 클래스가 원래 클래스의 내부 클래스라면 자동으로 원래 클래스의 this 변수를 공유하는 상태가 된다. 그러면 새로 만들어져 실행된 스레드에서 원래 클래스의 생성 메서드가 끝나기도 전에 원래 클래스에 정의되어 있는 여러 가지 변수를 직접 사용할 수 있게 된다. 스레드를 생성하면서 바로 시작시키기보다는 스레드를 시작시키는 기능을 start 나 initialize 등으 메서드로 만들어 사용하는 편이 좋다. <br/><br>새로 작성하는 클래스의 생성 메서드에서 이벤트 리스너를 등록하거나 새로운 스레드를 시작시키려면 아래의 예제 코드와 같이 생성 메서드를 private 으로 지정하고 public 으로 지정된 팩토리 메서드를 만들어 사용하는 방법이 좋다. 아래의 코드는 생성 메서드에서 this 변수가 외부로 유출되지 않도록 팩토리 메서드를 사용하는 예제이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeListener</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventListener listener;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SafeListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">listener = <span class="keyword">new</span> EventListener() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span> </span>&#123;</span><br><span class="line">doSomething(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SafeListener <span class="title">newInstance</span><span class="params">(EventSource source)</span> </span>&#123;</span><br><span class="line">SafeListener safe = <span class="keyword">new</span> SafeListener();</span><br><span class="line">source.registerListener(safe.listener);</span><br><span class="line"><span class="keyword">return</span> safe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-스레드-한정"><a href="#3-3-스레드-한정" class="headerlink" title="3.3 스레드 한정"></a>3.3 스레드 한정</h2><p>특정 객체를 단일 스레드에서만 활용한다고 확신할 수 있다면 해당 객체는 따로 동기화할 필요가 없다. 이처럼 객체를 사용하는 스레드를 한정하는 방법으로 스레드 안정성을 확보할 수 있다. <br/><br>예를 들어 스윙(swing)에서 스레드 한정 기법을 굉장히 많이 사용하고 있다. 스윙의 화면 컴포넌트와 데이터 모델 객체는 스레드에 안전하지 않지만, 스윙 이벤트 처리 스레드에 컴포넌트와 모델을 한정시켜 스레드 안정성을 확보하고 있다. <br/><br>스레드 한정 기법을 사용하는 또 다른 사례는 바로 JDBC의 Connection 객체를 풀링해 사용하는 경우다. 일반적인 서버 애플리케이션을 보면 풀에서 DB 연결을 확보하고, 확보한 DB 연결로 요청 하나를 처리한 다음 사용한 연결을 다시 반환하는 과정을 거친다. 서블릿 요청이나 EJB 호출 등의 요청은 대부분 단일 스레드에서 동기적으로 처리하며 DB 풀은 한쪽에서 DB 연결을 하는 동안에는 해당 연결을 다른 스레드가 사용하지 못하게 막기 때문에, 공유하는 Connection 객체를 풀로 관리하면 특정 Connection 을 한 번에 하나 이상의 스레드가 사용하지 못하도록 한정할 수 있다.<br/><br>언어적인 차원에서 임의의 객체를 특정 스레드에 한정시키는 기능은 제공하지 않기 때문에 스레드 한정 기법은 프로그램을 처음 설계하는 과정부터 함께 다뤄야 하며, 프로그램을 구현하는 과정 내내 한정 기법을 계속해서 적용해야 한다. </p><h3 id="3-3-1-스레드-한정-주먹구구식"><a href="#3-3-1-스레드-한정-주먹구구식" class="headerlink" title="3.3.1 스레드 한정 - 주먹구구식"></a>3.3.1 스레드 한정 - 주먹구구식</h3><p>특정 모듈의 기능을 단일 스레드로 동작하도록 구현한다면, 언어적인 지원 없이 직접 구현한 스레드 한정 기법에서 나타날 수 있는 오류의 가능성을 최소화할 수 있다. (특정 모듈을 단일 스레드로 동작하도록 구현하면 데드락을 미연에 방지할 수 있다는 장점이 있다)<br/><br>읽기와 쓰기가 모두 가능한 volatile 변수를 공유해 사용할 때에는 특정 단일 스레드에서만 쓰기 작업을 하도록 구현해야 안전하다. 이런 경우 경쟁 조건을 막기 위해 ‘변경’ 작업은 특정 스레드 한 곳에서만 할 수 있도록 제한해야 하고, 읽기 작업이 가능한 다른 모든 스레드는 volatile 변수의 특성상 가장 최근에 업데이트된 값을 정확하게 읽어갈 수 있다. <br/><br>임시방편적인 스레드 한정 기법은 안정성을 완벽하게 보장할 수 있는 방법은 아니기 때문에 제한적으로 사용하고, 가능하다면 스택 한정이나 ThreadLocal 클래스 등의 좀 더 안전한 스레드 한정 기법을 사용하자</p><h3 id="3-3-2-스택-한정"><a href="#3-3-2-스택-한정" class="headerlink" title="3.3.2 스택 한정"></a>3.3.2 스택 한정</h3><p>스택 한정 기법은 특정 객체를 로컬 변수를 통해서만 사용할 수 있는 특별한 경우의 스레드 한정 기법이라고 할 수 있다. 변수를 클래스 내부에 숨겨두면 변경 상태를 관리하기가 쉬운데, 또한 클래스 내부에 숨겨둔 변수는 특정 스레드에 쉽게 한정시킬 수도 있다. 로컬 변수는 모두 암묵적으로 현재 실행 중인 스레드에 한정되어 있다고 볼 수 있다. 즉, 로컬 변수는 현재 실행 중인 스레드 내부의 스택에만 존재하기 때문이며, 스레드 내부의 스택은 외부 스레드에서 물론 볼 수 없다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadTheArk</span><span class="params">(Collection&lt;Animal&gt; candidates)</span> </span>&#123;</span><br><span class="line">SortedSet&lt;Animal&gt; animals;</span><br><span class="line"><span class="keyword">int</span> numPairs = <span class="number">0</span>;</span><br><span class="line">Animal candidate = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">animals = <span class="keyword">new</span> TreeSet&lt;Animal&gt;(<span class="keyword">new</span> SpeciesGenderComparator());</span><br><span class="line">animals.addAll(candidates);</span><br><span class="line"><span class="keyword">for</span> (Animal a : animals) &#123;</span><br><span class="line"><span class="keyword">if</span> (candidate == <span class="keyword">null</span> || !candidate.isPotentialMate(a))</span><br><span class="line">candidate = a;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ark.load(<span class="keyword">new</span> AnimalPair(candidate, a));</span><br><span class="line">++numPairs;</span><br><span class="line">candidate = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> numPairs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>예제 코드의 loadTheArk 메서드 내부의 numPairs 와 같이 기본 변수형을 사용하는 로컬 변수는 일부러 하려고 해도 스택 한정 상태를 깰 수 없다. 기본 변수형은 참조 값이 아니기 때문에 기본 변수형 로컬 변수는 언어적으로 스택 한정 상태가 보장된다. <br/><br>객체형 변수가 스택 한정 상태를 유지할 수 있게 하려면 해당 객체에 대한 참조가 외부로 유출되지 않도록 개발자가 주의를 기울여야 한다. 예제 코드의 loadTheArk 메서드에서 animal 변수는 TreeSet 클래스의 인스턴스를 참조하고 있다. 그러면 지금까지는 TreeSet 인스턴스에 대한 참조가 정확하게 하나만 존재하며, 또한 로컬 변수에 보관하고 있기 때문에 현재 실행 중인 스레드의 스택에 안전하게 한정되어 있다. 하지만 TreeSet 인스턴스에 대한 참조를 외부에 공개한다면 스택 한정 상태가 깨질수 밖에 없다.<br/><br>스레드에 안전하지 않은 객체라 해도 특정 스레드 내부에서만 동작한다면 동기화 문제가 없기 때문에 안전하다. 하지만 해당 객체를 현재 스레드에 한정해야 한다는 요구사항과 해당 객체가 스레드에 안전하지 않다는 점은 대부분 코드를 처음 작성했던 개발자만 인식할 뿐, 후임 개발자는 전달받지 못하는 경우가 많다. 따라서 이런 점을 명확하게 정리해 누구든지 알아볼 수 있도록 표시해 두는 것이 좋다. </p><h3 id="3-3-3-ThreadLocal"><a href="#3-3-3-ThreadLocal" class="headerlink" title="3.3.3 ThreadLocal"></a>3.3.3 ThreadLocal</h3><p>ThreadLocal 클래스에는 get 과 set 메서드가 있는데 호출하는 스레드마다 다른 값을 사용할 수 있도록 관리해준다. 다시 말해 ThreadLocal 클래스의 get 메서드를 호출하면 현재 실행 중인 스레드에서 최근에 set 메서드를 호출해 저장했던 값을 가져올 수 있다. 스레드 로컬 변수는 변경 가능한 싱글턴이나 전역 변수 등을 기반으로 설계되어 있는 구조에서 변수가 임의로 공유되는 상황을 막기 위해 사용되는 경우가 많다. 개념적으로 본다면 ThreadLocal<T> 클래스는 Map&lt;Thread, T&gt; 라는 자료 구조로 구성되어 있고, Map&lt;Thread, T&gt;에 스레드별 값을 보관한다고 생각할 수 있겠다. <br/><br>만약 원래 단일 스레드에서 동작하던 기능을 멀티스레드 환경으로 구성해야 할 때, 그 의미에 따라 다르지만 공유된 전역 변수를 ThreadLocal 을 활용하도록 변경하면 스레드 안정성을 보장할 수 있다. <br/><br>ThreadLocal 클래스는 애플리케이션 프레임웍을 구현할 때 상당히 많이 사용되는 편이다. 예를들어 J2EE 컨테이너는 EJB 를 사용하는 동안 해당 스레드와 트랜잭션 컨텍스트를 연결해 관리한다. 이처럼 스레드 단위로 트랜잭션 컨텍스트를 관리하고자 할 때는 static 으로 선언된 ThreadLocal 변수에 트랜잭션 컨텍스트를 넣어두면 편리하다. 만약 프레임웍에서 현재 진행중인 트랜잭션이 어느 것인지 확인하고 싶다면 트랜잭션이 보관되어 있는 ThreadLocal 에서 쉽게 찾아낼 수 있다. 이런 방법을 사용하면 메서드를 호출할 때마다 현재 실행 중인 스레드의 정보를 넘겨줘야 할 필요는 없지만, 이런 방법을 사용하는 코드는 해당 프레임웍에 대한 의존성을 갖게 된다. <br/><br>이렇게 편리하긴 하지만, 전역 변수가 아니면서도 전역 변수처럼 동작하기 때문에 프로그램 구조상 전역 변수를 남발하는 결과를 가져올 수도 있고, 따라서 메서드에 당연히 인자로 넘겨야할 값을 ThreadLocal 을 통해 뒤로 넘겨주는 방법을 사용하면서 프로그램의 구조가 허약해질 가능성도 높다. </p><h2 id="3-4-불변성"><a href="#3-4-불변성" class="headerlink" title="3.4 불변성"></a>3.4 불변성</h2><p>만약 객체의 상태가 변하지 않는다고 가정하면 어떨까? 지금까지 발생했던 복잡하고도 다양한 문제가 일순간에 사라진다.<br/><br>불변 객체는 맨 처음 생성되는 시점을 제외하고는 그 값이 전혀 바뀌지 않는 객체를 말한다. 다시 말해 불변 객체의 변하지 않는 값은 처음 만들어질 때 생성 메서드에서 설정하고, 상태를 바꿀 수 없기 때문에 맨 처음 설정된 값이 나중에도 바뀌지 않는다. 따라서 불변 객체는 태생부터 스레드에 안전한 상태다.</p><blockquote><p>불변 객체는 언제라도 스레드에 안전하다.</p></blockquote><p>불변 객체는 만들기도 쉽고 훨씬 안전하다. 객체 내부의 값을 마음대로 변경할 수 있다면, 객체를 제 3자가 만든 코드에 넘겨주거나 외부의 라이브러리가 볼 수 있는 범위에 공개되어 있다면 굉장히 위험한 상태에 이를 수도 있다. 반대로 불변 객체는 제 3자가 만들어 검증되지 않고 오류가 많거나 심지어는 악의를 갖고 만든 악성 코드가 가져다 사용한다 해도 값을 변경할 수 없다. <br/><br>다음의 조건을 만족하면 해당 객체는 불변 객체다.</p><ol><li>생성되고 난 이후에는 객체의 상태를 변경할 수 없다.</li><li>내부의 모든 변수는 final 로 설정돼야 한다.</li><li>적절한 방법으로 생성돼야 한다. (예를 들어 this 변수에 대한 참조가 외부로 유출되지 않아야 한다)</li></ol><p>아래는 일반 객체를 사용해 불변 객체를 구성한 예제 코드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeStooges</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; stooges = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreeStooges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">stooges.add(<span class="string">&quot;Moe&quot;</span>);</span><br><span class="line">stooges.add(<span class="string">&quot;Larry&quot;</span>);</span><br><span class="line">stooges.add(<span class="string">&quot;Curly&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStooge</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> stooges.contains(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이름을 저장해두는 Set 변수는 변경 가능한 객체이지만, ThreeStooges 클래스의 구조를 보면 생성 메서드를 실행한 이후에는 Set 변수의 값을 변경할 수 없도록 되어 있다. 그리고 stooges 변수는 final 로 선언되어 있기 때문에 객체의 모든 상태는 final 변수를 통해 사용할 수 밖에 없다. 마지막으로 생성 메서드에서 this 변수에 대한 참조가 외부로 유출될 만한, 즉 호출한 클래스나 생성 메서드 이외의 부분에서 참조를 가져갈 수 있는 일을 전혀 하고 있지 않기 때문에 ThreeStooges 클래스는 불변 객체라고 볼 수 있다. </p><h3 id="3-4-1-final-변수"><a href="#3-4-1-final-변수" class="headerlink" title="3.4.1 final 변수"></a>3.4.1 final 변수</h3><p>final 키워드를 적절하게 사용하면 초기화 안정성을 보장하기 때문에 별다른 동기화 작업 없이도 불변 객체를 자유롭게 사용하고 공유할 수 있다. </p><blockquote><p>외부에서 반드시 사용할 일이 없는 변수는 private 으로 선언하는 게 괜찮은 방법인 만큼 나중에 변경할 일이 없다고 판단되는 변수는 final 로 선언해두는 것도 좋은 방법이다.</p></blockquote><h3 id="3-4-2-예제-불변-객체를-공개할-때-volatile-키워드-사용"><a href="#3-4-2-예제-불변-객체를-공개할-때-volatile-키워드-사용" class="headerlink" title="3.4.2 예제: 불변 객체를 공개할 때 volatile 키워드 사용"></a>3.4.2 예제: 불변 객체를 공개할 때 volatile 키워드 사용</h3><p>여러 개의 변수 값을 서로 읽거나 쓰는 과정에 경쟁 조건이 발생할 수 있는데, 불변 객체 안에 해당하는 변수를 모두 모아두면 경쟁 조건을 방지할 수 있다. 여러 개의 변수를 묶어 사용하고자 할 때, 불변 객체가 아닌 일반 객체를 만들어 사용하면 락을 사용해야 연산의 단일성을 보장할 수 있다. 하지만 불변 객체에 변수를 묶어두면 특정 스레드가 불변 객체를 사용할 때 다른 스레드가 불변 객체 값을 변경하지 않을까 걱정하지 않아도 된다. 만약 불변 객체 내부에 들어 있는 변수 값을 변경하면 새로운 불변 객체가 만들어지기 때문에, 기존에 변수 값이 변경되기 전의 불변 객체를 사용하는 다른 스레드는 아무런 이상 없이 계속 동작한다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneValueCache</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BigInteger lastNumber;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BigInteger[] lastFactors;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OneValueCache</span><span class="params">(BigInteger i, BigInteger[] factors)</span> </span>&#123;</span><br><span class="line">lastNumber = i;</span><br><span class="line">lastFactors = Arrays.copyOf(factors, factors.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> BigInteger[] getFactors(BigInteger i) &#123;</span><br><span class="line"><span class="keyword">if</span> (lastNumber == <span class="keyword">null</span> || !lastNumber.equals(i))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> Arrays.copyOf(lastFactors, lastFactors.length);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileCachedFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> OneValueCache cache = <span class="keyword">new</span> OneValueCache(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class="line">BigInteger i = extractFromRequest(req);</span><br><span class="line">BigInteger[] factors = cache.getFactors(i);</span><br><span class="line"><span class="keyword">if</span> (factors == <span class="keyword">null</span>) &#123;</span><br><span class="line">factors = factor(i);</span><br><span class="line">cache = <span class="keyword">new</span> OneValueCache(i, factors);</span><br><span class="line">&#125;</span><br><span class="line">encodeIntoResponse(resp, factors);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OneValueCache 클래스가 불변인데다 cache 변수를 사용하는 코드에서는 cache 변수를 정확하게 한 번씩만 사용하기 때문에 캐시와 관련된 연산은 전혀 혼동되거나 섞이지 않는다. VolatileCachedFactorizer 클래스는 변경할 수 없는 상태 값을 여러 개 갖고 있는 불변 객체인데다 volatile 키워드를 적용해 시간적으로 가시성을 확보하기 때문에 따로 락을 사용하지 않았다 해도 스레드에 안전하다.</p><h2 id="3-5-안전-공개"><a href="#3-5-안전-공개" class="headerlink" title="3.5 안전 공개"></a>3.5 안전 공개</h2><p>지금까지는 객체를 특정 스레드에 한정하거나 다른 객체 내부에 넣을 때, 객체를 공개하지 않고 확실하게 숨기는 방법에 대해 살펴봤다. 하지만 상황에 따라 여러 스레드에서 공유하도록 공개해야 할 상황일 수 있는데, 이럴 때는 반드시 안전한 방법을 사용해야 한다. 아래의 예제는 안전하지 않은 공개 방법의 예시이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Holder holder;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">holder = <span class="keyword">new</span> Holder(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>예제 코드는 가시성 문제 때문에 Holder 클래스가 안정적이지 않은 상태에서 외부 스레드에게 노출될 수 있으며, 심지어는 생성 메서드에서 내부의 고정된 값을 정상적으로 설정한 이후에도 문제가 된다. 이렇게 단순한 방법으로 객체를 외부에 공개하면 생성 메서드가 채 끝나기도 전에 공개된 객체를 다른 스레드가 사용할 수 있다.</p><h3 id="3-5-1-적절하지-않은-공개-방법-정상적인-객체도-문제를-일으킨다"><a href="#3-5-1-적절하지-않은-공개-방법-정상적인-객체도-문제를-일으킨다" class="headerlink" title="3.5.1 적절하지 않은 공개 방법: 정상적인 객체도 문제를 일으킨다"></a>3.5.1 적절하지 않은 공개 방법: 정상적인 객체도 문제를 일으킨다</h3><p>객체의 생성 메서드가 제대로 완료되지 않은 상태의 인스턴스를 다른 스레드가 사용하려 한다면 비정상적인 상태임에도 불구하고 그대로 사용하게 될 가능성이 있고, 나중에 생성 메서드가 제대로 끝나고 보니 공개한 이후에 값이 바뀐 적이 없음에도 불구하고 처음 사용할 때와는 값이 다른 경우도 생긴다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.n = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assertSannity</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n != n) </span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">&quot;This statement is false&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Holder 객체를 다른 스레드가 사용할 수 있도록 코드를 작성하면서 적절한 동기화 방법을 적용하지 않았으므로 Holder 클래스는 올바르게 공개되지 않았다고 할 수 있다. 이 때 두 가지 문제가 발생할 수 있는데, 첫 번째 문제는 Holder 변수에 스테일 상태가 발생할 수 있는 것이고, 두 번째 문제는 다른 스레드는 모두 Holder 변수에서 정상적인 참조 값을 가져갈 수 있지만 Holder 클래스의 입장에서는 스테일 상태에 빠질 수 있다는 것이다. <br/><br>다시 한 번 강조하지만, 특정 데이터를 여러 개의 스레드에서 사용하도록 공유할 때 적절한 동기화 방법을 적용하지 않는다면 굉장히 이상한 일이 발생할 가능성이 높다는 점을 알아두자</p><h3 id="3-5-2-불변-객체와-초기화-안전성"><a href="#3-5-2-불변-객체와-초기화-안전성" class="headerlink" title="3.5.2 불변 객체와 초기화 안전성"></a>3.5.2 불변 객체와 초기화 안전성</h3><p>데이터를 여러 스레드가 공유하는 환경에서는 불변 객체가 굉장히 중요한 위치를 차지하기 때문에, 자바 메모리 모델에는 불변 객체를 공유하고자 할 때 초기화 작업을 안전하게 처리할 수 있는 방법이 만들어져 있다. 특정 객체에 대한 참조를 클래스 외부에서 볼 수 있다 해도 외부 스레드 입장에서 항상 정상적인 참조 값을 사용한다는 보장이 없다. 외부 스레드에서 항상 정상적인 값을 참조하려면 동기화 방법이 필요하다. <br/><br>반면에 불변 객체를 사용하면 객체의 참조를 외부에 공개할 때 추가적인 동기화 방법을 사용하지 않았다 해도 항상 안전하게 올바른 참조 값을 사용할 수 있다. 이와 같이 안전하게 초기화 과정을 진행하려면 몇 가지 불변 객체의 요구 조건을 만족시켜야 하는데, 요구 조건으로는 1) 상태를 변경할 수 없어야 하고 2) 모든 필드의 값이 final 로 선언돼야 하며, 3) 적절한 방법으로 생성해야 한다. </p><blockquote><p>불변 객체는 별다른 동기화 방법을 적용하지 않았다 해도 어느 스레드에서건 마음껏 안전하게 사용할 수 있다. 불변 객체를 공개하는 부분에 동기화 처리를 하지 않았다 해도 아무런 문제가 없다.</p></blockquote><h3 id="3-5-3-안전한-공개-방법의-특성"><a href="#3-5-3-안전한-공개-방법의-특성" class="headerlink" title="3.5.3 안전한 공개 방법의 특성"></a>3.5.3 안전한 공개 방법의 특성</h3><p>불변 객체가 아닌 객체는 모두 올바른 방법으로 안전하게 공개해야 하며, 대부분은 공개하는 스레드와 불러다 사용하는 스레드 양쪽 모두에 동기화 방법을 적용해야 한다. </p><p>객체를 안전하게 공개하려면 해당 객체에 대한 참조와 객체 내부의 상태를 외부의 스레드에게 동시에 볼 수 있어야 한다.<br>올바르게 생성 메서드가 실행되고 난 객체는 다음과 같은 방법으로 안전하게 공개할 수 있다.</p><ul><li>객체에 대한 참조를 static 메서드에서 초기화한다</li><li>객체에 대한 참조를 volatile 변수 또는 AtomicReference 클래스에 보관한다</li><li>객체에 대한 참조를 올바르게 생성된 클래스 내부의 final 변수에 보관한다</li><li>락을 사용해 올바르게 막혀 있는 변수에 객체에 대한 참조를 보관한다</li></ul><p>자바에서 기본으로 제공하는 스레드 안전한 컬렉션은 다음과 같은 스레드 동기화 기능을 갖고 있다. </p><ul><li>HashTable, ConcurrentMap, synchronizedMap 을 사용해 만든 Map 객체를 사용하면 그 안에 보관하고 있는 키와 값 모두를 어느 스레드에서라도 항상 안전하게 사용할 수 있다.</li><li>객체를 Vector, CopyOnWriteArrayList, CopyOnWriteArraySet 이나 synchronizedList 또는 synchronizedSet 메서드로 만든 컬렉션은 그 안에 보관하고 있는 객체를 어느 스레드에서라도 항상 안전하게 사용할 수 있다.</li><li>BlockingQueue 나 ConcurrentLinkedQueue 컬렉션에 들어 있는 객체는 어느 스레드라도 항상 안전하게 사용할 수 있다.</li></ul><p>다음과 같이 static 변수를 선언할 때 직접 new 연산자로 생성 메서드를 실행해 객체를 생성할 수 있다면 가장 쉬우면서도 안전한 객체 공개 방법이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Holder holder = <span class="keyword">new</span> Holder(<span class="number">42</span>);</span><br></pre></td></tr></table></figure><p>static 초기화 방법은 JVM 에서 클래스를 초기화하는 시점에 작업이 모두 진행된다. 그런데 JVM 내부에서 동기화가 맞춰져 있기 때문에 이런 방법으로 객체를 초기화하면 객체를 안전하게 공개할 수 있다.</p><h3 id="3-5-4-결과적으로-불변인-객체"><a href="#3-5-4-결과적으로-불변인-객체" class="headerlink" title="3.5.4 결과적으로 불변인 객체"></a>3.5.4 결과적으로 불변인 객체</h3><p>처음 생성한 이후에 그 내용이 바뀌지 않도록 만들어진 클래스에 안전한 공개 방법을 사용하면, 별다른 동기화 방법 없이도 다른 스레드에서 얼마든지 사용해도 아무런 문제가 발생하지 않는다. 다시 설명하면, 특정 객체를 안전한 방법으로 공개했을 경우, 해당 객체에 대한 참조를 갖고 객체를 불러와 사용하는 시점에는 공개하는 시점의 객체 상태를 정확하게 사용할 수 있고, 해당 객체 내부의 값이 바뀌지 않는 한 여러 스레드에서 동시에 값을 가져다 사용해도 동기화 문제가 발생하지 않는다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, Date&gt; lastLogin </span><br><span class="line">                    = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;String, Date&gt;());</span><br></pre></td></tr></table></figure><p>위와 같은 코드에서 Map에 한 번 들어간 Date 인스턴스의 값이 더 이상 바뀌지 않는다면 synchronizedMap 메서드를 사용하는 것만으로 동기화 작업이 충분하며, 그 안의 값을 사용할 때에도 추가적인 동기화 코드를 만들어야 할 필요가 없다.</p><h3 id="3-5-5-가변-객체"><a href="#3-5-5-가변-객체" class="headerlink" title="3.5.5 가변 객체"></a>3.5.5 가변 객체</h3><p>가변 객체(mutable object)를 사용할 때에는 공개하는 부분과 가변 객체를 사용하는 모든 부분에서 동기화 코드를 작성해야만 한다. 그래야 객체 내용이 바뀌는 상황을 정확하게 인식하고 사용할 수 있다. 가변 객체를 안전하게 사용하려면 안전하게 공개해야만 하고, 또한 동기화와 락을 사용해 스레드 안전성을 확보해야만 한다.</p><p>가변성에 따라 객체를 공개할 때 필요한 점을 살펴보면 다음과 같다.</p><ul><li>불변 객체는 어떤 방법으로 공개해도 아무런 문제가 없다.</li><li>결과적으로 불변인 객체는 안전하게 공개해야 한다.</li><li>가변 객체는 안전하게 공개해야 하고, 스레드에 안전하게 만들거나 락으로 동기화 시켜야 한다</li></ul><h3 id="3-5-6-객체를-안전하게-공유하기"><a href="#3-5-6-객체를-안전하게-공유하기" class="headerlink" title="3.5.6 객체를 안전하게 공유하기"></a>3.5.6 객체를 안전하게 공유하기</h3><p>언제든 객체에 대한 참조를 가져다 사용하는 부분이 있다면, 그 객체로 어느 정도의 일을 할 수 있는지를 정확하게 알고 있어야 한다. 객체를 사용하기 전에 동기화 코드를 적용해 락을 확보해야 하는지? 객체 내부의 값을 바꿔도 괜찮은지, 아니면 값을 알기만 해야 하는지? 대부분의 동기화 오류는 이와 같이 일반적인 몇 가지 수칙을 제대로 이해하지 못하고 프로그램을 작성하는 데서 싹트기 시작한다. 또한, 반대로 객체를 일부에서 사용할 수 있도록 공개할 때에는 해당 객체를 어떤 방법으로 사용할 수 있고, 사용해야 하는지에 대해서 정확하게 설명해야 한다.</p><p>여러 스레드를 동시에 사용하는 병렬 프로그래밍에서 객체를 공유해 사용하고자 할 때 가장 많이 사용되는 몇 가지 원칙을 살펴보면 다음과 같다.</p><ul><li>스레드 한정: 스레드에 한정된 객체는 완전하게 해당 스레드 내부에 존재하면서도 그 스레드에서만 호출해 사용할 수 있다</li><li>읽기 전용 객체를 공유: 읽기 전용 객체를 공유해 사용하면 동기화 작업을 하지 않더라도 여러 스레드에서 언제든지 마음껏 읽어 사용할 수 있다</li><li>스레드에 안전한 객체를 공유: 스레드에 안전한 객체는 객체 내부적으로 필수적인 동기화 기능이 만들어져 있기 때문에 외부에서 동기화를 신경 쓸 필요 없이 여러 스레드에서 마음껏 호출해 사용할 수 있다</li><li>동기화 방법 적용: 특정 객체에 동기화 방법을 적용해두면 지정한 락을 획득하기 전에는 해당 객체를 사용할 수 없다</li></ul>]]></content:encoded>
      
      <comments>https://daniel-hebn.github.io/2017/12/17/2017-12-17-%EC%9E%90%EB%B0%94-%EB%B3%91%EB%A0%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-3%EC%9E%A5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>자바 병렬 프로그래밍(1~2장)</title>
      <link>https://daniel-hebn.github.io/2017/12/17/2017-12-17-%EC%9E%90%EB%B0%94-%EB%B3%91%EB%A0%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-1-2%EC%9E%A5/</link>
      <guid>https://daniel-hebn.github.io/2017/12/17/2017-12-17-%EC%9E%90%EB%B0%94-%EB%B3%91%EB%A0%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-1-2%EC%9E%A5/</guid>
      <pubDate>Sun, 17 Dec 2017 08:53:45 GMT</pubDate>
      <description>
      
        
        
          &lt;img src=&quot;/images/logo/java_concurrency_book.png&quot;/&gt;&lt;h1 id=&quot;1장-개요&quot;&gt;&lt;a href=&quot;#1장-개요&quot; class=&quot;headerlink&quot; title=&quot;1장 개요&quot;&gt;&lt;/a&gt;1장 개요&lt;/h1&gt;&lt;h2 id=&quot;1-
        
      
      </description>
      
      
      <content:encoded><![CDATA[<img src="/images/logo/java_concurrency_book.png"/><h1 id="1장-개요"><a href="#1장-개요" class="headerlink" title="1장 개요"></a>1장 개요</h1><h2 id="1-1-작업을-동시에-실행하는-일에-대한-간략한-역사"><a href="#1-1-작업을-동시에-실행하는-일에-대한-간략한-역사" class="headerlink" title="1.1 작업을 동시에 실행하는 일에 대한 간략한 역사"></a>1.1 작업을 동시에 실행하는 일에 대한 간략한 역사</h2><p>스레드는 멀티프로세서 시스템의 능력을 최대한 끌어낼 수 있는 가장 쉬운 방법이다.</p><p>프로세스는 각자가 서로 격리된 채로 독립적으로 실행되는 프로그램으로서 운영체제는 프로세스마다 메모리, 파일 핸들, 보안 권한 등의 자원을 할당한다.</p><p>스레드는 메모리, 파일 핸들과 같이 프로세스에 할당된 자원을 공유한다. 하지만 각 스레드는 각기 별도의 프로그램 카운터, 스택, 지역 변수를 갖는다.</p><p>또한 프로그램을 스레드로 분리하면 멀티프로세서 시스템에서 자연스럽게 하드웨어 병렬성을 이용할 수 있다. 즉, 한 프로그램 내 여러 스레드를 동시에 여러 개의 CPU 에 할당해 실행시킬 수 있다.</p><p>스레드는 자신이 포함된 프로세스의 메모리 주소 공간을 공유하기 때문에 한 프로세스 내 모든 스레드는 같은 변수에 접근하고 같은 힙(heap) 에 객체를 할당한다.</p><h2 id="1-2-스레드의-이점"><a href="#1-2-스레드의-이점" class="headerlink" title="1.2 스레드의 이점"></a>1.2 스레드의 이점</h2><p>개발 및 유지 보수 비용을 줄이고 복잡한 애플리케이션의 성능을 향상시킬 수 있다. 비동기적인 일 흐름을 거의 순차적으로 바꿀 수 있어 사람이 일하고 상호 작용하는 방식을 모델링하기 쉬워진다. </p><ul><li>멀티프로세서 활용 - 프로세서 스케쥴링의 기본 단위는 스레드이기 때문에 스레드 하나로 동작하는 프로그램은 한 번에 최대 하나의 프로세서만 사용한다. 따라서 멀티스레드 프로그램은 가용한 프로서세 자원을 더 효율적으로 활용하여 처리 속도를 높이는 것임</li><li>단순한 모델링 - 복잡하면서 비동기적인 작업 흐름을 각기 별도 스레드에서 수행되는 더 단순하고 동기적인 작업 흐름 몇 개로 나눌 수 있다. 이런 작업 흐름에서는 특정한 동기화 시점에서만 상호 작용이 발생한다.</li><li>단순한 비동기 이벤트 처리 - 여러 클라이언트 프로그램에서 소켓 연결을 받는 서버 애플리케이션의 경우 각 연결마다 스레드를 할당하고 동기 I/O 를 사용하도록 하면 개발 작업이 쉬워진다. </li><li>더 빨리 반응하는 사용자 인터페이스</li></ul><h2 id="1-3-스레드-사용의-위험성"><a href="#1-3-스레드-사용의-위험성" class="headerlink" title="1.3 스레드 사용의 위험성"></a>1.3 스레드 사용의 위험성</h2><ul><li>안정성 위해 요소 - 여러 스레드에서 실행되는 연산의 순서는 때로는 놀라울 만큼 예측하기가 어렵다.<br>스레드는 서로 같은 메모리 주소 공간을 공유하고 동시에 실행되기 때문에 다른 스레드가 사용 중일지도 모르는 변수를 읽거나 수정할 수도 있다. ex) value++ 연산을 멀티 스레드로 구현했을 때 </li><li>활동성 위험 - 단일 스레드 프로그램에서는 발생하지 않는 추가적인 안정성 위험에 노출될 수 있고 또한 추가적인 형태의 활동성 장애가 발생할 수 있다. ex) deadlock, starvation, livelock </li><li>성능 위험 - 스레드가 많은 프로그램에서는 컨텍스트 스위칭이 더 빈번하고, 그 때문에 상당한 부담이 생긴다. </li></ul><h2 id="1-4-스레드는-어디에나"><a href="#1-4-스레드는-어디에나" class="headerlink" title="1.4 스레드는 어디에나"></a>1.4 스레드는 어디에나</h2><p>모든 자바 프로그램은 기본적으로 스레드를 사용한다. JVM 을 시작시키면 main 메서드를 실행할 주 스레드 뿐 아니라 가비지 컬렉션이나 객체 종료(object finalization) 와 같은 JVM 내부 작업을 담당할 스레드도 생성한다. 프레임웍 때문에 프로그림이 병렬로 실행되는 경우가 생기면 병렬로 실행된다는 사실을 프레임웍 뿐만 아니라 프로그램에서도 인식하고 적절히 대응해야 한다. </p><ul><li>타이머(Timer)</li><li>서블릿과 JSP</li><li>원격 메서드 호출(RMI)</li><li>스윙과 AWT </li></ul><h1 id="2장-스레드-안정성"><a href="#2장-스레드-안정성" class="headerlink" title="2장 스레드 안정성"></a>2장 스레드 안정성</h1><p>스레드에 안전한 코드를 작성하는 것은 근본적으로는 <strong>상태</strong>, 즉 <strong>공유되고 변경할 수 있는 상태에 대한 접근을 관리하는 것</strong>이다.</p><p>객체의 상태는 인스턴스나 static 변수 같은 상태 변수에 저장된 객체의 데이터다. 공유됐다는 것은 여러 스레드가 특정 변수에 접근할 수 있다는 뜻이고, 변경할 수 있다(mutable)는 것은 해당 변수 값이 변경될 수 있다는 뜻이다.</p><p>스레드 안정성이란 데이터에 제어 없이 동시 접근하는 것을 막으려는 의미임을 알아두자. 객체를 스레드 안전하게 만들려면 동기화를 통해 변경할 수 있는 상태에 접근하는 과정을 조율해야 한다.</p><p>스레드가 하나 이상 상태 변수에 접근하고 그 중 하나라도 변수에 값을 쓰면, 해당 변수에 접근할 때 관련된 모든 스레드가 동기화를 통해 조율해야 한다. 자바에서 제공하는 동기화 기본 수단은 synchronized, volatile 변수, 명시적 락, 단일 연산 변수(atomic variable) 등이 있다.</p><p>만약 여러 스레드가 변경할 수 있는 하나의 상태 변수를 적절한 동기화 없이 접근하면 그 프로그램은 잘못된 것이다. 이런 잘못된 프로그램을 고치는 데는 세 가지 방법이 있다.</p><ul><li>해당 상태 변수를 스레드 간에 공유하지 않거나</li><li>해당 상태 변수를 변경할 수 없도록 만들거나</li><li>해당 상태 변수에 접근할 땐 언제나 동기화를 사용한다.</li></ul><p>(당연한 이야기지만) 스레드 안정성을 확보하기 위해 나중에 클래스를 고치는 것보다는 애당초 스레드에 안전하게 설계하는 편이 훨씬 쉽다. 프로그램 상태를 잘 캡슐화할수록 프로그램을 스레드에 안전하게 만들기 쉽고 유지 보수 팀에서도 역시 해당 프로그램이 계속해서 스레드에 안전하도록 유지하기 쉽다.</p><blockquote><p>스레드 안전한 클래스를 설계할 땐, 바람직한 객체 지향 기법이 왕도다.<br>캡슐화와 불변 객체를 잘 활용하고, 불변 조건을 명확하게 기술해야 한다.</p></blockquote><h2 id="2-1-스레드-안정성이란"><a href="#2-1-스레드-안정성이란" class="headerlink" title="2.1 스레드 안정성이란?"></a>2.1 스레드 안정성이란?</h2><p>여러 스레드가 클래스에 접근할 때 계속 정확하게 동작하면 해당 클래스는 스레드에 안전하다. 어떻게 스케쥴하든 어디에 끼워 넣든, 호출하는 쪽에서 추가적인 동기화나 다른 조율 없이도 정확하게 동작하면 해당 클래스는 스레드 안전하다고 말한다. 또한 스레드 안전한 클래스는 클라이언트 쪽에서 별도로 동기화할 필요가 없도록 동기화 기능도 캡슐화한다.</p><h3 id="2-1-1-예제-상태-없는-서블릿"><a href="#2-1-1-예제-상태-없는-서블릿" class="headerlink" title="2.1.1 예제: 상태 없는 서블릿"></a>2.1.1 예제: 상태 없는 서블릿</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatelessFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class="line">        BigInteger i = extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = factor(i);</span><br><span class="line">        encodeIntoResponse(resp, factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StatelessFactorizer 는 대부분의 서블릿처럼 상태가 없다. 즉, 선언한 변수가 없고 다른 클래스의 변수를 참조하지도 않는다. 특정 계산을 위한 일시적인 상태는 스레드의 스택에 저장되는 지역 변수에만 저장하고, 실행하는 해당 스레드에서만 접근할 수 있다.</p><p>따라서 두 스레드가 상태를 공유하지 않기 대문에 사실상 서로 다른 인스턴스에 접근하는 것과 같다.</p><blockquote><p>상태 없는 객체는 항상 스레드 안전하다.</p></blockquote><h2 id="2-2-단일-연산"><a href="#2-2-단일-연산" class="headerlink" title="2.2 단일 연산"></a>2.2 단일 연산</h2><h3 id="2-2-1-경쟁-조건"><a href="#2-2-1-경쟁-조건" class="headerlink" title="2.2.1 경쟁 조건"></a>2.2.1 경쟁 조건</h3><p>병렬 프로그램의 입장에서 타이밍이 안 좋을 때 결과가 잘못될 가능성은 굉장히 중요한 개념이기 때문에 경쟁 조건(race condition)이라는 별도 용어로 정의한다.</p><p>가장 일반적인 경쟁 조건 형태는 잠재적으로 유효하지 않은 값을 참조해서 다음에 뭘 할지를 결정하는 점검 후 행동 형태의 구문이다. (check-then-act)</p><p>어떤 사실을 확인하고 그 관찰에 기반해 행동을 한다. 하지만 해당 관찰은 관찰한 시각과 행동한 시각 사이에 더 이상 유효하지 않게 되었을 수도 있다. ex) 스벅에서 친구 만나기</p><h3 id="2-2-2-예제-늦은-초기화-시-경쟁-조건"><a href="#2-2-2-예제-늦은-초기화-시-경쟁-조건" class="headerlink" title="2.2.2 예제: 늦은 초기화 시 경쟁 조건"></a>2.2.2 예제: 늦은 초기화 시 경쟁 조건</h3><p>점검 후 행동하는 흔한 프로그래밍 패턴으로 늦은 초기화(lazy initialization)가 있다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInitRace</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> ExpensiveObject instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ExpensiveObject <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> ExpensiveObject();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 경쟁 조건 때문에 의도대로 동작하지 않을 가능성이 있다. </p><h3 id="2-2-3-복합-동작"><a href="#2-2-3-복합-동작" class="headerlink" title="2.2.3 복합 동작"></a>2.2.3 복합 동작</h3><p>경쟁 조건을 피하려면 변수가 수정되는 동안 다른 스레드가 해당 변수를 사용하지 못하도록 막을 방법이 있어야 하며, 이런 방법으로 보호해두면 특정 스레드에서 변수를 수정할 때 다른 스레드는 수정 도중이 아닌 수정 이전이나 이후에만 상태를 읽거나 변경을 가할 수 있다.</p><blockquote><p>작업 A를 실행 중인 스레드 관점에서 다른 스레드가 작업 B를 실행할 때<br>작업 B가 모두 수행됐거나 또는 전혀 수행되지 않은 두가지 상태로만 파악된다면<br>작업 A의 눈으로 볼 때 작업 B는 단일 연산이다.</p></blockquote><p>스레드 안정성을 보장하기 위해 점검 후 행동과 읽고 수정하고 쓰기 등의 작업은 항상 단일 연산이어야 한다. 이런 일련의 동작을 복합 동작(compound action) 이라고 한다. 즉, 스레드에 안전하기 위해서는 전체가 단일 연산으로 실행돼야 하는 일련의 동작을 지칭한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong count = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> count.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class="line">BigInteger i = extractFromRequest(req);</span><br><span class="line">BigInteger[] factors = factor(i);</span><br><span class="line">count.incrementAndGet();</span><br><span class="line">encodeIntoResponse(resp, factors);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java.util.concurrent.atomic 패키지에는 숫자나 객체 참조 값에 대해 상태를 단일 연산으로 변경할 수 있도록 단일 연산 변수(atomic variable) 클래스가 준비돼 있다. 상태 없는 클래스에 상태 요소를 하나 추가할 때 스레드 안전한 객체 하나로 모든 상태를 관리한다면 해당 클래스는 스레드에 안전하다. 하지만 지금처럼 상태가 없다가 하나가 추가되는 경우보다 상태가 하나가 아닌 둘 이상이 될 때는 구현이 더 복잡해질 수 있다.</p><h2 id="2-3-락"><a href="#2-3-락" class="headerlink" title="2.3 락"></a>2.3 락</h2><p>아래의 코드는 입력한 숫자를 인수분해하여 입력한 숫자과 인수분해 결과를 캐시하여 보관하는 코드이다. AtomicLong 등의 변수를 사용하여 스레드 안정성을 확보한 코드처럼 보이지만 사실은 Thread 안전하지 않은 코드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeCachingFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;BigInteger&gt; lastNumber = <span class="keyword">new</span> AtomicReference&lt;BigInteger&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;BigInteger[]&gt; lastFactors = <span class="keyword">new</span> AtomicReference&lt;BigInteger[]&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class="line">BigInteger i = extractFromRequest(req);</span><br><span class="line"><span class="keyword">if</span> (i.equals(lastNumber.get())) &#123;</span><br><span class="line">encodeIntoResponse(resp, lastFactors.get());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">BigInteger[] factors = factor(i);</span><br><span class="line">lastNumber.set(i);</span><br><span class="line">lastFactors.set(factors);</span><br><span class="line">encodeIntoResponse(resp, factors);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>스레드 안정성의 정의에 따르면 여러 스레드에서 수행되는 작업의 타이밍이나 스케쥴링에 따른 교차 실행과 관계 없이 불변조건이 유지돼야 스레드에 안전하다.</p><p>UnsafeCachingFactorizer 에는 인수분해 결과를 곱한 값이 lastNumber 에 캐시된 값과 같아야 한다는 불변조건이 있으며, 이와 같은 불변조건이 항상 성립해야 서블릿이 제대로 동작한다고 볼 수 있다. </p><p>여기서 만약 타이밍이 좋지 않았다면 개별적인 각 set 메서드에서는 단일 연산으로 동작하지만, lastNumber 와 lastFactors 라는 두 개의 값을 동시에 갱신하지는 못한다. 하나는 수정됐고 다른 하나는 수정되지 않은 그 시점에 여전히 취약점이 존재한다. 이 순간 다른 스레드가 값을 읽어가면 불변조건이 깨진 상태를 보게 될 것이다.</p><blockquote><p>상태를 일관성있게 유지하려면 관련 있는 변수들을 하나의 단일 연산으로 갱신해야 한다.</p></blockquote><h3 id="2-3-1-암묵적인-락"><a href="#2-3-1-암묵적인-락" class="headerlink" title="2.3.1 암묵적인 락"></a>2.3.1 암묵적인 락</h3><p>자바에서는 단일 연산 특성을 보장하기 위해 synchronized 라는 구문을 제공한다. synchronized 구문은 락으로 사용될 객체의 참조 값과 해당 락으로 보호하려는 코드 블록으로 구성된다. 메서드 선언 부분에 synchronized 키워드를 지정하면 메서드 내부의 코드 전체를 포함하면서 메서드가 포함된 클래스의 인스턴스를 락으로 사용하는 synchronized 블록을 간략하게 표현한 것으로 볼 수 있다.</p><p>모든 자바 객체는 락으로 사용할 수 있다. 이와 같이 자바에 내장된 락을 암묵적인 락(intrinsic lock) 혹은 모니터 락(monitor lock)이라고 한다. 락은 스레드가 synchronized 블록에 들어가기 전에 자동으로 확보되며 정상적으로든 예외가 발생해서든 해당 블록을 벗어날 때 자동으로 해제된다.</p><p>자바에서 암묵적인 락은 뮤텍스(mutual exclusion lock)로 동작한다. 즉, 한 번에 한 스레드만 특정 락을 소유할 수 있다. 스레드 B가 가지고 있는 락을 스레드 A가 얻으려면 A는 B가 해당 락을 놓을 때까지 기다려야 한다.</p><p>특정 락으로 보호된 코드 블록은 한 번에 한 스레드만 실행할 수 있기 때문에 같은 락으로 보호되는 서로 다른 synchronized 블록 역시 서로 다른 단일 연산으로 실행된다. 한 스레드가 synchronized 블록을 실행 중이라면 같은 락으로 보호되는 synchronized 블록에 다른 스레드가 들어와 있을 수 없다. </p><h3 id="2-3-2-재진입성"><a href="#2-3-2-재진입성" class="headerlink" title="2.3.2 재진입성"></a>2.3.2 재진입성</h3><p>스레드가 다른 스레드가 가진 락을 요청하면 해당 스레드는 대기 상태에 들어간다. 하지만 암묵적인 락은 재진입 가능(reentrant)하기 때문에 특정 스레드가 자기가 이미 획득한 락을 다시 확보할 수 있다. 재진입성은 확보 요청 단위가 아닌 스레드 단위로 락을 얻는다는 것을 의미한다. 재진입성을 구현하려면 각 락마다 확보 횟수와 확보한 스레드를 연결시켜 둔다. 확보 횟수가 0 이면 락은 해제된 상태이다. 스레드가 해제된 락을 확보하면 JVM이 락에 대한 소유 스레드를 기록하고 확보 횟수를 1로 지정한다. 같은 스레드가 락을 다시 얻으면 횟수를 증가시키고, 소유한 스레드가 synchronized 블록 밖으로 나가면 횟수를 감소시킨다. 이렇게 횟수가 0이 되면 해당 락은 해제된다.</p><p>재진입성 때문에 락의 동작을 쉽게 캡슐화할 수 있고, 객체 지향 병렬 프로그램을 개발하기가 단순해졌다. 재진입 가능한 락이 없으면 하위 클래스에서 synchronized 메서드를 제정의하고 상위 클래스의 메서드를 호출하는 단순한 코드에서도 데드락에 빠질 것이다. </p><h2 id="2-4-락으로-상태-보호하기"><a href="#2-4-락으로-상태-보호하기" class="headerlink" title="2.4 락으로 상태 보호하기"></a>2.4 락으로 상태 보호하기</h2><p>락은 자신이 보호하는 코드 경로에 여러 스레드가 순차적으로 접근하도록 한다. 보통 경쟁 조건을 피하려면 하나의 공유된 상태에 대한 복합 동작을 단일 연산으로 만들어야 한다.</p><p>하지만 단순히 복합 동작 부분을 synchronized 블록으로 감싸는 것으로는 부족하다. 특정 변수에 대한 접근을 조율하기 위해 동기화할 때는 해당 변수에 접근하는 모든 부분을 동기화해야 한다. 또한 해당 변수에 접근하는 모든 곳에서 반드시 같은 락을 사용해야 한다. </p><blockquote><p>모든 변경할 수 있는 공유 변수는 정확하게 단 하나의 락으로 보호해야 한다.<br>유지보수하는 사람이 알 수 있게 어느 락으로 보호하고 있는지를 명확하게 표시하라.</p></blockquote><p>락을 활용함에 있어 일반적인 사용 예는 먼저 모든 변경 가능한 변수를 객체 안에 캡슐화하고, 해당 객체의 암묵적인 락을 사용해 캡슐화한 변수에 접근하는 모든 코드 경로를 동기화함으로써 여러 스레드가 동시에 접근하는 상태에서 내부 변수를 보호하는 방법이다.</p><p>그런데 이런 식의 락에 대한 규칙은 새로운 메서드나 코드 경로를 추가하면서 실수로 동기화하는 걸 잊기만 해도 쉽게 무너질 수 있다.</p><p>특정 변수가 락으로 보호되면, 즉 해당 변수에 항상 락을 확보한 상태에서 접근하도록 하면, 한 번에 한 스레드만 해당 변수에 접근할 수 있다는 점을 보장할 수 있다. 클래스에 여러 상태 변수에 대한 불변조건이 있으면 불변조건에 관련된 각 변수는 모두 같은 락으로 보호돼야 한다는 추가 요구사항이 따라 붙는다.</p><blockquote><p>여러 변수에 대한 불변조건이 있으면 해당 변수들은 모두 같은 락으로 보호해야 한다.</p></blockquote><h2 id="2-5-활동성과-성능"><a href="#2-5-활동성과-성능" class="headerlink" title="2.5 활동성과 성능"></a>2.5 활동성과 성능</h2><p>synchronized 블록의 범위를 줄이면 스레드 안정성을 유지하면서 쉽게 동시성을 향상시킬 수 있다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line"><span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> BigInteger lastNumber;</span><br><span class="line"><span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> BigInteger[] lastFactors;</span><br><span class="line"><span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> <span class="keyword">long</span> hits;</span><br><span class="line"><span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> <span class="keyword">long</span> cacheHits;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">getHits</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> hits; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">double</span> <span class="title">getCacheHitRatio</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">double</span>) cacheHits / (<span class="keyword">double</span>) hits;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class="line">BigInteger i = extractFromRequest(req);</span><br><span class="line">BigInteger[] factors = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">++hits;</span><br><span class="line"><span class="keyword">if</span> (i.equals(lastNumber)) &#123;</span><br><span class="line">++cacheHits;</span><br><span class="line">factors = lastFactors.clone();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (factors == <span class="keyword">null</span>) &#123;</span><br><span class="line">factors = factor(i);</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">lastNumber = i;</span><br><span class="line">lastFactors = factors.clone();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">encodeIntoResponse(resp, factors);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>나름의 코드 해석을 적으면</p><ul><li>맴버 변수만 표시해보면 쓰기 뿐만 아니라 읽기 시에도 synchronized 처리 했음을 알 수 있다.</li><li>메서드 앞에 synchronized 를 붙일 때에는 암묵적으로 해당 클래스의 객체를 락 객체로 사용되나, 특정 영역을 sync 할 때는 this 등의 선언을 붙여줘야 한다.</li></ul><p>여기서 AtomicLong 클래스를 써도 괜찮지만 이미 synchronized 블록을 사용해 동기화하고 있으므로 별다른 장점은 없다. 성능이나 안전성 측면의 이점은 없고 혼동만 줄 뿐이다. 예시 코드는 단순성과 병렬 처리 능력 사이에 균형을 맞췄다. 락을 얻고 놓는 작업만으로도 어느 정도의 부하가 따르므로 synchronized 블록을 <strong>너무 잘게</strong> 쪼개는 일은 바람직하지 않다.</p><p>락을 사용할 땐 블록 안의 코드가 무엇을 하는지, 수행하는 데 얼마나 걸릴지를 파악해야 한다. 계산량이 많은 작업을 하거나 잠재적으로 대기 상태에 들어 갈 수 있는 작업을 하느라 락을 오래 잡고 있으면 활동성이나 성능 문제를 야기할 수 있다. </p><blockquote><p>복잡하고 오래 걸리는 계산 작업, 네트웍 작업, 사용자 입출력 작업과 같이<br>빨리 끝나지 않을 수 있는 작업 부분에서는 가능한 락을 잡지 말아라</p></blockquote>]]></content:encoded>
      
      <comments>https://daniel-hebn.github.io/2017/12/17/2017-12-17-%EC%9E%90%EB%B0%94-%EB%B3%91%EB%A0%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-1-2%EC%9E%A5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>RESTful-API-간략정리 (1)</title>
      <link>https://daniel-hebn.github.io/2017/06/23/2017-06-23-RESTful-API-%EA%B0%84%EB%9E%B5%EC%A0%95%EB%A6%AC-1/</link>
      <guid>https://daniel-hebn.github.io/2017/06/23/2017-06-23-RESTful-API-%EA%B0%84%EB%9E%B5%EC%A0%95%EB%A6%AC-1/</guid>
      <pubDate>Fri, 23 Jun 2017 08:53:03 GMT</pubDate>
      <description>
      
        
        
          &lt;img src=&quot;/images/logo/RESTful_logo.png&quot;/&gt;&lt;h1 id=&quot;개요&quot;&gt;&lt;a href=&quot;#개요&quot; class=&quot;headerlink&quot; title=&quot;개요&quot;&gt;&lt;/a&gt;개요&lt;/h1&gt;&lt;p&gt;RESTful 에 대한 워낙 좋은 글들이 많아 굳이
        
      
      </description>
      
      
      <content:encoded><![CDATA[<img src="/images/logo/RESTful_logo.png"/><h1 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h1><p>RESTful 에 대한 워낙 좋은 글들이 많아 굳이 작성할 필요는 없는 글이지만 개인적인 정리를 위해 작성한다. <br/><br>Spring MVC 를 활용하여 RESTful 개념으로 적당히 Controller 을 구현하고 구글링을 통해 여러 글들을 접하면서 <br/><br>내가 정리한 RESTful 의 장점은 크게 3가지라고 생각한다.</p><h2 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h2><ol><li>읽기 쉽다. 가장 중요하다고 생각. 읽히기 쉬운 인터페이스를 가지면 개발간에 오해 없이 빠른 개발 진행이 가능</li><li>HTTP 스펙을 최대한 활용하기 때문에, HTTP 기반이면 뭐든 사용 가능</li><li>(사실 두번째 장점의 연장성인데) 여러 플랫폼 / 여러 클라이언트를 대응할 수 있음</li></ol><h1 id="RESTful-의-규칙"><a href="#RESTful-의-규칙" class="headerlink" title="RESTful 의 규칙"></a>RESTful 의 규칙</h1><p>로이필딩이 정의한 다음의 요건을 만족해야 RESTful 하다고 말할 수 있다.</p><ul><li>클라이언트 서버 구조(Client / Server Architectural Style)</li><li>무상태(Stateless): 단, 인증/권한을 위한 내용은 실용적인 측면에서 예외가 가능함 캐시 처리 가능(Cacheable)</li><li>계층화(Layered System)</li><li>균일 인터페이스(Uniform Interface)</li><li>Code on Demand(optional)</li></ul><p>그 중 가장 중요한 규칙이라고 할 수 있는 균일 인터페이스(Uniform Interface)를 지키기 위한 중요한 2가지 요소를 적어보면 다음과 같다.</p><ul><li>리소스의 식별</li><li>리소스의 조작</li></ul><p>그 중 <strong>리소스의 식별</strong> 의 측면에서 RESTful 특징의 일부를 기술하고자 한다.</p><h2 id="리소스의-식별"><a href="#리소스의-식별" class="headerlink" title="리소스의 식별"></a>리소스의 식별</h2><p>리소스는 반드시 유일한 식별자를 가져야 한다. 따라서 웹 API의 경우 고유의 URI을 가진다. <br/><br>또한 URI 만을 통해서 해당 자원의 의미를 충분히 표현할 수 있어야 한다. <br/><br>다만, 동일한 URI 라도 HTTP method 에 따라 리소스에 관련한 작업 - 조회, 등록, 수정, 삭제를 구분하기 에 URI 자체에는 CRUD 성격의 표현이 들어가선 안 된다. <br/><br>이를 지키기 위한 간단한 디자인 팁은 다음과 같다.<br/></p><ul><li>리소스 표현(URI)에서 동사를 제거하자 </li><li>리소스 간의 관계를 표현하자 </li><li>snake-case 를 사용하자. 하이픈 활용 </li><li>확장자를 URI 에 기술하지 말자</li></ul><h3 id="1-리소스-표현-URI-에서-동사를-제거하자"><a href="#1-리소스-표현-URI-에서-동사를-제거하자" class="headerlink" title="1) 리소스 표현(URI) 에서 동사를 제거하자"></a>1) 리소스 표현(URI) 에서 동사를 제거하자</h3><p>나쁜 예 / 좋은 예를 제시하여 내용 설명을 대체한다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ex) 나쁜 예</span><br><span class="line"></span><br><span class="line">    /getAllDogs</span><br><span class="line">    /locationVerify</span><br><span class="line">    /foodNeeded</span><br><span class="line">    /createRecurringDogWalk</span><br><span class="line">    /giveDirectOrder</span><br><span class="line">    /healthCheck</span><br><span class="line">    /getRecurringDogWalkSchedule</span><br><span class="line">    /getLocation</span><br><span class="line">    /getDog</span><br><span class="line">    /massDogParty</span><br><span class="line">    /getNewDogsSince</span><br><span class="line">    /getRedDogs</span><br><span class="line">    /getSittingDogs</span><br><span class="line">    /dogStateChangesSearch</span><br><span class="line">    /replaceSittingDogsWithRunningDogs</span><br><span class="line">    /saveDog</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ex) 좋은 예</span><br><span class="line"></span><br><span class="line">    GET /tickets ‐ Retrieves a list of tickets</span><br><span class="line">    GET /tickets/12 ‐ Retrieves a specific ticket</span><br><span class="line">    POST /tickets ‐ Creates a new ticket</span><br><span class="line">    PUT /tickets/12 ‐ Updates ticket #12</span><br><span class="line">    PATCH /tickets/12 ‐ Partially updates ticket #12</span><br><span class="line">    DELETE /tickets/12 ‐ Deletes ticket #12</span><br><span class="line">    GET /tickets/new ‐ 신규 티켓 등록을 위한 form 화면 조회</span><br></pre></td></tr></table></figure><h3 id="2-리소스-간의-관계를-표현하자"><a href="#2-리소스-간의-관계를-표현하자" class="headerlink" title="2) 리소스 간의 관계를 표현하자"></a>2) 리소스 간의 관계를 표현하자</h3><p>보통 리소스는 리소스 독립적이 아니라 리소스 간의 관계를 가지게 된다. <br/><br>REST 에서는 이를 컬렉션(Collection) 과 도큐먼트(Document) 라는 개념으로 설명하고 있는데 굳이 그런 설명이 없더라도 직관적으로 이해가 가능하다. 다음 예시 URI 를 보자 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /users/&#123;id&#125;/dogs/</span><br></pre></td></tr></table></figure><p>URI 를 읽어보면 특정 user 가 소유한 (또는 연관된) dogs 의 리스트를 말하는 것임을 직관적으로 알 수 있다. <br/><br>내가 URI 에 표현하고자 하는 자원이 복수인지 단수인지를 명확히 구분하여 복수 자원인 경우에는 s 를 꼭 붙여줘야 RESTful 한 URI 설계가 된다.</p><h3 id="3-snake-case-를-사용하자-하이픈-활용"><a href="#3-snake-case-를-사용하자-하이픈-활용" class="headerlink" title="3) snake-case 를 사용하자. 하이픈 활용"></a>3) snake-case 를 사용하자. 하이픈 활용</h3><p>URI 로 자원을 표현하고 싶을 때 공백을 두어 단어간의 의미를 명확히 구분하기를 원할 때가 있다. <br/><br>예를 들어보면, 현재 시스템에서 유 효한 상태의 user 를 얻고자 할 때 URI 설계를 다음과 같이 할 수도 있다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ex) GET /valid user</span><br></pre></td></tr></table></figure><p>그러나 공백이 들어가는 경우 URI 에서는 %20 으로 표현되는데 보기가 안 좋다. 그에 따라 보통 밑줄( _ ) 이나 하이픈 ( - ), 또는 CamelCase 방식으로 작성한다.<br>여기서는 <strong>하이픈 사용을 권장</strong>한다. <br/><br>밑줄을 쓸 경우 링크 표현 시 밑줄이 가려보이는 이슈가 있고, CamelCase 방식은 대소문자가 섞이는 이슈가 있다. </p><blockquote><p>도메인과 달리 URI 레벨에서는 대소문자가 구분된다. 따라서 대소문자를 섞어서 쓸 경우 예상치 못한 이슈가 발생하므로 소문자 통일을 권장한다.</p></blockquote><h3 id="4-확장자를-URI-에-추가하지-말자"><a href="#4-확장자를-URI-에-추가하지-말자" class="headerlink" title="4) 확장자를 URI 에 추가하지 말자"></a>4) 확장자를 URI 에 추가하지 말자</h3><p>URI 는 리소스의 표현이고 이는 플랫폼이나 클라이언트의 요청 자원 형태에 독립적이어야 한다. <br/><br>따라서 동일한 자원에 대해 .txt / .csv 등의 확장자는 붙이지 말아야 한다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">확장자가 포함된 URI</span><br><span class="line"></span><br><span class="line">   GET /groups/14/users.txt</span><br><span class="line">   GET /groups/14/users.csv</span><br></pre></td></tr></table></figure><p>예시에서는 group 아이디 14번이 가지는 users 의 리스트를 표현하는데 각각의 응답 형태가 txt 와 csv 임을 알 수 있다. 하지만 리소스 자체는 group 아이디 14번이 가지는 user 리스트이므로 둘 간의 차이는 없다. <br/><br>클라이언트가 원하는 리소스 형태에 따라 대응하고 싶다면 HTTP header 에서 Accept 를 활용하여 미디어 타입에 따른 대응이 가능하도록 구현하면 된다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Accept header 활용</span><br><span class="line"></span><br><span class="line">   GET /hello HTTP/1.1</span><br><span class="line">   Host: remotty.com</span><br><span class="line">   Accept: text/plain</span><br><span class="line">   </span><br><span class="line">   GET /hello HTTP/1.1</span><br><span class="line">   Host: remotty.com</span><br><span class="line">   Accept: text/csv</span><br></pre></td></tr></table></figure><p>Accept 에 따라 서버에서 각각 적절한 응답 형식을 리턴하도록 구현하면 URI 고유의 의미를 지키면서 각 클라이언트 요청이 원하는 형 태의 데이터 리턴이 가능하다.<br>또한 Spring MVC 에서는 Accept 에 따라 메서드 분기가 가능하도록 이미 Controller 의 메서드에 produces / consumes 를 제공하고 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Spring MVC 의 Controller 에서  produces / consumes 활용</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping(method = RequestMethod.GET, produces = &quot;application/json; charset=utf8&quot;, consumes = &quot;application/json; charset=utf8&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity <span class="title">retrieveUser</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Valid</span> UserDto.Retrieve retrieveDto, BindingResult bindingResult)</span> </span>&#123; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://stackoverflow.com/questions/30923249/spring-4-requestmapping-consumes-vs-headers">stackoverflow springmvc requestmapping article</a> 를 꼭 읽어보시길 바람</p></blockquote><p>리소스의 식별과 관련하여 지금까지 제시한 규칙을 따른다면 RESTful 한 구현에 있어서 URI 설계 쪽에는 큰 이슈가 없을 것이다. <br/><br>제시된 4가지 팁 이외에 고민해볼만한 한가지 사항을 더 추가하면 다음과 같다.</p><h3 id="URI-의-버전-정보를-어떻게-표현할-것인가"><a href="#URI-의-버전-정보를-어떻게-표현할-것인가" class="headerlink" title="URI 의 버전 정보를 어떻게 표현할 것인가?"></a>URI 의 버전 정보를 어떻게 표현할 것인가?</h3><p>사실 API의 버전에 상관없이 고유한 URI의 측면에서 생각한다면 URI 에 /v1,/v2 등을 기술하여 관리하는 것은 RESTful 하지 않다.<br>이상적이라면 HTTP 의 header 안에 버전 정보를 기술하여 넣는 것이 맞다. <br/><br>실제로 github 같은 경우 다음과 같이 자체적인 header 를 사용하여 resource 형태와 versioning 을 표현한다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application/vnd.github+json; version=1.0</span><br></pre></td></tr></table></figure><p>header 안에 versioning 을 표현하는 아래와 같은 예시도 있다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">￼curl https://api.stripe.com/v1/charges \</span><br><span class="line">   ‐u sk_test_BQokikJOvBiI2HlWgH4o \</span><br><span class="line">   ‐H &quot;Stripe‐Version: 2017‐06‐05&quot;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://stripe.com/docs/api#versioning">stripe api 예시</a></p></blockquote><p>허나 <a href="https://stackoverflow.com/questions/389169/best-practices-for-api-versioning">best practice for api versioning</a> 와  링크도 있듯이, header 안에 versioning 을 넣는 이상적인 방안 뿐만 아니라 URI 에 /v1, /v2 를 넣는 방식에 대한 논의도 많다. 브라우저에서 직접 /v1, /v2 등을 입력하여 접근하기 좋고, 구현하는 쪽이나 사용하는 쪽 둘 다 편하다는 장점을 생각한다면 URI 에 /v1 등을 사용하는 것이 꼭 나쁘다고는 생각하지 않아도 될 듯 하다.</p><h3 id="참고-링크"><a href="#참고-링크" class="headerlink" title="참고 링크"></a>참고 링크</h3><ul><li><a href="https://spoqa.github.io/2012/02/27/rest-introduction.html">https://spoqa.github.io/2012/02/27/rest-introduction.html</a></li><li><a href="https://spoqa.github.io/2013/06/11/more-restful-interface.html">https://spoqa.github.io/2013/06/11/more-restful-interface.html</a></li><li><a href="http://blog.remotty.com/blog/2014/01/28/lets-study-rest/">http://blog.remotty.com/blog/2014/01/28/lets-study-rest/</a></li><li><a href="http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api">http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api</a></li><li><a href="https://stripe.com/docs/api#versioning">https://stripe.com/docs/api#versioning</a></li><li><a href="https://stackoverflow.com/questions/389169/best-practices-for-api-versioning">https://stackoverflow.com/questions/389169/best-practices-for-api-versioning</a></li><li><a href="https://beyondj2ee.wordpress.com/2013/03/21/%EB%8B%B9%EC%8B%A0%EC%9D%98-api%EA%B0%80-restful-%ED%95%98%EC%A7%80-%EC%95%8A%EC%9D%80-5%EA%B0%80%EC%A7%80-%EC%A6%9D%EA%B1%B0/">https://beyondj2ee.wordpress.com/2013/03/21/%EB%8B%B9%EC%8B%A0%EC%9D%98-api%EA%B0%80-restful-%ED%95%98%EC%A7%80-%EC%95%8A%EC%9D%80-5%EA%B0%80%EC%A7%80-%EC%A6%9D%EA%B1%B0/</a></li><li><a href="http://www.hanbit.co.kr/store/books/look.php?p_code=E9835405237">http://www.hanbit.co.kr/store/books/look.php?p_code=E9835405237</a>  -  이 책의 경우, 목차만 봐도 RESTful 을 다 이해할 것만 같다. </li></ul>]]></content:encoded>
      
      <comments>https://daniel-hebn.github.io/2017/06/23/2017-06-23-RESTful-API-%EA%B0%84%EB%9E%B5%EC%A0%95%EB%A6%AC-1/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
